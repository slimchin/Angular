<html>
	<head>
		<link href="traffic.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<div class="header">Request</div>
		<div class="traffic">
			<div style="color: blue; display: inline"><b>GET</b></div> /ConsentManagementSystem/Content/lib/jquery/dist/jquery.js <div style="color: blue; display: inline"><b>HTTP/1.1</b></div><br/><div style="color: blue; display: inline"><b>Host</b></div>: backofficedev.asiaplus.co.th<br/><div style="color: blue; display: inline"><b>Connection</b></div>: keep-alive<br/><div style="color: blue; display: inline"><b>Accept</b></div>: */*<br/><div style="color: blue; display: inline"><b>User-Agent</b></div>: Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Safari/537.36<br/><div style="color: blue; display: inline"><b>Sec-Fetch-Site</b></div>: same-origin<br/><div style="color: blue; display: inline"><b>Sec-Fetch-Mode</b></div>: no-cors<br/><div style="color: blue; display: inline"><b>Referer</b></div>: https://backofficedev.asiaplus.co.th/ConsentManagementSystem<br/><div style="color: blue; display: inline"><b>Accept-Encoding</b></div>: gzip, deflate, br<br/><div style="color: blue; display: inline"><b>Accept-Language</b></div>: en-US,en;q=0.9<br/><br/>
		</div>
		<div class="header">Response</div>
		<div class="traffic">
			<div style="color: blue; display: inline"><b>HTTP/1.1 200 OK</b></div><br/><div style="color: blue; display: inline"><b>Connection</b></div>: close<br/><div style="color: blue; display: inline"><b>Date</b></div>: Thu, 14 May 2020 02:50:06 GMT<br/><div style="color: blue; display: inline"><b>Content-Length</b></div>: 282115<br/><div style="color: blue; display: inline"><b>Content-Type</b></div>: application/javascript<br/><div style="color: blue; display: inline"><b>Last-Modified</b></div>: Sat, 07 Mar 2020 10:16:11 GMT<br/><div style="color: blue; display: inline"><b>Accept-Ranges</b></div>: bytes<br/><div style="color: blue; display: inline"><b>ETag</b></div>: "7cb576d69f4d51:0"<br/><div style="color: blue; display: inline"><b>Server</b></div>: Microsoft-IIS/8.5<br/><br/>/*!<br/> * jQuery JavaScript Library v3.3.1<br/> * https://jquery.com/<br/> *<br/> * Includes Sizzle.js<br/> * https://sizzlejs.com/<br/> *<br/> * Copyright JS Foundation and other contributors<br/> * Released under the MIT license<br/> * https://jquery.org/license<br/> *<br/> * Date: 2018-01-20T17:24Z<br/> */<br/>( function( global, factory ) {<br/><br/>	"use strict";<br/><br/>	if ( typeof module === "object" &amp;&amp; typeof module.exports === "object" ) {<br/><br/>		// For CommonJS and CommonJS-like environments where a proper `window`<br/>		// is present, execute the factory and get jQuery.<br/>		// For environments that do not have a `window` with a `document`<br/>		// (such as Node.js), expose a factory as module.exports.<br/>		// This accentuates the need for the creation of a real `window`.<br/>		// e.g. var jQuery = require("jquery")(window);<br/>		// See ticket #14549 for more info.<br/>		module.exports = global.document ?<br/>			factory( global, true ) :<br/>			function( w ) {<br/>				if ( !w.document ) {<br/>					throw new Error( "jQuery requires a window with a document" );<br/>				}<br/>				return factory( w );<br/>			};<br/>	} else {<br/>		factory( global );<br/>	}<br/><br/>// Pass this if window is not defined yet<br/>} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {<br/><br/>// Edge &lt;= 12 - 13+, Firefox &lt;=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1<br/>// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode<br/>// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common<br/>// enough that all such attempts are guarded in a try block.<br/>"use strict";<br/><br/>var arr = [];<br/><br/>var document = window.document;<br/><br/>var getProto = Object.getPrototypeOf;<br/><br/>var slice = arr.slice;<br/><br/>var concat = arr.concat;<br/><br/>var push = arr.push;<br/><br/>var indexOf = arr.indexOf;<br/><br/>var class2type = {};<br/><br/>var toString = class2type.toString;<br/><br/>var hasOwn = class2type.hasOwnProperty;<br/><br/>var fnToString = hasOwn.toString;<br/><br/>var ObjectFunctionString = fnToString.call( Object );<br/><br/>var support = {};<br/><br/>var isFunction = function isFunction( obj ) {<br/><br/>      // Support: Chrome &lt;=57, Firefox &lt;=52<br/>      // In some browsers, typeof returns "function" for HTML &lt;object&gt; elements<br/>      // (i.e., `typeof document.createElement( "object" ) === "function"`).<br/>      // We don't want to classify *any* DOM node as a function.<br/>      return typeof obj === "function" &amp;&amp; typeof obj.nodeType !== "number";<br/>  };<br/><br/><br/>var isWindow = function isWindow( obj ) {<br/>		return obj != null &amp;&amp; obj === obj.window;<br/>	};<br/><br/><br/><br/><br/>	var preservedScriptAttributes = {<br/>		type: true,<br/>		src: true,<br/>		noModule: true<br/>	};<br/><br/>	function DOMEval( code, doc, node ) {<br/>		doc = doc || document;<br/><br/>		var i,<br/>			script = doc.createElement( "script" );<br/><br/>		script.text = code;<br/>		if ( node ) {<br/>			for ( i in preservedScriptAttributes ) {<br/>				if ( node[ i ] ) {<br/>					script[ i ] = node[ i ];<br/>				}<br/>			}<br/>		}<br/>		doc.head.appendChild( script ).parentNode.removeChild( script );<br/>	}<br/><br/><br/>function toType( obj ) {<br/>	if ( obj == null ) {<br/>		return obj + "";<br/>	}<br/><br/>	// Support: Android &lt;=2.3 only (functionish RegExp)<br/>	return typeof obj === "object" || typeof obj === "function" ?<br/>		class2type[ toString.call( obj ) ] || "object" :<br/>		typeof obj;<br/>}<br/>/* global Symbol */<br/>// Defining this global in .eslintrc.json would create a danger of using the global<br/>// unguarded in another place, it seems safer to define global only for this module<br/><br/><br/><br/>var<br/>	version = "3.3.1",<br/><br/>	// Define a local copy of jQuery<br/>	jQuery = function( selector, context ) {<br/><br/>		// The jQuery object is actually just the init constructor 'enhanced'<br/>		// Need init if jQuery is called (just allow error to be thrown if not included)<br/>		return new jQuery.fn.init( selector, context );<br/>	},<br/><br/>	// Support: Android &lt;=4.0 only<br/>	// Make sure we trim BOM and NBSP<br/>	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;<br/><br/>jQuery.fn = jQuery.prototype = {<br/><br/>	// The current version of jQuery being used<br/>	jquery: version,<br/><br/>	constructor: jQuery,<br/><br/>	// The default length of a jQuery object is 0<br/>	length: 0,<br/><br/>	toArray: function() {<br/>		return slice.call( this );<br/>	},<br/><br/>	// Get the Nth element in the matched element set OR<br/>	// Get the whole matched element set as a clean array<br/>	get: function( num ) {<br/><br/>		// Return all the elements in a clean array<br/>		if ( num == null ) {<br/>			return slice.call( this );<br/>		}<br/><br/>		// Return just the one element from the set<br/>		return num &lt; 0 ? this[ num + this.length ] : this[ num ];<br/>	},<br/><br/>	// Take an array of elements and push it onto the stack<br/>	// (returning the new matched element set)<br/>	pushStack: function( elems ) {<br/><br/>		// Build a new jQuery matched element set<br/>		var ret = jQuery.merge( this.constructor(), elems );<br/><br/>		// Add the old object onto the stack (as a reference)<br/>		ret.prevObject = this;<br/><br/>		// Return the newly-formed element set<br/>		return ret;<br/>	},<br/><br/>	// Execute a callback for every element in the matched set.<br/>	each: function( callback ) {<br/>		return jQuery.each( this, callback );<br/>	},<br/><br/>	map: function( callback ) {<br/>		return this.pushStack( jQuery.map( this, function( elem, i ) {<br/>			return callback.call( elem, i, elem );<br/>		} ) );<br/>	},<br/><br/>	slice: function() {<br/>		return this.pushStack( slice.apply( this, arguments ) );<br/>	},<br/><br/>	first: function() {<br/>		return this.eq( 0 );<br/>	},<br/><br/>	last: function() {<br/>		return this.eq( -1 );<br/>	},<br/><br/>	eq: function( i ) {<br/>		var len = this.length,<br/>			j = +i + ( i &lt; 0 ? len : 0 );<br/>		return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[ j ] ] : [] );<br/>	},<br/><br/>	end: function() {<br/>		return this.prevObject || this.constructor();<br/>	},<br/><br/>	// For internal use only.<br/>	// Behaves like an Array's method, not like a jQuery method.<br/>	push: push,<br/>	sort: arr.sort,<br/>	splice: arr.splice<br/>};<br/><br/>jQuery.extend = jQuery.fn.extend = function() {<br/>	var options, name, src, copy, copyIsArray, clone,<br/>		target = arguments[ 0 ] || {},<br/>		i = 1,<br/>		length = arguments.length,<br/>		deep = false;<br/><br/>	// Handle a deep copy situation<br/>	if ( typeof target === "boolean" ) {<br/>		deep = target;<br/><br/>		// Skip the boolean and the target<br/>		target = arguments[ i ] || {};<br/>		i++;<br/>	}<br/><br/>	// Handle case when target is a string or something (possible in deep copy)<br/>	if ( typeof target !== "object" &amp;&amp; !isFunction( target ) ) {<br/>		target = {};<br/>	}<br/><br/>	// Extend jQuery itself if only one argument is passed<br/>	if ( i === length ) {<br/>		target = this;<br/>		i--;<br/>	}<br/><br/>	for ( ; i &lt; length; i++ ) {<br/><br/>		// Only deal with non-null/undefined values<br/>		if ( ( options = arguments[ i ] ) != null ) {<br/><br/>			// Extend the base object<br/>			for ( name in options ) {<br/>				src = target[ name ];<br/>				copy = options[ name ];<br/><br/>				// Prevent never-ending loop<br/>				if ( target === copy ) {<br/>					continue;<br/>				}<br/><br/>				// Recurse if we're merging plain objects or arrays<br/>				if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) ||<br/>					( copyIsArray = Array.isArray( copy ) ) ) ) {<br/><br/>					if ( copyIsArray ) {<br/>						copyIsArray = false;<br/>						clone = src &amp;&amp; Array.isArray( src ) ? src : [];<br/><br/>					} else {<br/>						clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : {};<br/>					}<br/><br/>					// Never move original objects, clone them<br/>					target[ name ] = jQuery.extend( deep, clone, copy );<br/><br/>				// Don't bring in undefined values<br/>				} else if ( copy !== undefined ) {<br/>					target[ name ] = copy;<br/>				}<br/>			}<br/>		}<br/>	}<br/><br/>	// Return the modified object<br/>	return target;<br/>};<br/><br/>jQuery.extend( {<br/><br/>	// Unique for each copy of jQuery on the page<br/>	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),<br/><br/>	// Assume jQuery is ready without the ready module<br/>	isReady: true,<br/><br/>	error: function( msg ) {<br/>		throw new Error( msg );<br/>	},<br/><br/>	noop: function() {},<br/><br/>	isPlainObject: function( obj ) {<br/>		var proto, Ctor;<br/><br/>		// Detect obvious negatives<br/>		// Use toString instead of jQuery.type to catch host objects<br/>		if ( !obj || toString.call( obj ) !== "[object Object]" ) {<br/>			return false;<br/>		}<br/><br/>		proto = getProto( obj );<br/><br/>		// Objects with no prototype (e.g., `Object.create( null )`) are plain<br/>		if ( !proto ) {<br/>			return true;<br/>		}<br/><br/>		// Objects with prototype are plain iff they were constructed by a global Object function<br/>		Ctor = hasOwn.call( proto, "constructor" ) &amp;&amp; proto.constructor;<br/>		return typeof Ctor === "function" &amp;&amp; fnToString.call( Ctor ) === ObjectFunctionString;<br/>	},<br/><br/>	isEmptyObject: function( obj ) {<br/><br/>		/* eslint-disable no-unused-vars */<br/>		// See https://github.com/eslint/eslint/issues/6125<br/>		var name;<br/><br/>		for ( name in obj ) {<br/>			return false;<br/>		}<br/>		return true;<br/>	},<br/><br/>	// Evaluates a script in a global context<br/>	globalEval: function( code ) {<br/>		DOMEval( code );<br/>	},<br/><br/>	each: function( obj, callback ) {<br/>		var length, i = 0;<br/><br/>		if ( isArrayLike( obj ) ) {<br/>			length = obj.length;<br/>			for ( ; i &lt; length; i++ ) {<br/>				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {<br/>					break;<br/>				}<br/>			}<br/>		} else {<br/>			for ( i in obj ) {<br/>				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {<br/>					break;<br/>				}<br/>			}<br/>		}<br/><br/>		return obj;<br/>	},<br/><br/>	// Support: Android &lt;=4.0 only<br/>	trim: function( text ) {<br/>		return text == null ?<br/>			"" :<br/>			( text + "" ).replace( rtrim, "" );<br/>	},<br/><br/>	// results is for internal usage only<br/>	makeArray: function( arr, results ) {<br/>		var ret = results || [];<br/><br/>		if ( arr != null ) {<br/>			if ( isArrayLike( Object( arr ) ) ) {<br/>				jQuery.merge( ret,<br/>					typeof arr === "string" ?<br/>					[ arr ] : arr<br/>				);<br/>			} else {<br/>				push.call( ret, arr );<br/>			}<br/>		}<br/><br/>		return ret;<br/>	},<br/><br/>	inArray: function( elem, arr, i ) {<br/>		return arr == null ? -1 : indexOf.call( arr, elem, i );<br/>	},<br/><br/>	// Support: Android &lt;=4.0 only, PhantomJS 1 only<br/>	// push.apply(_, arraylike) throws on ancient WebKit<br/>	merge: function( first, second ) {<br/>		var len = +second.length,<br/>			j = 0,<br/>			i = first.length;<br/><br/>		for ( ; j &lt; len; j++ ) {<br/>			first[ i++ ] = second[ j ];<br/>		}<br/><br/>		first.length = i;<br/><br/>		return first;<br/>	},<br/><br/>	grep: function( elems, callback, invert ) {<br/>		var callbackInverse,<br/>			matches = [],<br/>			i = 0,<br/>			length = elems.length,<br/>			callbackExpect = !invert;<br/><br/>		// Go through the array, only saving the items<br/>		// that pass the validator function<br/>		for ( ; i &lt; length; i++ ) {<br/>			callbackInverse = !callback( elems[ i ], i );<br/>			if ( callbackInverse !== callbackExpect ) {<br/>				matches.push( elems[ i ] );<br/>			}<br/>		}<br/><br/>		return matches;<br/>	},<br/><br/>	// arg is for internal usage only<br/>	map: function( elems, callback, arg ) {<br/>		var length, value,<br/>			i = 0,<br/>			ret = [];<br/><br/>		// Go through the array, translating each of the items to their new values<br/>		if ( isArrayLike( elems ) ) {<br/>			length = elems.length;<br/>			for ( ; i &lt; length; i++ ) {<br/>				value = callback( elems[ i ], i, arg );<br/><br/>				if ( value != null ) {<br/>					ret.push( value );<br/>				}<br/>			}<br/><br/>		// Go through every key on the object,<br/>		} else {<br/>			for ( i in elems ) {<br/>				value = callback( elems[ i ], i, arg );<br/><br/>				if ( value != null ) {<br/>					ret.push( value );<br/>				}<br/>			}<br/>		}<br/><br/>		// Flatten any nested arrays<br/>		return concat.apply( [], ret );<br/>	},<br/><br/>	// A global GUID counter for objects<br/>	guid: 1,<br/><br/>	// jQuery.support is not used in Core but other projects attach their<br/>	// properties to it so it needs to exist.<br/>	support: support<br/>} );<br/><br/>if ( typeof Symbol === "function" ) {<br/>	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];<br/>}<br/><br/>// Populate the class2type map<br/>jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),<br/>function( i, name ) {<br/>	class2type[ "[object " + name + "]" ] = name.toLowerCase();<br/>} );<br/><br/>function isArrayLike( obj ) {<br/><br/>	// Support: real iOS 8.2 only (not reproducible in simulator)<br/>	// `in` check used to prevent JIT error (gh-2145)<br/>	// hasOwn isn't used here due to false negatives<br/>	// regarding Nodelist length in IE<br/>	var length = !!obj &amp;&amp; "length" in obj &amp;&amp; obj.length,<br/>		type = toType( obj );<br/><br/>	if ( isFunction( obj ) || isWindow( obj ) ) {<br/>		return false;<br/>	}<br/><br/>	return type === "array" || length === 0 ||<br/>		typeof length === "number" &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj;<br/>}<br/>var Sizzle =<br/>/*!<br/> * Sizzle CSS Selector Engine v2.3.3<br/> * https://sizzlejs.com/<br/> *<br/> * Copyright jQuery Foundation and other contributors<br/> * Released under the MIT license<br/> * http://jquery.org/license<br/> *<br/> * Date: 2016-08-08<br/> */<br/>(function( window ) {<br/><br/>var i,<br/>	support,<br/>	Expr,<br/>	getText,<br/>	isXML,<br/>	tokenize,<br/>	compile,<br/>	select,<br/>	outermostContext,<br/>	sortInput,<br/>	hasDuplicate,<br/><br/>	// Local document vars<br/>	setDocument,<br/>	document,<br/>	docElem,<br/>	documentIsHTML,<br/>	rbuggyQSA,<br/>	rbuggyMatches,<br/>	matches,<br/>	contains,<br/><br/>	// Instance-specific data<br/>	expando = "sizzle" + 1 * new Date(),<br/>	preferredDoc = window.document,<br/>	dirruns = 0,<br/>	done = 0,<br/>	classCache = createCache(),<br/>	tokenCache = createCache(),<br/>	compilerCache = createCache(),<br/>	sortOrder = function( a, b ) {<br/>		if ( a === b ) {<br/>			hasDuplicate = true;<br/>		}<br/>		return 0;<br/>	},<br/><br/>	// Instance methods<br/>	hasOwn = ({}).hasOwnProperty,<br/>	arr = [],<br/>	pop = arr.pop,<br/>	push_native = arr.push,<br/>	push = arr.push,<br/>	slice = arr.slice,<br/>	// Use a stripped-down indexOf as it's faster than native<br/>	// https://jsperf.com/thor-indexof-vs-for/5<br/>	indexOf = function( list, elem ) {<br/>		var i = 0,<br/>			len = list.length;<br/>		for ( ; i &lt; len; i++ ) {<br/>			if ( list[i] === elem ) {<br/>				return i;<br/>			}<br/>		}<br/>		return -1;<br/>	},<br/><br/>	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",<br/><br/>	// Regular expressions<br/><br/>	// http://www.w3.org/TR/css3-selectors/#whitespace<br/>	whitespace = "[\\x20\\t\\r\\n\\f]",<br/><br/>	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier<br/>	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",<br/><br/>	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors<br/>	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +<br/>		// Operator (capture 2)<br/>		"*([*^$|!~]?=)" + whitespace +<br/>		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"<br/>		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +<br/>		"*\\]",<br/><br/>	pseudos = ":(" + identifier + ")(?:\\((" +<br/>		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:<br/>		// 1. quoted (capture 3; capture 4 or capture 5)<br/>		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +<br/>		// 2. simple (capture 6)<br/>		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +<br/>		// 3. anything else (capture 2)<br/>		".*" +<br/>		")\\)|)",<br/><br/>	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter<br/>	rwhitespace = new RegExp( whitespace + "+", "g" ),<br/>	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),<br/><br/>	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),<br/>	rcombinators = new RegExp( "^" + whitespace + "*([&gt;+~]|" + whitespace + ")" + whitespace + "*" ),<br/><br/>	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),<br/><br/>	rpseudo = new RegExp( pseudos ),<br/>	ridentifier = new RegExp( "^" + identifier + "$" ),<br/><br/>	matchExpr = {<br/>		"ID": new RegExp( "^#(" + identifier + ")" ),<br/>		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),<br/>		"TAG": new RegExp( "^(" + identifier + "|[*])" ),<br/>		"ATTR": new RegExp( "^" + attributes ),<br/>		"PSEUDO": new RegExp( "^" + pseudos ),<br/>		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +<br/>			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +<br/>			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),<br/>		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),<br/>		// For use in libraries implementing .is()<br/>		// We use this for POS matching in `select`<br/>		"needsContext": new RegExp( "^" + whitespace + "*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +<br/>			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )<br/>	},<br/><br/>	rinputs = /^(?:input|select|textarea|button)$/i,<br/>	rheader = /^h\d$/i,<br/><br/>	rnative = /^[^{]+\{\s*\[native \w/,<br/><br/>	// Easily-parseable/retrievable ID or TAG or CLASS selectors<br/>	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,<br/><br/>	rsibling = /[+~]/,<br/><br/>	// CSS escapes<br/>	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters<br/>	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),<br/>	funescape = function( _, escaped, escapedWhitespace ) {<br/>		var high = "0x" + escaped - 0x10000;<br/>		// NaN means non-codepoint<br/>		// Support: Firefox&lt;24<br/>		// Workaround erroneous numeric interpretation of +"0x"<br/>		return high !== high || escapedWhitespace ?<br/>			escaped :<br/>			high &lt; 0 ?<br/>				// BMP codepoint<br/>				String.fromCharCode( high + 0x10000 ) :<br/>				// Supplemental Plane codepoint (surrogate pair)<br/>				String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 );<br/>	},<br/><br/>	// CSS string/identifier serialization<br/>	// https://drafts.csswg.org/cssom/#common-serializing-idioms<br/>	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,<br/>	fcssescape = function( ch, asCodePoint ) {<br/>		if ( asCodePoint ) {<br/><br/>			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER<br/>			if ( ch === "\0" ) {<br/>				return "\uFFFD";<br/>			}<br/><br/>			// Control characters and (dependent upon position) numbers get escaped as code points<br/>			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";<br/>		}<br/><br/>		// Other potentially-special ASCII characters get backslash-escaped<br/>		return "\\" + ch;<br/>	},<br/><br/>	// Used for iframes<br/>	// See setDocument()<br/>	// Removing the function wrapper causes a "Permission Denied"<br/>	// error in IE<br/>	unloadHandler = function() {<br/>		setDocument();<br/>	},<br/><br/>	disabledAncestor = addCombinator(<br/>		function( elem ) {<br/>			return elem.disabled === true &amp;&amp; ("form" in elem || "label" in elem);<br/>		},<br/>		{ dir: "parentNode", next: "legend" }<br/>	);<br/><br/>// Optimize for push.apply( _, NodeList )<br/>try {<br/>	push.apply(<br/>		(arr = slice.call( preferredDoc.childNodes )),<br/>		preferredDoc.childNodes<br/>	);<br/>	// Support: Android&lt;4.0<br/>	// Detect silently failing push.apply<br/>	arr[ preferredDoc.childNodes.length ].nodeType;<br/>} catch ( e ) {<br/>	push = { apply: arr.length ?<br/><br/>		// Leverage slice if possible<br/>		function( target, els ) {<br/>			push_native.apply( target, slice.call(els) );<br/>		} :<br/><br/>		// Support: IE&lt;9<br/>		// Otherwise append directly<br/>		function( target, els ) {<br/>			var j = target.length,<br/>				i = 0;<br/>			// Can't trust NodeList.length<br/>			while ( (target[j++] = els[i++]) ) {}<br/>			target.length = j - 1;<br/>		}<br/>	};<br/>}<br/><br/>function Sizzle( selector, context, results, seed ) {<br/>	var m, i, elem, nid, match, groups, newSelector,<br/>		newContext = context &amp;&amp; context.ownerDocument,<br/><br/>		// nodeType defaults to 9, since context defaults to document<br/>		nodeType = context ? context.nodeType : 9;<br/><br/>	results = results || [];<br/><br/>	// Return early from calls with invalid selector or context<br/>	if ( typeof selector !== "string" || !selector ||<br/>		nodeType !== 1 &amp;&amp; nodeType !== 9 &amp;&amp; nodeType !== 11 ) {<br/><br/>		return results;<br/>	}<br/><br/>	// Try to shortcut find operations (as opposed to filters) in HTML documents<br/>	if ( !seed ) {<br/><br/>		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {<br/>			setDocument( context );<br/>		}<br/>		context = context || document;<br/><br/>		if ( documentIsHTML ) {<br/><br/>			// If the selector is sufficiently simple, try using a "get*By*" DOM method<br/>			// (excepting DocumentFragment context, where the methods don't exist)<br/>			if ( nodeType !== 11 &amp;&amp; (match = rquickExpr.exec( selector )) ) {<br/><br/>				// ID selector<br/>				if ( (m = match[1]) ) {<br/><br/>					// Document context<br/>					if ( nodeType === 9 ) {<br/>						if ( (elem = context.getElementById( m )) ) {<br/><br/>							// Support: IE, Opera, Webkit<br/>							// TODO: identify versions<br/>							// getElementById can match elements by name instead of ID<br/>							if ( elem.id === m ) {<br/>								results.push( elem );<br/>								return results;<br/>							}<br/>						} else {<br/>							return results;<br/>						}<br/><br/>					// Element context<br/>					} else {<br/><br/>						// Support: IE, Opera, Webkit<br/>						// TODO: identify versions<br/>						// getElementById can match elements by name instead of ID<br/>						if ( newContext &amp;&amp; (elem = newContext.getElementById( m )) &amp;&amp;<br/>							contains( context, elem ) &amp;&amp;<br/>							elem.id === m ) {<br/><br/>							results.push( elem );<br/>							return results;<br/>						}<br/>					}<br/><br/>				// Type selector<br/>				} else if ( match[2] ) {<br/>					push.apply( results, context.getElementsByTagName( selector ) );<br/>					return results;<br/><br/>				// Class selector<br/>				} else if ( (m = match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp;<br/>					context.getElementsByClassName ) {<br/><br/>					push.apply( results, context.getElementsByClassName( m ) );<br/>					return results;<br/>				}<br/>			}<br/><br/>			// Take advantage of querySelectorAll<br/>			if ( support.qsa &amp;&amp;<br/>				!compilerCache[ selector + " " ] &amp;&amp;<br/>				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {<br/><br/>				if ( nodeType !== 1 ) {<br/>					newContext = context;<br/>					newSelector = selector;<br/><br/>				// qSA looks outside Element context, which is not what we want<br/>				// Thanks to Andrew Dupont for this workaround technique<br/>				// Support: IE &lt;=8<br/>				// Exclude object elements<br/>				} else if ( context.nodeName.toLowerCase() !== "object" ) {<br/><br/>					// Capture the context ID, setting it first if necessary<br/>					if ( (nid = context.getAttribute( "id" )) ) {<br/>						nid = nid.replace( rcssescape, fcssescape );<br/>					} else {<br/>						context.setAttribute( "id", (nid = expando) );<br/>					}<br/><br/>					// Prefix every selector in the list<br/>					groups = tokenize( selector );<br/>					i = groups.length;<br/>					while ( i-- ) {<br/>						groups[i] = "#" + nid + " " + toSelector( groups[i] );<br/>					}<br/>					newSelector = groups.join( "," );<br/><br/>					// Expand context for sibling selectors<br/>					newContext = rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) ||<br/>						context;<br/>				}<br/><br/>				if ( newSelector ) {<br/>					try {<br/>						push.apply( results,<br/>							newContext.querySelectorAll( newSelector )<br/>						);<br/>						return results;<br/>					} catch ( qsaError ) {<br/>					} finally {<br/>						if ( nid === expando ) {<br/>							context.removeAttribute( "id" );<br/>						}<br/>					}<br/>				}<br/>			}<br/>		}<br/>	}<br/><br/>	// All others<br/>	return select( selector.replace( rtrim, "$1" ), context, results, seed );<br/>}<br/><br/>/**<br/> * Create key-value caches of limited size<br/> * @returns {function(string, object)} Returns the Object data after storing it on itself with<br/> *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)<br/> *	deleting the oldest entry<br/> */<br/>function createCache() {<br/>	var keys = [];<br/><br/>	function cache( key, value ) {<br/>		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)<br/>		if ( keys.push( key + " " ) &gt; Expr.cacheLength ) {<br/>			// Only keep the most recent entries<br/>			delete cache[ keys.shift() ];<br/>		}<br/>		return (cache[ key + " " ] = value);<br/>	}<br/>	return cache;<br/>}<br/><br/>/**<br/> * Mark a function for special use by Sizzle<br/> * @param {Function} fn The function to mark<br/> */<br/>function markFunction( fn ) {<br/>	fn[ expando ] = true;<br/>	return fn;<br/>}<br/><br/>/**<br/> * Support testing using an element<br/> * @param {Function} fn Passed the created element and returns a boolean result<br/> */<br/>function assert( fn ) {<br/>	var el = document.createElement("fieldset");<br/><br/>	try {<br/>		return !!fn( el );<br/>	} catch (e) {<br/>		return false;<br/>	} finally {<br/>		// Remove from its parent by default<br/>		if ( el.parentNode ) {<br/>			el.parentNode.removeChild( el );<br/>		}<br/>		// release memory in IE<br/>		el = null;<br/>	}<br/>}<br/><br/>/**<br/> * Adds the same handler for all of the specified attrs<br/> * @param {String} attrs Pipe-separated list of attributes<br/> * @param {Function} handler The method that will be applied<br/> */<br/>function addHandle( attrs, handler ) {<br/>	var arr = attrs.split("|"),<br/>		i = arr.length;<br/><br/>	while ( i-- ) {<br/>		Expr.attrHandle[ arr[i] ] = handler;<br/>	}<br/>}<br/><br/>/**<br/> * Checks document order of two siblings<br/> * @param {Element} a<br/> * @param {Element} b<br/> * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b<br/> */<br/>function siblingCheck( a, b ) {<br/>	var cur = b &amp;&amp; a,<br/>		diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp;<br/>			a.sourceIndex - b.sourceIndex;<br/><br/>	// Use IE sourceIndex if available on both nodes<br/>	if ( diff ) {<br/>		return diff;<br/>	}<br/><br/>	// Check if b follows a<br/>	if ( cur ) {<br/>		while ( (cur = cur.nextSibling) ) {<br/>			if ( cur === b ) {<br/>				return -1;<br/>			}<br/>		}<br/>	}<br/><br/>	return a ? 1 : -1;<br/>}<br/><br/>/**<br/> * Returns a function to use in pseudos for input types<br/> * @param {String} type<br/> */<br/>function createInputPseudo( type ) {<br/>	return function( elem ) {<br/>		var name = elem.nodeName.toLowerCase();<br/>		return name === "input" &amp;&amp; elem.type === type;<br/>	};<br/>}<br/><br/>/**<br/> * Returns a function to use in pseudos for buttons<br/> * @param {String} type<br/> */<br/>function createButtonPseudo( type ) {<br/>	return function( elem ) {<br/>		var name = elem.nodeName.toLowerCase();<br/>		return (name === "input" || name === "button") &amp;&amp; elem.type === type;<br/>	};<br/>}<br/><br/>/**<br/> * Returns a function to use in pseudos for :enabled/:disabled<br/> * @param {Boolean} disabled true for :disabled; false for :enabled<br/> */<br/>function createDisabledPseudo( disabled ) {<br/><br/>	// Known :disabled false positives: fieldset[disabled] &gt; legend:nth-of-type(n+2) :can-disable<br/>	return function( elem ) {<br/><br/>		// Only certain elements can match :enabled or :disabled<br/>		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled<br/>		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled<br/>		if ( "form" in elem ) {<br/><br/>			// Check for inherited disabledness on relevant non-disabled elements:<br/>			// * listed form-associated elements in a disabled fieldset<br/>			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed<br/>			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled<br/>			// * option elements in a disabled optgroup<br/>			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled<br/>			// All such elements have a "form" property.<br/>			if ( elem.parentNode &amp;&amp; elem.disabled === false ) {<br/><br/>				// Option elements defer to a parent optgroup if present<br/>				if ( "label" in elem ) {<br/>					if ( "label" in elem.parentNode ) {<br/>						return elem.parentNode.disabled === disabled;<br/>					} else {<br/>						return elem.disabled === disabled;<br/>					}<br/>				}<br/><br/>				// Support: IE 6 - 11<br/>				// Use the isDisabled shortcut property to check for disabled fieldset ancestors<br/>				return elem.isDisabled === disabled ||<br/><br/>					// Where there is no isDisabled, check manually<br/>					/* jshint -W018 */<br/>					elem.isDisabled !== !disabled &amp;&amp;<br/>						disabledAncestor( elem ) === disabled;<br/>			}<br/><br/>			return elem.disabled === disabled;<br/><br/>		// Try to winnow out elements that can't be disabled before trusting the disabled property.<br/>		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't<br/>		// even exist on them, let alone have a boolean value.<br/>		} else if ( "label" in elem ) {<br/>			return elem.disabled === disabled;<br/>		}<br/><br/>		// Remaining elements are neither :enabled nor :disabled<br/>		return false;<br/>	};<br/>}<br/><br/>/**<br/> * Returns a function to use in pseudos for positionals<br/> * @param {Function} fn<br/> */<br/>function createPositionalPseudo( fn ) {<br/>	return markFunction(function( argument ) {<br/>		argument = +argument;<br/>		return markFunction(function( seed, matches ) {<br/>			var j,<br/>				matchIndexes = fn( [], seed.length, argument ),<br/>				i = matchIndexes.length;<br/><br/>			// Match elements found at the specified indexes<br/>			while ( i-- ) {<br/>				if ( seed[ (j = matchIndexes[i]) ] ) {<br/>					seed[j] = !(matches[j] = seed[j]);<br/>				}<br/>			}<br/>		});<br/>	});<br/>}<br/><br/>/**<br/> * Checks a node for validity as a Sizzle context<br/> * @param {Element|Object=} context<br/> * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value<br/> */<br/>function testContext( context ) {<br/>	return context &amp;&amp; typeof context.getElementsByTagName !== "undefined" &amp;&amp; context;<br/>}<br/><br/>// Expose support vars for convenience<br/>support = Sizzle.support = {};<br/><br/>/**<br/> * Detects XML nodes<br/> * @param {Element|Object} elem An element or a document<br/> * @returns {Boolean} True iff elem is a non-HTML XML node<br/> */<br/>isXML = Sizzle.isXML = function( elem ) {<br/>	// documentElement is verified for cases where it doesn't yet exist<br/>	// (such as loading iframes in IE - #4833)<br/>	var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;<br/>	return documentElement ? documentElement.nodeName !== "HTML" : false;<br/>};<br/><br/>/**<br/> * Sets document-related variables once based on the current document<br/> * @param {Element|Object} [doc] An element or document object to use to set the document<br/> * @returns {Object} Returns the current document<br/> */<br/>setDocument = Sizzle.setDocument = function( node ) {<br/>	var hasCompare, subWindow,<br/>		doc = node ? node.ownerDocument || node : preferredDoc;<br/><br/>	// Return early if doc is invalid or already selected<br/>	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {<br/>		return document;<br/>	}<br/><br/>	// Update global variables<br/>	document = doc;<br/>	docElem = document.documentElement;<br/>	documentIsHTML = !isXML( document );<br/><br/>	// Support: IE 9-11, Edge<br/>	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)<br/>	if ( preferredDoc !== document &amp;&amp;<br/>		(subWindow = document.defaultView) &amp;&amp; subWindow.top !== subWindow ) {<br/><br/>		// Support: IE 11, Edge<br/>		if ( subWindow.addEventListener ) {<br/>			subWindow.addEventListener( "unload", unloadHandler, false );<br/><br/>		// Support: IE 9 - 10 only<br/>		} else if ( subWindow.attachEvent ) {<br/>			subWindow.attachEvent( "onunload", unloadHandler );<br/>		}<br/>	}<br/><br/>	/* Attributes<br/>	---------------------------------------------------------------------- */<br/><br/>	// Support: IE&lt;8<br/>	// Verify that getAttribute really returns attributes and not properties<br/>	// (excepting IE8 booleans)<br/>	support.attributes = assert(function( el ) {<br/>		el.className = "i";<br/>		return !el.getAttribute("className");<br/>	});<br/><br/>	/* getElement(s)By*<br/>	---------------------------------------------------------------------- */<br/><br/>	// Check if getElementsByTagName("*") returns only elements<br/>	support.getElementsByTagName = assert(function( el ) {<br/>		el.appendChild( document.createComment("") );<br/>		return !el.getElementsByTagName("*").length;<br/>	});<br/><br/>	// Support: IE&lt;9<br/>	support.getElementsByClassName = rnative.test( document.getElementsByClassName );<br/><br/>	// Support: IE&lt;10<br/>	// Check if getElementById returns elements by name<br/>	// The broken getElementById methods don't pick up programmatically-set names,<br/>	// so use a roundabout getElementsByName test<br/>	support.getById = assert(function( el ) {<br/>		docElem.appendChild( el ).id = expando;<br/>		return !document.getElementsByName || !document.getElementsByName( expando ).length;<br/>	});<br/><br/>	// ID filter and find<br/>	if ( support.getById ) {<br/>		Expr.filter["ID"] = function( id ) {<br/>			var attrId = id.replace( runescape, funescape );<br/>			return function( elem ) {<br/>				return elem.getAttribute("id") === attrId;<br/>			};<br/>		};<br/>		Expr.find["ID"] = function( id, context ) {<br/>			if ( typeof context.getElementById !== "undefined" &amp;&amp; documentIsHTML ) {<br/>				var elem = context.getElementById( id );<br/>				return elem ? [ elem ] : [];<br/>			}<br/>		};<br/>	} else {<br/>		Expr.filter["ID"] =  function( id ) {<br/>			var attrId = id.replace( runescape, funescape );<br/>			return function( elem ) {<br/>				var node = typeof elem.getAttributeNode !== "undefined" &amp;&amp;<br/>					elem.getAttributeNode("id");<br/>				return node &amp;&amp; node.value === attrId;<br/>			};<br/>		};<br/><br/>		// Support: IE 6 - 7 only<br/>		// getElementById is not reliable as a find shortcut<br/>		Expr.find["ID"] = function( id, context ) {<br/>			if ( typeof context.getElementById !== "undefined" &amp;&amp; documentIsHTML ) {<br/>				var node, i, elems,<br/>					elem = context.getElementById( id );<br/><br/>				if ( elem ) {<br/><br/>					// Verify the id attribute<br/>					node = elem.getAttributeNode("id");<br/>					if ( node &amp;&amp; node.value === id ) {<br/>						return [ elem ];<br/>					}<br/><br/>					// Fall back on getElementsByName<br/>					elems = context.getElementsByName( id );<br/>					i = 0;<br/>					while ( (elem = elems[i++]) ) {<br/>						node = elem.getAttributeNode("id");<br/>						if ( node &amp;&amp; node.value === id ) {<br/>							return [ elem ];<br/>						}<br/>					}<br/>				}<br/><br/>				return [];<br/>			}<br/>		};<br/>	}<br/><br/>	// Tag<br/>	Expr.find["TAG"] = support.getElementsByTagName ?<br/>		function( tag, context ) {<br/>			if ( typeof context.getElementsByTagName !== "undefined" ) {<br/>				return context.getElementsByTagName( tag );<br/><br/>			// DocumentFragment nodes don't have gEBTN<br/>			} else if ( support.qsa ) {<br/>				return context.querySelectorAll( tag );<br/>			}<br/>		} :<br/><br/>		function( tag, context ) {<br/>			var elem,<br/>				tmp = [],<br/>				i = 0,<br/>				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too<br/>				results = context.getElementsByTagName( tag );<br/><br/>			// Filter out possible comments<br/>			if ( tag === "*" ) {<br/>				while ( (elem = results[i++]) ) {<br/>					if ( elem.nodeType === 1 ) {<br/>						tmp.push( elem );<br/>					}<br/>				}<br/><br/>				return tmp;<br/>			}<br/>			return results;<br/>		};<br/><br/>	// Class<br/>	Expr.find["CLASS"] = support.getElementsByClassName &amp;&amp; function( className, context ) {<br/>		if ( typeof context.getElementsByClassName !== "undefined" &amp;&amp; documentIsHTML ) {<br/>			return context.getElementsByClassName( className );<br/>		}<br/>	};<br/><br/>	/* QSA/matchesSelector<br/>	---------------------------------------------------------------------- */<br/><br/>	// QSA and matchesSelector support<br/><br/>	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)<br/>	rbuggyMatches = [];<br/><br/>	// qSa(:focus) reports false when true (Chrome 21)<br/>	// We allow this because of a bug in IE8/9 that throws an error<br/>	// whenever `document.activeElement` is accessed on an iframe<br/>	// So, we allow :focus to pass through QSA all the time to avoid the IE error<br/>	// See https://bugs.jquery.com/ticket/13378<br/>	rbuggyQSA = [];<br/><br/>	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {<br/>		// Build QSA regex<br/>		// Regex strategy adopted from Diego Perini<br/>		assert(function( el ) {<br/>			// Select is set to empty string on purpose<br/>			// This is to test IE's treatment of not explicitly<br/>			// setting a boolean content attribute,<br/>			// since its presence should be enough<br/>			// https://bugs.jquery.com/ticket/12359<br/>			docElem.appendChild( el ).innerHTML = "&lt;a id='" + expando + "'&gt;&lt;/a&gt;" +<br/>				"&lt;select id='" + expando + "-\r\\' msallowcapture=''&gt;" +<br/>				"&lt;option selected=''&gt;&lt;/option&gt;&lt;/select&gt;";<br/><br/>			// Support: IE8, Opera 11-12.16<br/>			// Nothing should be selected when empty strings follow ^= or $= or *=<br/>			// The test attribute must be unknown in Opera but "safe" for WinRT<br/>			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section<br/>			if ( el.querySelectorAll("[msallowcapture^='']").length ) {<br/>				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );<br/>			}<br/><br/>			// Support: IE8<br/>			// Boolean attributes and "value" are not treated correctly<br/>			if ( !el.querySelectorAll("[selected]").length ) {<br/>				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );<br/>			}<br/><br/>			// Support: Chrome&lt;29, Android&lt;4.4, Safari&lt;7.0+, iOS&lt;7.0+, PhantomJS&lt;1.9.8+<br/>			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {<br/>				rbuggyQSA.push("~=");<br/>			}<br/><br/>			// Webkit/Opera - :checked should return selected option elements<br/>			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked<br/>			// IE8 throws error here and will not see later tests<br/>			if ( !el.querySelectorAll(":checked").length ) {<br/>				rbuggyQSA.push(":checked");<br/>			}<br/><br/>			// Support: Safari 8+, iOS 8+<br/>			// https://bugs.webkit.org/show_bug.cgi?id=136851<br/>			// In-page `selector#id sibling-combinator selector` fails<br/>			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {<br/>				rbuggyQSA.push(".#.+[+~]");<br/>			}<br/>		});<br/><br/>		assert(function( el ) {<br/>			el.innerHTML = "&lt;a href='' disabled='disabled'&gt;&lt;/a&gt;" +<br/>				"&lt;select disabled='disabled'&gt;&lt;option/&gt;&lt;/select&gt;";<br/><br/>			// Support: Windows 8 Native Apps<br/>			// The type and name attributes are restricted during .innerHTML assignment<br/>			var input = document.createElement("input");<br/>			input.setAttribute( "type", "hidden" );<br/>			el.appendChild( input ).setAttribute( "name", "D" );<br/><br/>			// Support: IE8<br/>			// Enforce case-sensitivity of name attribute<br/>			if ( el.querySelectorAll("[name=d]").length ) {<br/>				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );<br/>			}<br/><br/>			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)<br/>			// IE8 throws error here and will not see later tests<br/>			if ( el.querySelectorAll(":enabled").length !== 2 ) {<br/>				rbuggyQSA.push( ":enabled", ":disabled" );<br/>			}<br/><br/>			// Support: IE9-11+<br/>			// IE's :disabled selector does not pick up the children of disabled fieldsets<br/>			docElem.appendChild( el ).disabled = true;<br/>			if ( el.querySelectorAll(":disabled").length !== 2 ) {<br/>				rbuggyQSA.push( ":enabled", ":disabled" );<br/>			}<br/><br/>			// Opera 10-11 does not throw on post-comma invalid pseudos<br/>			el.querySelectorAll("*,:x");<br/>			rbuggyQSA.push(",.*:");<br/>		});<br/>	}<br/><br/>	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||<br/>		docElem.webkitMatchesSelector ||<br/>		docElem.mozMatchesSelector ||<br/>		docElem.oMatchesSelector ||<br/>		docElem.msMatchesSelector) )) ) {<br/><br/>		assert(function( el ) {<br/>			// Check to see if it's possible to do matchesSelector<br/>			// on a disconnected node (IE 9)<br/>			support.disconnectedMatch = matches.call( el, "*" );<br/><br/>			// This should fail with an exception<br/>			// Gecko does not error, returns false instead<br/>			matches.call( el, "[s!='']:x" );<br/>			rbuggyMatches.push( "!=", pseudos );<br/>		});<br/>	}<br/><br/>	rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp( rbuggyQSA.join("|") );<br/>	rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp( rbuggyMatches.join("|") );<br/><br/>	/* Contains<br/>	---------------------------------------------------------------------- */<br/>	hasCompare = rnative.test( docElem.compareDocumentPosition );<br/><br/>	// Element contains another<br/>	// Purposefully self-exclusive<br/>	// As in, an element does not contain itself<br/>	contains = hasCompare || rnative.test( docElem.contains ) ?<br/>		function( a, b ) {<br/>			var adown = a.nodeType === 9 ? a.documentElement : a,<br/>				bup = b &amp;&amp; b.parentNode;<br/>			return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (<br/>				adown.contains ?<br/>					adown.contains( bup ) :<br/>					a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16<br/>			));<br/>		} :<br/>		function( a, b ) {<br/>			if ( b ) {<br/>				while ( (b = b.parentNode) ) {<br/>					if ( b === a ) {<br/>						return true;<br/>					}<br/>				}<br/>			}<br/>			return false;<br/>		};<br/><br/>	/* Sorting<br/>	---------------------------------------------------------------------- */<br/><br/>	// Document order sorting<br/>	sortOrder = hasCompare ?<br/>	function( a, b ) {<br/><br/>		// Flag for duplicate removal<br/>		if ( a === b ) {<br/>			hasDuplicate = true;<br/>			return 0;<br/>		}<br/><br/>		// Sort on method existence if only one input has compareDocumentPosition<br/>		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;<br/>		if ( compare ) {<br/>			return compare;<br/>		}<br/><br/>		// Calculate position if both inputs belong to the same document<br/>		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?<br/>			a.compareDocumentPosition( b ) :<br/><br/>			// Otherwise we know they are disconnected<br/>			1;<br/><br/>		// Disconnected nodes<br/>		if ( compare &amp; 1 ||<br/>			(!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) {<br/><br/>			// Choose the first element that is related to our preferred document<br/>			if ( a === document || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a) ) {<br/>				return -1;<br/>			}<br/>			if ( b === document || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b) ) {<br/>				return 1;<br/>			}<br/><br/>			// Maintain original order<br/>			return sortInput ?<br/>				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :<br/>				0;<br/>		}<br/><br/>		return compare &amp; 4 ? -1 : 1;<br/>	} :<br/>	function( a, b ) {<br/>		// Exit early if the nodes are identical<br/>		if ( a === b ) {<br/>			hasDuplicate = true;<br/>			return 0;<br/>		}<br/><br/>		var cur,<br/>			i = 0,<br/>			aup = a.parentNode,<br/>			bup = b.parentNode,<br/>			ap = [ a ],<br/>			bp = [ b ];<br/><br/>		// Parentless nodes are either documents or disconnected<br/>		if ( !aup || !bup ) {<br/>			return a === document ? -1 :<br/>				b === document ? 1 :<br/>				aup ? -1 :<br/>				bup ? 1 :<br/>				sortInput ?<br/>				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :<br/>				0;<br/><br/>		// If the nodes are siblings, we can do a quick check<br/>		} else if ( aup === bup ) {<br/>			return siblingCheck( a, b );<br/>		}<br/><br/>		// Otherwise we need full lists of their ancestors for comparison<br/>		cur = a;<br/>		while ( (cur = cur.parentNode) ) {<br/>			ap.unshift( cur );<br/>		}<br/>		cur = b;<br/>		while ( (cur = cur.parentNode) ) {<br/>			bp.unshift( cur );<br/>		}<br/><br/>		// Walk down the tree looking for a discrepancy<br/>		while ( ap[i] === bp[i] ) {<br/>			i++;<br/>		}<br/><br/>		return i ?<br/>			// Do a sibling check if the nodes have a common ancestor<br/>			siblingCheck( ap[i], bp[i] ) :<br/><br/>			// Otherwise nodes in our document sort first<br/>			ap[i] === preferredDoc ? -1 :<br/>			bp[i] === preferredDoc ? 1 :<br/>			0;<br/>	};<br/><br/>	return document;<br/>};<br/><br/>Sizzle.matches = function( expr, elements ) {<br/>	return Sizzle( expr, null, null, elements );<br/>};<br/><br/>Sizzle.matchesSelector = function( elem, expr ) {<br/>	// Set document vars if needed<br/>	if ( ( elem.ownerDocument || elem ) !== document ) {<br/>		setDocument( elem );<br/>	}<br/><br/>	// Make sure that attribute selectors are quoted<br/>	expr = expr.replace( rattributeQuotes, "='$1']" );<br/><br/>	if ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;<br/>		!compilerCache[ expr + " " ] &amp;&amp;<br/>		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp;<br/>		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {<br/><br/>		try {<br/>			var ret = matches.call( elem, expr );<br/><br/>			// IE 9's matchesSelector returns false on disconnected nodes<br/>			if ( ret || support.disconnectedMatch ||<br/>					// As well, disconnected nodes are said to be in a document<br/>					// fragment in IE 9<br/>					elem.document &amp;&amp; elem.document.nodeType !== 11 ) {<br/>				return ret;<br/>			}<br/>		} catch (e) {}<br/>	}<br/><br/>	return Sizzle( expr, document, null, [ elem ] ).length &gt; 0;<br/>};<br/><br/>Sizzle.contains = function( context, elem ) {<br/>	// Set document vars if needed<br/>	if ( ( context.ownerDocument || context ) !== document ) {<br/>		setDocument( context );<br/>	}<br/>	return contains( context, elem );<br/>};<br/><br/>Sizzle.attr = function( elem, name ) {<br/>	// Set document vars if needed<br/>	if ( ( elem.ownerDocument || elem ) !== document ) {<br/>		setDocument( elem );<br/>	}<br/><br/>	var fn = Expr.attrHandle[ name.toLowerCase() ],<br/>		// Don't get fooled by Object.prototype properties (jQuery #13807)<br/>		val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?<br/>			fn( elem, name, !documentIsHTML ) :<br/>			undefined;<br/><br/>	return val !== undefined ?<br/>		val :<br/>		support.attributes || !documentIsHTML ?<br/>			elem.getAttribute( name ) :<br/>			(val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?<br/>				val.value :<br/>				null;<br/>};<br/><br/>Sizzle.escape = function( sel ) {<br/>	return (sel + "").replace( rcssescape, fcssescape );<br/>};<br/><br/>Sizzle.error = function( msg ) {<br/>	throw new Error( "Syntax error, unrecognized expression: " + msg );<br/>};<br/><br/>/**<br/> * Document sorting and removing duplicates<br/> * @param {ArrayLike} results<br/> */<br/>Sizzle.uniqueSort = function( results ) {<br/>	var elem,<br/>		duplicates = [],<br/>		j = 0,<br/>		i = 0;<br/><br/>	// Unless we *know* we can detect duplicates, assume their presence<br/>	hasDuplicate = !support.detectDuplicates;<br/>	sortInput = !support.sortStable &amp;&amp; results.slice( 0 );<br/>	results.sort( sortOrder );<br/><br/>	if ( hasDuplicate ) {<br/>		while ( (elem = results[i++]) ) {<br/>			if ( elem === results[ i ] ) {<br/>				j = duplicates.push( i );<br/>			}<br/>		}<br/>		while ( j-- ) {<br/>			results.splice( duplicates[ j ], 1 );<br/>		}<br/>	}<br/><br/>	// Clear input after sorting to release objects<br/>	// See https://github.com/jquery/sizzle/pull/225<br/>	sortInput = null;<br/><br/>	return results;<br/>};<br/><br/>/**<br/> * Utility function for retrieving the text value of an array of DOM nodes<br/> * @param {Array|Element} elem<br/> */<br/>getText = Sizzle.getText = function( elem ) {<br/>	var node,<br/>		ret = "",<br/>		i = 0,<br/>		nodeType = elem.nodeType;<br/><br/>	if ( !nodeType ) {<br/>		// If no nodeType, this is expected to be an array<br/>		while ( (node = elem[i++]) ) {<br/>			// Do not traverse comment nodes<br/>			ret += getText( node );<br/>		}<br/>	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {<br/>		// Use textContent for elements<br/>		// innerText usage removed for consistency of new lines (jQuery #11153)<br/>		if ( typeof elem.textContent === "string" ) {<br/>			return elem.textContent;<br/>		} else {<br/>			// Traverse its children<br/>			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {<br/>				ret += getText( elem );<br/>			}<br/>		}<br/>	} else if ( nodeType === 3 || nodeType === 4 ) {<br/>		return elem.nodeValue;<br/>	}<br/>	// Do not include comment or processing instruction nodes<br/><br/>	return ret;<br/>};<br/><br/>Expr = Sizzle.selectors = {<br/><br/>	// Can be adjusted by the user<br/>	cacheLength: 50,<br/><br/>	createPseudo: markFunction,<br/><br/>	match: matchExpr,<br/><br/>	attrHandle: {},<br/><br/>	find: {},<br/><br/>	relative: {<br/>		"&gt;": { dir: "parentNode", first: true },<br/>		" ": { dir: "parentNode" },<br/>		"+": { dir: "previousSibling", first: true },<br/>		"~": { dir: "previousSibling" }<br/>	},<br/><br/>	preFilter: {<br/>		"ATTR": function( match ) {<br/>			match[1] = match[1].replace( runescape, funescape );<br/><br/>			// Move the given value to match[3] whether quoted or unquoted<br/>			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );<br/><br/>			if ( match[2] === "~=" ) {<br/>				match[3] = " " + match[3] + " ";<br/>			}<br/><br/>			return match.slice( 0, 4 );<br/>		},<br/><br/>		"CHILD": function( match ) {<br/>			/* matches from matchExpr["CHILD"]<br/>				1 type (only|nth|...)<br/>				2 what (child|of-type)<br/>				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)<br/>				4 xn-component of xn+y argument ([+-]?\d*n|)<br/>				5 sign of xn-component<br/>				6 x of xn-component<br/>				7 sign of y-component<br/>				8 y of y-component<br/>			*/<br/>			match[1] = match[1].toLowerCase();<br/><br/>			if ( match[1].slice( 0, 3 ) === "nth" ) {<br/>				// nth-* requires argument<br/>				if ( !match[3] ) {<br/>					Sizzle.error( match[0] );<br/>				}<br/><br/>				// numeric x and y parameters for Expr.filter.CHILD<br/>				// remember that false/true cast respectively to 0/1<br/>				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );<br/>				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );<br/><br/>			// other types prohibit arguments<br/>			} else if ( match[3] ) {<br/>				Sizzle.error( match[0] );<br/>			}<br/><br/>			return match;<br/>		},<br/><br/>		"PSEUDO": function( match ) {<br/>			var excess,<br/>				unquoted = !match[6] &amp;&amp; match[2];<br/><br/>			if ( matchExpr["CHILD"].test( match[0] ) ) {<br/>				return null;<br/>			}<br/><br/>			// Accept quoted arguments as-is<br/>			if ( match[3] ) {<br/>				match[2] = match[4] || match[5] || "";<br/><br/>			// Strip excess characters from unquoted arguments<br/>			} else if ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;<br/>				// Get excess from tokenize (recursively)<br/>				(excess = tokenize( unquoted, true )) &amp;&amp;<br/>				// advance to the next closing parenthesis<br/>				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {<br/><br/>				// excess is a negative index<br/>				match[0] = match[0].slice( 0, excess );<br/>				match[2] = unquoted.slice( 0, excess );<br/>			}<br/><br/>			// Return only captures needed by the pseudo filter method (type and argument)<br/>			return match.slice( 0, 3 );<br/>		}<br/>	},<br/><br/>	filter: {<br/><br/>		"TAG": function( nodeNameSelector ) {<br/>			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();<br/>			return nodeNameSelector === "*" ?<br/>				function() { return true; } :<br/>				function( elem ) {<br/>					return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;<br/>				};<br/>		},<br/><br/>		"CLASS": function( className ) {<br/>			var pattern = classCache[ className + " " ];<br/><br/>			return pattern ||<br/>				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &amp;&amp;<br/>				classCache( className, function( elem ) {<br/>					return pattern.test( typeof elem.className === "string" &amp;&amp; elem.className || typeof elem.getAttribute !== "undefined" &amp;&amp; elem.getAttribute("class") || "" );<br/>				});<br/>		},<br/><br/>		"ATTR": function( name, operator, check ) {<br/>			return function( elem ) {<br/>				var result = Sizzle.attr( elem, name );<br/><br/>				if ( result == null ) {<br/>					return operator === "!=";<br/>				}<br/>				if ( !operator ) {<br/>					return true;<br/>				}<br/><br/>				result += "";<br/><br/>				return operator === "=" ? result === check :<br/>					operator === "!=" ? result !== check :<br/>					operator === "^=" ? check &amp;&amp; result.indexOf( check ) === 0 :<br/>					operator === "*=" ? check &amp;&amp; result.indexOf( check ) &gt; -1 :<br/>					operator === "$=" ? check &amp;&amp; result.slice( -check.length ) === check :<br/>					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) &gt; -1 :<br/>					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :<br/>					false;<br/>			};<br/>		},<br/><br/>		"CHILD": function( type, what, argument, first, last ) {<br/>			var simple = type.slice( 0, 3 ) !== "nth",<br/>				forward = type.slice( -4 ) !== "last",<br/>				ofType = what === "of-type";<br/><br/>			return first === 1 &amp;&amp; last === 0 ?<br/><br/>				// Shortcut for :nth-*(n)<br/>				function( elem ) {<br/>					return !!elem.parentNode;<br/>				} :<br/><br/>				function( elem, context, xml ) {<br/>					var cache, uniqueCache, outerCache, node, nodeIndex, start,<br/>						dir = simple !== forward ? "nextSibling" : "previousSibling",<br/>						parent = elem.parentNode,<br/>						name = ofType &amp;&amp; elem.nodeName.toLowerCase(),<br/>						useCache = !xml &amp;&amp; !ofType,<br/>						diff = false;<br/><br/>					if ( parent ) {<br/><br/>						// :(first|last|only)-(child|of-type)<br/>						if ( simple ) {<br/>							while ( dir ) {<br/>								node = elem;<br/>								while ( (node = node[ dir ]) ) {<br/>									if ( ofType ?<br/>										node.nodeName.toLowerCase() === name :<br/>										node.nodeType === 1 ) {<br/><br/>										return false;<br/>									}<br/>								}<br/>								// Reverse direction for :only-* (if we haven't yet done so)<br/>								start = dir = type === "only" &amp;&amp; !start &amp;&amp; "nextSibling";<br/>							}<br/>							return true;<br/>						}<br/><br/>						start = [ forward ? parent.firstChild : parent.lastChild ];<br/><br/>						// non-xml :nth-child(...) stores cache data on `parent`<br/>						if ( forward &amp;&amp; useCache ) {<br/><br/>							// Seek `elem` from a previously-cached index<br/><br/>							// ...in a gzip-friendly way<br/>							node = parent;<br/>							outerCache = node[ expando ] || (node[ expando ] = {});<br/><br/>							// Support: IE &lt;9 only<br/>							// Defend against cloned attroperties (jQuery gh-1709)<br/>							uniqueCache = outerCache[ node.uniqueID ] ||<br/>								(outerCache[ node.uniqueID ] = {});<br/><br/>							cache = uniqueCache[ type ] || [];<br/>							nodeIndex = cache[ 0 ] === dirruns &amp;&amp; cache[ 1 ];<br/>							diff = nodeIndex &amp;&amp; cache[ 2 ];<br/>							node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];<br/><br/>							while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||<br/><br/>								// Fallback to seeking `elem` from the start<br/>								(diff = nodeIndex = 0) || start.pop()) ) {<br/><br/>								// When found, cache indexes on `parent` and break<br/>								if ( node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem ) {<br/>									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];<br/>									break;<br/>								}<br/>							}<br/><br/>						} else {<br/>							// Use previously-cached element index if available<br/>							if ( useCache ) {<br/>								// ...in a gzip-friendly way<br/>								node = elem;<br/>								outerCache = node[ expando ] || (node[ expando ] = {});<br/><br/>								// Support: IE &lt;9 only<br/>								// Defend against cloned attroperties (jQuery gh-1709)<br/>								uniqueCache = outerCache[ node.uniqueID ] ||<br/>									(outerCache[ node.uniqueID ] = {});<br/><br/>								cache = uniqueCache[ type ] || [];<br/>								nodeIndex = cache[ 0 ] === dirruns &amp;&amp; cache[ 1 ];<br/>								diff = nodeIndex;<br/>							}<br/><br/>							// xml :nth-child(...)<br/>							// or :nth-last-child(...) or :nth(-last)?-of-type(...)<br/>							if ( diff === false ) {<br/>								// Use the same loop as above to seek `elem` from the start<br/>								while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||<br/>									(diff = nodeIndex = 0) || start.pop()) ) {<br/><br/>									if ( ( ofType ?<br/>										node.nodeName.toLowerCase() === name :<br/>										node.nodeType === 1 ) &amp;&amp;<br/>										++diff ) {<br/><br/>										// Cache the index of each encountered element<br/>										if ( useCache ) {<br/>											outerCache = node[ expando ] || (node[ expando ] = {});<br/><br/>											// Support: IE &lt;9 only<br/>											// Defend against cloned attroperties (jQuery gh-1709)<br/>											uniqueCache = outerCache[ node.uniqueID ] ||<br/>												(outerCache[ node.uniqueID ] = {});<br/><br/>											uniqueCache[ type ] = [ dirruns, diff ];<br/>										}<br/><br/>										if ( node === elem ) {<br/>											break;<br/>										}<br/>									}<br/>								}<br/>							}<br/>						}<br/><br/>						// Incorporate the offset, then check against cycle size<br/>						diff -= last;<br/>						return diff === first || ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );<br/>					}<br/>				};<br/>		},<br/><br/>		"PSEUDO": function( pseudo, argument ) {<br/>			// pseudo-class names are case-insensitive<br/>			// http://www.w3.org/TR/selectors/#pseudo-classes<br/>			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters<br/>			// Remember that setFilters inherits from pseudos<br/>			var args,<br/>				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||<br/>					Sizzle.error( "unsupported pseudo: " + pseudo );<br/><br/>			// The user may use createPseudo to indicate that<br/>			// arguments are needed to create the filter function<br/>			// just as Sizzle does<br/>			if ( fn[ expando ] ) {<br/>				return fn( argument );<br/>			}<br/><br/>			// But maintain support for old signatures<br/>			if ( fn.length &gt; 1 ) {<br/>				args = [ pseudo, pseudo, "", argument ];<br/>				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?<br/>					markFunction(function( seed, matches ) {<br/>						var idx,<br/>							matched = fn( seed, argument ),<br/>							i = matched.length;<br/>						while ( i-- ) {<br/>							idx = indexOf( seed, matched[i] );<br/>							seed[ idx ] = !( matches[ idx ] = matched[i] );<br/>						}<br/>					}) :<br/>					function( elem ) {<br/>						return fn( elem, 0, args );<br/>					};<br/>			}<br/><br/>			return fn;<br/>		}<br/>	},<br/><br/>	pseudos: {<br/>		// Potentially complex pseudos<br/>		"not": markFunction(function( selector ) {<br/>			// Trim the selector passed to compile<br/>			// to avoid treating leading and trailing<br/>			// spaces as combinators<br/>			var input = [],<br/>				results = [],<br/>				matcher = compile( selector.replace( rtrim, "$1" ) );<br/><br/>			return matcher[ expando ] ?<br/>				markFunction(function( seed, matches, context, xml ) {<br/>					var elem,<br/>						unmatched = matcher( seed, null, xml, [] ),<br/>						i = seed.length;<br/><br/>					// Match elements unmatched by `matcher`<br/>					while ( i-- ) {<br/>						if ( (elem = unmatched[i]) ) {<br/>							seed[i] = !(matches[i] = elem);<br/>						}<br/>					}<br/>				}) :<br/>				function( elem, context, xml ) {<br/>					input[0] = elem;<br/>					matcher( input, null, xml, results );<br/>					// Don't keep the element (issue #299)<br/>					input[0] = null;<br/>					return !results.pop();<br/>				};<br/>		}),<br/><br/>		"has": markFunction(function( selector ) {<br/>			return function( elem ) {<br/>				return Sizzle( selector, elem ).length &gt; 0;<br/>			};<br/>		}),<br/><br/>		"contains": markFunction(function( text ) {<br/>			text = text.replace( runescape, funescape );<br/>			return function( elem ) {<br/>				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1;<br/>			};<br/>		}),<br/><br/>		// "Whether an element is represented by a :lang() selector<br/>		// is based solely on the element's language value<br/>		// being equal to the identifier C,<br/>		// or beginning with the identifier C immediately followed by "-".<br/>		// The matching of C against the element's language value is performed case-insensitively.<br/>		// The identifier C does not have to be a valid language name."<br/>		// http://www.w3.org/TR/selectors/#lang-pseudo<br/>		"lang": markFunction( function( lang ) {<br/>			// lang value must be a valid identifier<br/>			if ( !ridentifier.test(lang || "") ) {<br/>				Sizzle.error( "unsupported lang: " + lang );<br/>			}<br/>			lang = lang.replace( runescape, funescape ).toLowerCase();<br/>			return function( elem ) {<br/>				var elemLang;<br/>				do {<br/>					if ( (elemLang = documentIsHTML ?<br/>						elem.lang :<br/>						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {<br/><br/>						elemLang = elemLang.toLowerCase();<br/>						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;<br/>					}<br/>				} while ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === 1 );<br/>				return false;<br/>			};<br/>		}),<br/><br/>		// Miscellaneous<br/>		"target": function( elem ) {<br/>			var hash = window.location &amp;&amp; window.location.hash;<br/>			return hash &amp;&amp; hash.slice( 1 ) === elem.id;<br/>		},<br/><br/>		"root": function( elem ) {<br/>			return elem === docElem;<br/>		},<br/><br/>		"focus": function( elem ) {<br/>			return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);<br/>		},<br/><br/>		// Boolean properties<br/>		"enabled": createDisabledPseudo( false ),<br/>		"disabled": createDisabledPseudo( true ),<br/><br/>		"checked": function( elem ) {<br/>			// In CSS3, :checked should return both checked and selected elements<br/>			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked<br/>			var nodeName = elem.nodeName.toLowerCase();<br/>			return (nodeName === "input" &amp;&amp; !!elem.checked) || (nodeName === "option" &amp;&amp; !!elem.selected);<br/>		},<br/><br/>		"selected": function( elem ) {<br/>			// Accessing this property makes selected-by-default<br/>			// options in Safari work properly<br/>			if ( elem.parentNode ) {<br/>				elem.parentNode.selectedIndex;<br/>			}<br/><br/>			return elem.selected === true;<br/>		},<br/><br/>		// Contents<br/>		"empty": function( elem ) {<br/>			// http://www.w3.org/TR/selectors/#empty-pseudo<br/>			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),<br/>			//   but not by others (comment: 8; processing instruction: 7; etc.)<br/>			// nodeType &lt; 6 works because attributes (2) do not appear as children<br/>			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {<br/>				if ( elem.nodeType &lt; 6 ) {<br/>					return false;<br/>				}<br/>			}<br/>			return true;<br/>		},<br/><br/>		"parent": function( elem ) {<br/>			return !Expr.pseudos["empty"]( elem );<br/>		},<br/><br/>		// Element/input types<br/>		"header": function( elem ) {<br/>			return rheader.test( elem.nodeName );<br/>		},<br/><br/>		"input": function( elem ) {<br/>			return rinputs.test( elem.nodeName );<br/>		},<br/><br/>		"button": function( elem ) {<br/>			var name = elem.nodeName.toLowerCase();<br/>			return name === "input" &amp;&amp; elem.type === "button" || name === "button";<br/>		},<br/><br/>		"text": function( elem ) {<br/>			var attr;<br/>			return elem.nodeName.toLowerCase() === "input" &amp;&amp;<br/>				elem.type === "text" &amp;&amp;<br/><br/>				// Support: IE&lt;8<br/>				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"<br/>				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );<br/>		},<br/><br/>		// Position-in-collection<br/>		"first": createPositionalPseudo(function() {<br/>			return [ 0 ];<br/>		}),<br/><br/>		"last": createPositionalPseudo(function( matchIndexes, length ) {<br/>			return [ length - 1 ];<br/>		}),<br/><br/>		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {<br/>			return [ argument &lt; 0 ? argument + length : argument ];<br/>		}),<br/><br/>		"even": createPositionalPseudo(function( matchIndexes, length ) {<br/>			var i = 0;<br/>			for ( ; i &lt; length; i += 2 ) {<br/>				matchIndexes.push( i );<br/>			}<br/>			return matchIndexes;<br/>		}),<br/><br/>		"odd": createPositionalPseudo(function( matchIndexes, length ) {<br/>			var i = 1;<br/>			for ( ; i &lt; length; i += 2 ) {<br/>				matchIndexes.push( i );<br/>			}<br/>			return matchIndexes;<br/>		}),<br/><br/>		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {<br/>			var i = argument &lt; 0 ? argument + length : argument;<br/>			for ( ; --i &gt;= 0; ) {<br/>				matchIndexes.push( i );<br/>			}<br/>			return matchIndexes;<br/>		}),<br/><br/>		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {<br/>			var i = argument &lt; 0 ? argument + length : argument;<br/>			for ( ; ++i &lt; length; ) {<br/>				matchIndexes.push( i );<br/>			}<br/>			return matchIndexes;<br/>		})<br/>	}<br/>};<br/><br/>Expr.pseudos["nth"] = Expr.pseudos["eq"];<br/><br/>// Add button/input type pseudos<br/>for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {<br/>	Expr.pseudos[ i ] = createInputPseudo( i );<br/>}<br/>for ( i in { submit: true, reset: true } ) {<br/>	Expr.pseudos[ i ] = createButtonPseudo( i );<br/>}<br/><br/>// Easy API for creating new setFilters<br/>function setFilters() {}<br/>setFilters.prototype = Expr.filters = Expr.pseudos;<br/>Expr.setFilters = new setFilters();<br/><br/>tokenize = Sizzle.tokenize = function( selector, parseOnly ) {<br/>	var matched, match, tokens, type,<br/>		soFar, groups, preFilters,<br/>		cached = tokenCache[ selector + " " ];<br/><br/>	if ( cached ) {<br/>		return parseOnly ? 0 : cached.slice( 0 );<br/>	}<br/><br/>	soFar = selector;<br/>	groups = [];<br/>	preFilters = Expr.preFilter;<br/><br/>	while ( soFar ) {<br/><br/>		// Comma and first run<br/>		if ( !matched || (match = rcomma.exec( soFar )) ) {<br/>			if ( match ) {<br/>				// Don't consume trailing commas as valid<br/>				soFar = soFar.slice( match[0].length ) || soFar;<br/>			}<br/>			groups.push( (tokens = []) );<br/>		}<br/><br/>		matched = false;<br/><br/>		// Combinators<br/>		if ( (match = rcombinators.exec( soFar )) ) {<br/>			matched = match.shift();<br/>			tokens.push({<br/>				value: matched,<br/>				// Cast descendant combinators to space<br/>				type: match[0].replace( rtrim, " " )<br/>			});<br/>			soFar = soFar.slice( matched.length );<br/>		}<br/><br/>		// Filters<br/>		for ( type in Expr.filter ) {<br/>			if ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||<br/>				(match = preFilters[ type ]( match ))) ) {<br/>				matched = match.shift();<br/>				tokens.push({<br/>					value: matched,<br/>					type: type,<br/>					matches: match<br/>				});<br/>				soFar = soFar.slice( matched.length );<br/>			}<br/>		}<br/><br/>		if ( !matched ) {<br/>			break;<br/>		}<br/>	}<br/><br/>	// Return the length of the invalid excess<br/>	// if we're just parsing<br/>	// Otherwise, throw an error or return tokens<br/>	return parseOnly ?<br/>		soFar.length :<br/>		soFar ?<br/>			Sizzle.error( selector ) :<br/>			// Cache the tokens<br/>			tokenCache( selector, groups ).slice( 0 );<br/>};<br/><br/>function toSelector( tokens ) {<br/>	var i = 0,<br/>		len = tokens.length,<br/>		selector = "";<br/>	for ( ; i &lt; len; i++ ) {<br/>		selector += tokens[i].value;<br/>	}<br/>	return selector;<br/>}<br/><br/>function addCombinator( matcher, combinator, base ) {<br/>	var dir = combinator.dir,<br/>		skip = combinator.next,<br/>		key = skip || dir,<br/>		checkNonElements = base &amp;&amp; key === "parentNode",<br/>		doneName = done++;<br/><br/>	return combinator.first ?<br/>		// Check against closest ancestor/preceding element<br/>		function( elem, context, xml ) {<br/>			while ( (elem = elem[ dir ]) ) {<br/>				if ( elem.nodeType === 1 || checkNonElements ) {<br/>					return matcher( elem, context, xml );<br/>				}<br/>			}<br/>			return false;<br/>		} :<br/><br/>		// Check against all ancestor/preceding elements<br/>		function( elem, context, xml ) {<br/>			var oldCache, uniqueCache, outerCache,<br/>				newCache = [ dirruns, doneName ];<br/><br/>			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching<br/>			if ( xml ) {<br/>				while ( (elem = elem[ dir ]) ) {<br/>					if ( elem.nodeType === 1 || checkNonElements ) {<br/>						if ( matcher( elem, context, xml ) ) {<br/>							return true;<br/>						}<br/>					}<br/>				}<br/>			} else {<br/>				while ( (elem = elem[ dir ]) ) {<br/>					if ( elem.nodeType === 1 || checkNonElements ) {<br/>						outerCache = elem[ expando ] || (elem[ expando ] = {});<br/><br/>						// Support: IE &lt;9 only<br/>						// Defend against cloned attroperties (jQuery gh-1709)<br/>						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});<br/><br/>						if ( skip &amp;&amp; skip === elem.nodeName.toLowerCase() ) {<br/>							elem = elem[ dir ] || elem;<br/>						} else if ( (oldCache = uniqueCache[ key ]) &amp;&amp;<br/>							oldCache[ 0 ] === dirruns &amp;&amp; oldCache[ 1 ] === doneName ) {<br/><br/>							// Assign to newCache so results back-propagate to previous elements<br/>							return (newCache[ 2 ] = oldCache[ 2 ]);<br/>						} else {<br/>							// Reuse newcache so results back-propagate to previous elements<br/>							uniqueCache[ key ] = newCache;<br/><br/>							// A match means we're done; a fail means we have to keep checking<br/>							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {<br/>								return true;<br/>							}<br/>						}<br/>					}<br/>				}<br/>			}<br/>			return false;<br/>		};<br/>}<br/><br/>function elementMatcher( matchers ) {<br/>	return matchers.length &gt; 1 ?<br/>		function( elem, context, xml ) {<br/>			var i = matchers.length;<br/>			while ( i-- ) {<br/>				if ( !matchers[i]( elem, context, xml ) ) {<br/>					return false;<br/>				}<br/>			}<br/>			return true;<br/>		} :<br/>		matchers[0];<br/>}<br/><br/>function multipleContexts( selector, contexts, results ) {<br/>	var i = 0,<br/>		len = contexts.length;<br/>	for ( ; i &lt; len; i++ ) {<br/>		Sizzle( selector, contexts[i], results );<br/>	}<br/>	return results;<br/>}<br/><br/>function condense( unmatched, map, filter, context, xml ) {<br/>	var elem,<br/>		newUnmatched = [],<br/>		i = 0,<br/>		len = unmatched.length,<br/>		mapped = map != null;<br/><br/>	for ( ; i &lt; len; i++ ) {<br/>		if ( (elem = unmatched[i]) ) {<br/>			if ( !filter || filter( elem, context, xml ) ) {<br/>				newUnmatched.push( elem );<br/>				if ( mapped ) {<br/>					map.push( i );<br/>				}<br/>			}<br/>		}<br/>	}<br/><br/>	return newUnmatched;<br/>}<br/><br/>function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {<br/>	if ( postFilter &amp;&amp; !postFilter[ expando ] ) {<br/>		postFilter = setMatcher( postFilter );<br/>	}<br/>	if ( postFinder &amp;&amp; !postFinder[ expando ] ) {<br/>		postFinder = setMatcher( postFinder, postSelector );<br/>	}<br/>	return markFunction(function( seed, results, context, xml ) {<br/>		var temp, i, elem,<br/>			preMap = [],<br/>			postMap = [],<br/>			preexisting = results.length,<br/><br/>			// Get initial elements from seed or context<br/>			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),<br/><br/>			// Prefilter to get matcher input, preserving a map for seed-results synchronization<br/>			matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?<br/>				condense( elems, preMap, preFilter, context, xml ) :<br/>				elems,<br/><br/>			matcherOut = matcher ?<br/>				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,<br/>				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?<br/><br/>					// ...intermediate processing is necessary<br/>					[] :<br/><br/>					// ...otherwise use results directly<br/>					results :<br/>				matcherIn;<br/><br/>		// Find primary matches<br/>		if ( matcher ) {<br/>			matcher( matcherIn, matcherOut, context, xml );<br/>		}<br/><br/>		// Apply postFilter<br/>		if ( postFilter ) {<br/>			temp = condense( matcherOut, postMap );<br/>			postFilter( temp, [], context, xml );<br/><br/>			// Un-match failing elements by moving them back to matcherIn<br/>			i = temp.length;<br/>			while ( i-- ) {<br/>				if ( (elem = temp[i]) ) {<br/>					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);<br/>				}<br/>			}<br/>		}<br/><br/>		if ( seed ) {<br/>			if ( postFinder || preFilter ) {<br/>				if ( postFinder ) {<br/>					// Get the final matcherOut by condensing this intermediate into postFinder contexts<br/>					temp = [];<br/>					i = matcherOut.length;<br/>					while ( i-- ) {<br/>						if ( (elem = matcherOut[i]) ) {<br/>							// Restore matcherIn since elem is not yet a final match<br/>							temp.push( (matcherIn[i] = elem) );<br/>						}<br/>					}<br/>					postFinder( null, (matcherOut = []), temp, xml );<br/>				}<br/><br/>				// Move matched elements from seed to results to keep them synchronized<br/>				i = matcherOut.length;<br/>				while ( i-- ) {<br/>					if ( (elem = matcherOut[i]) &amp;&amp;<br/>						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) &gt; -1 ) {<br/><br/>						seed[temp] = !(results[temp] = elem);<br/>					}<br/>				}<br/>			}<br/><br/>		// Add elements to results, through postFinder if defined<br/>		} else {<br/>			matcherOut = condense(<br/>				matcherOut === results ?<br/>					matcherOut.splice( preexisting, matcherOut.length ) :<br/>					matcherOut<br/>			);<br/>			if ( postFinder ) {<br/>				postFinder( null, results, matcherOut, xml );<br/>			} else {<br/>				push.apply( results, matcherOut );<br/>			}<br/>		}<br/>	});<br/>}<br/><br/>function matcherFromTokens( tokens ) {<br/>	var checkContext, matcher, j,<br/>		len = tokens.length,<br/>		leadingRelative = Expr.relative[ tokens[0].type ],<br/>		implicitRelative = leadingRelative || Expr.relative[" "],<br/>		i = leadingRelative ? 1 : 0,<br/><br/>		// The foundational matcher ensures that elements are reachable from top-level context(s)<br/>		matchContext = addCombinator( function( elem ) {<br/>			return elem === checkContext;<br/>		}, implicitRelative, true ),<br/>		matchAnyContext = addCombinator( function( elem ) {<br/>			return indexOf( checkContext, elem ) &gt; -1;<br/>		}, implicitRelative, true ),<br/>		matchers = [ function( elem, context, xml ) {<br/>			var ret = ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (<br/>				(checkContext = context).nodeType ?<br/>					matchContext( elem, context, xml ) :<br/>					matchAnyContext( elem, context, xml ) );<br/>			// Avoid hanging onto element (issue #299)<br/>			checkContext = null;<br/>			return ret;<br/>		} ];<br/><br/>	for ( ; i &lt; len; i++ ) {<br/>		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {<br/>			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];<br/>		} else {<br/>			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );<br/><br/>			// Return special upon seeing a positional matcher<br/>			if ( matcher[ expando ] ) {<br/>				// Find the next relative operator (if any) for proper handling<br/>				j = ++i;<br/>				for ( ; j &lt; len; j++ ) {<br/>					if ( Expr.relative[ tokens[j].type ] ) {<br/>						break;<br/>					}<br/>				}<br/>				return setMatcher(<br/>					i &gt; 1 &amp;&amp; elementMatcher( matchers ),<br/>					i &gt; 1 &amp;&amp; toSelector(<br/>						// If the preceding token was a descendant combinator, insert an implicit any-element `*`<br/>						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })<br/>					).replace( rtrim, "$1" ),<br/>					matcher,<br/>					i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),<br/>					j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),<br/>					j &lt; len &amp;&amp; toSelector( tokens )<br/>				);<br/>			}<br/>			matchers.push( matcher );<br/>		}<br/>	}<br/><br/>	return elementMatcher( matchers );<br/>}<br/><br/>function matcherFromGroupMatchers( elementMatchers, setMatchers ) {<br/>	var bySet = setMatchers.length &gt; 0,<br/>		byElement = elementMatchers.length &gt; 0,<br/>		superMatcher = function( seed, context, xml, results, outermost ) {<br/>			var elem, j, matcher,<br/>				matchedCount = 0,<br/>				i = "0",<br/>				unmatched = seed &amp;&amp; [],<br/>				setMatched = [],<br/>				contextBackup = outermostContext,<br/>				// We must always have either seed elements or outermost context<br/>				elems = seed || byElement &amp;&amp; Expr.find["TAG"]( "*", outermost ),<br/>				// Use integer dirruns iff this is the outermost matcher<br/>				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),<br/>				len = elems.length;<br/><br/>			if ( outermost ) {<br/>				outermostContext = context === document || context || outermost;<br/>			}<br/><br/>			// Add elements passing elementMatchers directly to results<br/>			// Support: IE&lt;9, Safari<br/>			// Tolerate NodeList properties (IE: "length"; Safari: &lt;number&gt;) matching elements by id<br/>			for ( ; i !== len &amp;&amp; (elem = elems[i]) != null; i++ ) {<br/>				if ( byElement &amp;&amp; elem ) {<br/>					j = 0;<br/>					if ( !context &amp;&amp; elem.ownerDocument !== document ) {<br/>						setDocument( elem );<br/>						xml = !documentIsHTML;<br/>					}<br/>					while ( (matcher = elementMatchers[j++]) ) {<br/>						if ( matcher( elem, context || document, xml) ) {<br/>							results.push( elem );<br/>							break;<br/>						}<br/>					}<br/>					if ( outermost ) {<br/>						dirruns = dirrunsUnique;<br/>					}<br/>				}<br/><br/>				// Track unmatched elements for set filters<br/>				if ( bySet ) {<br/>					// They will have gone through all possible matchers<br/>					if ( (elem = !matcher &amp;&amp; elem) ) {<br/>						matchedCount--;<br/>					}<br/><br/>					// Lengthen the array for every element, matched or not<br/>					if ( seed ) {<br/>						unmatched.push( elem );<br/>					}<br/>				}<br/>			}<br/><br/>			// `i` is now the count of elements visited above, and adding it to `matchedCount`<br/>			// makes the latter nonnegative.<br/>			matchedCount += i;<br/><br/>			// Apply set filters to unmatched elements<br/>			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`<br/>			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have<br/>			// no element matchers and no seed.<br/>			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that<br/>			// case, which will result in a "00" `matchedCount` that differs from `i` but is also<br/>			// numerically zero.<br/>			if ( bySet &amp;&amp; i !== matchedCount ) {<br/>				j = 0;<br/>				while ( (matcher = setMatchers[j++]) ) {<br/>					matcher( unmatched, setMatched, context, xml );<br/>				}<br/><br/>				if ( seed ) {<br/>					// Reintegrate element matches to eliminate the need for sorting<br/>					if ( matchedCount &gt; 0 ) {<br/>						while ( i-- ) {<br/>							if ( !(unmatched[i] || setMatched[i]) ) {<br/>								setMatched[i] = pop.call( results );<br/>							}<br/>						}<br/>					}<br/><br/>					// Discard index placeholder values to get only actual matches<br/>					setMatched = condense( setMatched );<br/>				}<br/><br/>				// Add matches to results<br/>				push.apply( results, setMatched );<br/><br/>				// Seedless set matches succeeding multiple successful matchers stipulate sorting<br/>				if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;<br/>					( matchedCount + setMatchers.length ) &gt; 1 ) {<br/><br/>					Sizzle.uniqueSort( results );<br/>				}<br/>			}<br/><br/>			// Override manipulation of globals by nested matchers<br/>			if ( outermost ) {<br/>				dirruns = dirrunsUnique;<br/>				outermostContext = contextBackup;<br/>			}<br/><br/>			return unmatched;<br/>		};<br/><br/>	return bySet ?<br/>		markFunction( superMatcher ) :<br/>		superMatcher;<br/>}<br/><br/>compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {<br/>	var i,<br/>		setMatchers = [],<br/>		elementMatchers = [],<br/>		cached = compilerCache[ selector + " " ];<br/><br/>	if ( !cached ) {<br/>		// Generate a function of recursive functions that can be used to check each element<br/>		if ( !match ) {<br/>			match = tokenize( selector );<br/>		}<br/>		i = match.length;<br/>		while ( i-- ) {<br/>			cached = matcherFromTokens( match[i] );<br/>			if ( cached[ expando ] ) {<br/>				setMatchers.push( cached );<br/>			} else {<br/>				elementMatchers.push( cached );<br/>			}<br/>		}<br/><br/>		// Cache the compiled function<br/>		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );<br/><br/>		// Save selector and tokenization<br/>		cached.selector = selector;<br/>	}<br/>	return cached;<br/>};<br/><br/>/**<br/> * A low-level selection function that works with Sizzle's compiled<br/> *  selector functions<br/> * @param {String|Function} selector A selector or a pre-compiled<br/> *  selector function built with Sizzle.compile<br/> * @param {Element} context<br/> * @param {Array} [results]<br/> * @param {Array} [seed] A set of elements to match against<br/> */<br/>select = Sizzle.select = function( selector, context, results, seed ) {<br/>	var i, tokens, token, type, find,<br/>		compiled = typeof selector === "function" &amp;&amp; selector,<br/>		match = !seed &amp;&amp; tokenize( (selector = compiled.selector || selector) );<br/><br/>	results = results || [];<br/><br/>	// Try to minimize operations if there is only one selector in the list and no seed<br/>	// (the latter of which guarantees us context)<br/>	if ( match.length === 1 ) {<br/><br/>		// Reduce context if the leading compound selector is an ID<br/>		tokens = match[0] = match[0].slice( 0 );<br/>		if ( tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === "ID" &amp;&amp;<br/>				context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp; Expr.relative[ tokens[1].type ] ) {<br/><br/>			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];<br/>			if ( !context ) {<br/>				return results;<br/><br/>			// Precompiled matchers will still verify ancestry, so step up a level<br/>			} else if ( compiled ) {<br/>				context = context.parentNode;<br/>			}<br/><br/>			selector = selector.slice( tokens.shift().value.length );<br/>		}<br/><br/>		// Fetch a seed set for right-to-left matching<br/>		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;<br/>		while ( i-- ) {<br/>			token = tokens[i];<br/><br/>			// Abort if we hit a combinator<br/>			if ( Expr.relative[ (type = token.type) ] ) {<br/>				break;<br/>			}<br/>			if ( (find = Expr.find[ type ]) ) {<br/>				// Search, expanding context for leading sibling combinators<br/>				if ( (seed = find(<br/>					token.matches[0].replace( runescape, funescape ),<br/>					rsibling.test( tokens[0].type ) &amp;&amp; testContext( context.parentNode ) || context<br/>				)) ) {<br/><br/>					// If seed is empty or no tokens remain, we can return early<br/>					tokens.splice( i, 1 );<br/>					selector = seed.length &amp;&amp; toSelector( tokens );<br/>					if ( !selector ) {<br/>						push.apply( results, seed );<br/>						return results;<br/>					}<br/><br/>					break;<br/>				}<br/>			}<br/>		}<br/>	}<br/><br/>	// Compile and execute a filtering function if one is not provided<br/>	// Provide `match` to avoid retokenization if we modified the selector above<br/>	( compiled || compile( selector, match ) )(<br/>		seed,<br/>		context,<br/>		!documentIsHTML,<br/>		results,<br/>		!context || rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context<br/>	);<br/>	return results;<br/>};<br/><br/>// One-time assignments<br/><br/>// Sort stability<br/>support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;<br/><br/>// Support: Chrome 14-35+<br/>// Always assume duplicates if they aren't passed to the comparison function<br/>support.detectDuplicates = !!hasDuplicate;<br/><br/>// Initialize against the default document<br/>setDocument();<br/><br/>// Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)<br/>// Detached nodes confoundingly follow *each other*<br/>support.sortDetached = assert(function( el ) {<br/>	// Should return 1, but returns 4 (following)<br/>	return el.compareDocumentPosition( document.createElement("fieldset") ) &amp; 1;<br/>});<br/><br/>// Support: IE&lt;8<br/>// Prevent attribute/property "interpolation"<br/>// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx<br/>if ( !assert(function( el ) {<br/>	el.innerHTML = "&lt;a href='#'&gt;&lt;/a&gt;";<br/>	return el.firstChild.getAttribute("href") === "#" ;<br/>}) ) {<br/>	addHandle( "type|href|height|width", function( elem, name, isXML ) {<br/>		if ( !isXML ) {<br/>			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );<br/>		}<br/>	});<br/>}<br/><br/>// Support: IE&lt;9<br/>// Use defaultValue in place of getAttribute("value")<br/>if ( !support.attributes || !assert(function( el ) {<br/>	el.innerHTML = "&lt;input/&gt;";<br/>	el.firstChild.setAttribute( "value", "" );<br/>	return el.firstChild.getAttribute( "value" ) === "";<br/>}) ) {<br/>	addHandle( "value", function( elem, name, isXML ) {<br/>		if ( !isXML &amp;&amp; elem.nodeName.toLowerCase() === "input" ) {<br/>			return elem.defaultValue;<br/>		}<br/>	});<br/>}<br/><br/>// Support: IE&lt;9<br/>// Use getAttributeNode to fetch booleans when getAttribute lies<br/>if ( !assert(function( el ) {<br/>	return el.getAttribute("disabled") == null;<br/>}) ) {<br/>	addHandle( booleans, function( elem, name, isXML ) {<br/>		var val;<br/>		if ( !isXML ) {<br/>			return elem[ name ] === true ? name.toLowerCase() :<br/>					(val = elem.getAttributeNode( name )) &amp;&amp; val.specified ?<br/>					val.value :<br/>				null;<br/>		}<br/>	});<br/>}<br/><br/>return Sizzle;<br/><br/>})( window );<br/><br/><br/><br/>jQuery.find = Sizzle;<br/>jQuery.expr = Sizzle.selectors;<br/><br/>// Deprecated<br/>jQuery.expr[ ":" ] = jQuery.expr.pseudos;<br/>jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;<br/>jQuery.text = Sizzle.getText;<br/>jQuery.isXMLDoc = Sizzle.isXML;<br/>jQuery.contains = Sizzle.contains;<br/>jQuery.escapeSelector = Sizzle.escape;<br/><br/><br/><br/><br/>var dir = function( elem, dir, until ) {<br/>	var matched = [],<br/>		truncate = until !== undefined;<br/><br/>	while ( ( elem = elem[ dir ] ) &amp;&amp; elem.nodeType !== 9 ) {<br/>		if ( elem.nodeType === 1 ) {<br/>			if ( truncate &amp;&amp; jQuery( elem ).is( until ) ) {<br/>				break;<br/>			}<br/>			matched.push( elem );<br/>		}<br/>	}<br/>	return matched;<br/>};<br/><br/><br/>var siblings = function( n, elem ) {<br/>	var matched = [];<br/><br/>	for ( ; n; n = n.nextSibling ) {<br/>		if ( n.nodeType === 1 &amp;&amp; n !== elem ) {<br/>			matched.push( n );<br/>		}<br/>	}<br/><br/>	return matched;<br/>};<br/><br/><br/>var rneedsContext = jQuery.expr.match.needsContext;<br/><br/><br/><br/>function nodeName( elem, name ) {<br/><br/>  return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();<br/><br/>};<br/>var rsingleTag = ( /^&lt;([a-z][^\/\0&gt;:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?&gt;(?:&lt;\/\1&gt;|)$/i );<br/><br/><br/><br/>// Implement the identical functionality for filter and not<br/>function winnow( elements, qualifier, not ) {<br/>	if ( isFunction( qualifier ) ) {<br/>		return jQuery.grep( elements, function( elem, i ) {<br/>			return !!qualifier.call( elem, i, elem ) !== not;<br/>		} );<br/>	}<br/><br/>	// Single element<br/>	if ( qualifier.nodeType ) {<br/>		return jQuery.grep( elements, function( elem ) {<br/>			return ( elem === qualifier ) !== not;<br/>		} );<br/>	}<br/><br/>	// Arraylike of elements (jQuery, arguments, Array)<br/>	if ( typeof qualifier !== "string" ) {<br/>		return jQuery.grep( elements, function( elem ) {<br/>			return ( indexOf.call( qualifier, elem ) &gt; -1 ) !== not;<br/>		} );<br/>	}<br/><br/>	// Filtered directly for both simple and complex selectors<br/>	return jQuery.filter( qualifier, elements, not );<br/>}<br/><br/>jQuery.filter = function( expr, elems, not ) {<br/>	var elem = elems[ 0 ];<br/><br/>	if ( not ) {<br/>		expr = ":not(" + expr + ")";<br/>	}<br/><br/>	if ( elems.length === 1 &amp;&amp; elem.nodeType === 1 ) {<br/>		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];<br/>	}<br/><br/>	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {<br/>		return elem.nodeType === 1;<br/>	} ) );<br/>};<br/><br/>jQuery.fn.extend( {<br/>	find: function( selector ) {<br/>		var i, ret,<br/>			len = this.length,<br/>			self = this;<br/><br/>		if ( typeof selector !== "string" ) {<br/>			return this.pushStack( jQuery( selector ).filter( function() {<br/>				for ( i = 0; i &lt; len; i++ ) {<br/>					if ( jQuery.contains( self[ i ], this ) ) {<br/>						return true;<br/>					}<br/>				}<br/>			} ) );<br/>		}<br/><br/>		ret = this.pushStack( [] );<br/><br/>		for ( i = 0; i &lt; len; i++ ) {<br/>			jQuery.find( selector, self[ i ], ret );<br/>		}<br/><br/>		return len &gt; 1 ? jQuery.uniqueSort( ret ) : ret;<br/>	},<br/>	filter: function( selector ) {<br/>		return this.pushStack( winnow( this, selector || [], false ) );<br/>	},<br/>	not: function( selector ) {<br/>		return this.pushStack( winnow( this, selector || [], true ) );<br/>	},<br/>	is: function( selector ) {<br/>		return !!winnow(<br/>			this,<br/><br/>			// If this is a positional/relative selector, check membership in the returned set<br/>			// so $("p:first").is("p:last") won't return true for a doc with two "p".<br/>			typeof selector === "string" &amp;&amp; rneedsContext.test( selector ) ?<br/>				jQuery( selector ) :<br/>				selector || [],<br/>			false<br/>		).length;<br/>	}<br/>} );<br/><br/><br/>// Initialize a jQuery object<br/><br/><br/>// A central reference to the root jQuery(document)<br/>var rootjQuery,<br/><br/>	// A simple way to check for HTML strings<br/>	// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)<br/>	// Strict HTML recognition (#11290: must start with &lt;)<br/>	// Shortcut simple #id case for speed<br/>	rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]+))$/,<br/><br/>	init = jQuery.fn.init = function( selector, context, root ) {<br/>		var match, elem;<br/><br/>		// HANDLE: $(""), $(null), $(undefined), $(false)<br/>		if ( !selector ) {<br/>			return this;<br/>		}<br/><br/>		// Method init() accepts an alternate rootjQuery<br/>		// so migrate can support jQuery.sub (gh-2101)<br/>		root = root || rootjQuery;<br/><br/>		// Handle HTML strings<br/>		if ( typeof selector === "string" ) {<br/>			if ( selector[ 0 ] === "&lt;" &amp;&amp;<br/>				selector[ selector.length - 1 ] === "&gt;" &amp;&amp;<br/>				selector.length &gt;= 3 ) {<br/><br/>				// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check<br/>				match = [ null, selector, null ];<br/><br/>			} else {<br/>				match = rquickExpr.exec( selector );<br/>			}<br/><br/>			// Match html or make sure no context is specified for #id<br/>			if ( match &amp;&amp; ( match[ 1 ] || !context ) ) {<br/><br/>				// HANDLE: $(html) -&gt; $(array)<br/>				if ( match[ 1 ] ) {<br/>					context = context instanceof jQuery ? context[ 0 ] : context;<br/><br/>					// Option to run scripts is true for back-compat<br/>					// Intentionally let the error be thrown if parseHTML is not present<br/>					jQuery.merge( this, jQuery.parseHTML(<br/>						match[ 1 ],<br/>						context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,<br/>						true<br/>					) );<br/><br/>					// HANDLE: $(html, props)<br/>					if ( rsingleTag.test( match[ 1 ] ) &amp;&amp; jQuery.isPlainObject( context ) ) {<br/>						for ( match in context ) {<br/><br/>							// Properties of context are called as methods if possible<br/>							if ( isFunction( this[ match ] ) ) {<br/>								this[ match ]( context[ match ] );<br/><br/>							// ...and otherwise set as attributes<br/>							} else {<br/>								this.attr( match, context[ match ] );<br/>							}<br/>						}<br/>					}<br/><br/>					return this;<br/><br/>				// HANDLE: $(#id)<br/>				} else {<br/>					elem = document.getElementById( match[ 2 ] );<br/><br/>					if ( elem ) {<br/><br/>						// Inject the element directly into the jQuery object<br/>						this[ 0 ] = elem;<br/>						this.length = 1;<br/>					}<br/>					return this;<br/>				}<br/><br/>			// HANDLE: $(expr, $(...))<br/>			} else if ( !context || context.jquery ) {<br/>				return ( context || root ).find( selector );<br/><br/>			// HANDLE: $(expr, context)<br/>			// (which is just equivalent to: $(context).find(expr)<br/>			} else {<br/>				return this.constructor( context ).find( selector );<br/>			}<br/><br/>		// HANDLE: $(DOMElement)<br/>		} else if ( selector.nodeType ) {<br/>			this[ 0 ] = selector;<br/>			this.length = 1;<br/>			return this;<br/><br/>		// HANDLE: $(function)<br/>		// Shortcut for document ready<br/>		} else if ( isFunction( selector ) ) {<br/>			return root.ready !== undefined ?<br/>				root.ready( selector ) :<br/><br/>				// Execute immediately if ready is not present<br/>				selector( jQuery );<br/>		}<br/><br/>		return jQuery.makeArray( selector, this );<br/>	};<br/><br/>// Give the init function the jQuery prototype for later instantiation<br/>init.prototype = jQuery.fn;<br/><br/>// Initialize central reference<br/>rootjQuery = jQuery( document );<br/><br/><br/>var rparentsprev = /^(?:parents|prev(?:Until|All))/,<br/><br/>	// Methods guaranteed to produce a unique set when starting from a unique set<br/>	guaranteedUnique = {<br/>		children: true,<br/>		contents: true,<br/>		next: true,<br/>		prev: true<br/>	};<br/><br/>jQuery.fn.extend( {<br/>	has: function( target ) {<br/>		var targets = jQuery( target, this ),<br/>			l = targets.length;<br/><br/>		return this.filter( function() {<br/>			var i = 0;<br/>			for ( ; i &lt; l; i++ ) {<br/>				if ( jQuery.contains( this, targets[ i ] ) ) {<br/>					return true;<br/>				}<br/>			}<br/>		} );<br/>	},<br/><br/>	closest: function( selectors, context ) {<br/>		var cur,<br/>			i = 0,<br/>			l = this.length,<br/>			matched = [],<br/>			targets = typeof selectors !== "string" &amp;&amp; jQuery( selectors );<br/><br/>		// Positional selectors never match, since there's no _selection_ context<br/>		if ( !rneedsContext.test( selectors ) ) {<br/>			for ( ; i &lt; l; i++ ) {<br/>				for ( cur = this[ i ]; cur &amp;&amp; cur !== context; cur = cur.parentNode ) {<br/><br/>					// Always skip document fragments<br/>					if ( cur.nodeType &lt; 11 &amp;&amp; ( targets ?<br/>						targets.index( cur ) &gt; -1 :<br/><br/>						// Don't pass non-elements to Sizzle<br/>						cur.nodeType === 1 &amp;&amp;<br/>							jQuery.find.matchesSelector( cur, selectors ) ) ) {<br/><br/>						matched.push( cur );<br/>						break;<br/>					}<br/>				}<br/>			}<br/>		}<br/><br/>		return this.pushStack( matched.length &gt; 1 ? jQuery.uniqueSort( matched ) : matched );<br/>	},<br/><br/>	// Determine the position of an element within the set<br/>	index: function( elem ) {<br/><br/>		// No argument, return index in parent<br/>		if ( !elem ) {<br/>			return ( this[ 0 ] &amp;&amp; this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;<br/>		}<br/><br/>		// Index in selector<br/>		if ( typeof elem === "string" ) {<br/>			return indexOf.call( jQuery( elem ), this[ 0 ] );<br/>		}<br/><br/>		// Locate the position of the desired element<br/>		return indexOf.call( this,<br/><br/>			// If it receives a jQuery object, the first element is used<br/>			elem.jquery ? elem[ 0 ] : elem<br/>		);<br/>	},<br/><br/>	add: function( selector, context ) {<br/>		return this.pushStack(<br/>			jQuery.uniqueSort(<br/>				jQuery.merge( this.get(), jQuery( selector, context ) )<br/>			)<br/>		);<br/>	},<br/><br/>	addBack: function( selector ) {<br/>		return this.add( selector == null ?<br/>			this.prevObject : this.prevObject.filter( selector )<br/>		);<br/>	}<br/>} );<br/><br/>function sibling( cur, dir ) {<br/>	while ( ( cur = cur[ dir ] ) &amp;&amp; cur.nodeType !== 1 ) {}<br/>	return cur;<br/>}<br/><br/>jQuery.each( {<br/>	parent: function( elem ) {<br/>		var parent = elem.parentNode;<br/>		return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;<br/>	},<br/>	parents: function( elem ) {<br/>		return dir( elem, "parentNode" );<br/>	},<br/>	parentsUntil: function( elem, i, until ) {<br/>		return dir( elem, "parentNode", until );<br/>	},<br/>	next: function( elem ) {<br/>		return sibling( elem, "nextSibling" );<br/>	},<br/>	prev: function( elem ) {<br/>		return sibling( elem, "previousSibling" );<br/>	},<br/>	nextAll: function( elem ) {<br/>		return dir( elem, "nextSibling" );<br/>	},<br/>	prevAll: function( elem ) {<br/>		return dir( elem, "previousSibling" );<br/>	},<br/>	nextUntil: function( elem, i, until ) {<br/>		return dir( elem, "nextSibling", until );<br/>	},<br/>	prevUntil: function( elem, i, until ) {<br/>		return dir( elem, "previousSibling", until );<br/>	},<br/>	siblings: function( elem ) {<br/>		return siblings( ( elem.parentNode || {} ).firstChild, elem );<br/>	},<br/>	children: function( elem ) {<br/>		return siblings( elem.firstChild );<br/>	},<br/>	contents: function( elem ) {<br/>        if ( nodeName( elem, "iframe" ) ) {<br/>            return elem.contentDocument;<br/>        }<br/><br/>        // Support: IE 9 - 11 only, iOS 7 only, Android Browser &lt;=4.3 only<br/>        // Treat the template element as a regular one in browsers that<br/>        // don't support it.<br/>        if ( nodeName( elem, "template" ) ) {<br/>            elem = elem.content || elem;<br/>        }<br/><br/>        return jQuery.merge( [], elem.childNodes );<br/>	}<br/>}, function( name, fn ) {<br/>	jQuery.fn[ name ] = function( until, selector ) {<br/>		var matched = jQuery.map( this, fn, until );<br/><br/>		if ( name.slice( -5 ) !== "Until" ) {<br/>			selector = until;<br/>		}<br/><br/>		if ( selector &amp;&amp; typeof selector === "string" ) {<br/>			matched = jQuery.filter( selector, matched );<br/>		}<br/><br/>		if ( this.length &gt; 1 ) {<br/><br/>			// Remove duplicates<br/>			if ( !guaranteedUnique[ name ] ) {<br/>				jQuery.uniqueSort( matched );<br/>			}<br/><br/>			// Reverse order for parents* and prev-derivatives<br/>			if ( rparentsprev.test( name ) ) {<br/>				matched.reverse();<br/>			}<br/>		}<br/><br/>		return this.pushStack( matched );<br/>	};<br/>} );<br/>var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );<br/><br/><br/><br/>// Convert String-formatted options into Object-formatted ones<br/>function createOptions( options ) {<br/>	var object = {};<br/>	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {<br/>		object[ flag ] = true;<br/>	} );<br/>	return object;<br/>}<br/><br/>/*<br/> * Create a callback list using the following parameters:<br/> *<br/> *	options: an optional list of space-separated options that will change how<br/> *			the callback list behaves or a more traditional option object<br/> *<br/> * By default a callback list will act like an event callback list and can be<br/> * "fired" multiple times.<br/> *<br/> * Possible options:<br/> *<br/> *	once:			will ensure the callback list can only be fired once (like a Deferred)<br/> *<br/> *	memory:			will keep track of previous values and will call any callback added<br/> *					after the list has been fired right away with the latest "memorized"<br/> *					values (like a Deferred)<br/> *<br/> *	unique:			will ensure a callback can only be added once (no duplicate in the list)<br/> *<br/> *	stopOnFalse:	interrupt callings when a callback returns false<br/> *<br/> */<br/>jQuery.Callbacks = function( options ) {<br/><br/>	// Convert options from String-formatted to Object-formatted if needed<br/>	// (we check in cache first)<br/>	options = typeof options === "string" ?<br/>		createOptions( options ) :<br/>		jQuery.extend( {}, options );<br/><br/>	var // Flag to know if list is currently firing<br/>		firing,<br/><br/>		// Last fire value for non-forgettable lists<br/>		memory,<br/><br/>		// Flag to know if list was already fired<br/>		fired,<br/><br/>		// Flag to prevent firing<br/>		locked,<br/><br/>		// Actual callback list<br/>		list = [],<br/><br/>		// Queue of execution data for repeatable lists<br/>		queue = [],<br/><br/>		// Index of currently firing callback (modified by add/remove as needed)<br/>		firingIndex = -1,<br/><br/>		// Fire callbacks<br/>		fire = function() {<br/><br/>			// Enforce single-firing<br/>			locked = locked || options.once;<br/><br/>			// Execute callbacks for all pending executions,<br/>			// respecting firingIndex overrides and runtime changes<br/>			fired = firing = true;<br/>			for ( ; queue.length; firingIndex = -1 ) {<br/>				memory = queue.shift();<br/>				while ( ++firingIndex &lt; list.length ) {<br/><br/>					// Run callback and check for early termination<br/>					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &amp;&amp;<br/>						options.stopOnFalse ) {<br/><br/>						// Jump to end and forget the data so .add doesn't re-fire<br/>						firingIndex = list.length;<br/>						memory = false;<br/>					}<br/>				}<br/>			}<br/><br/>			// Forget the data if we're done with it<br/>			if ( !options.memory ) {<br/>				memory = false;<br/>			}<br/><br/>			firing = false;<br/><br/>			// Clean up if we're done firing for good<br/>			if ( locked ) {<br/><br/>				// Keep an empty list if we have data for future add calls<br/>				if ( memory ) {<br/>					list = [];<br/><br/>				// Otherwise, this object is spent<br/>				} else {<br/>					list = "";<br/>				}<br/>			}<br/>		},<br/><br/>		// Actual Callbacks object<br/>		self = {<br/><br/>			// Add a callback or a collection of callbacks to the list<br/>			add: function() {<br/>				if ( list ) {<br/><br/>					// If we have memory from a past run, we should fire after adding<br/>					if ( memory &amp;&amp; !firing ) {<br/>						firingIndex = list.length - 1;<br/>						queue.push( memory );<br/>					}<br/><br/>					( function add( args ) {<br/>						jQuery.each( args, function( _, arg ) {<br/>							if ( isFunction( arg ) ) {<br/>								if ( !options.unique || !self.has( arg ) ) {<br/>									list.push( arg );<br/>								}<br/>							} else if ( arg &amp;&amp; arg.length &amp;&amp; toType( arg ) !== "string" ) {<br/><br/>								// Inspect recursively<br/>								add( arg );<br/>							}<br/>						} );<br/>					} )( arguments );<br/><br/>					if ( memory &amp;&amp; !firing ) {<br/>						fire();<br/>					}<br/>				}<br/>				return this;<br/>			},<br/><br/>			// Remove a callback from the list<br/>			remove: function() {<br/>				jQuery.each( arguments, function( _, arg ) {<br/>					var index;<br/>					while ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) {<br/>						list.splice( index, 1 );<br/><br/>						// Handle firing indexes<br/>						if ( index &lt;= firingIndex ) {<br/>							firingIndex--;<br/>						}<br/>					}<br/>				} );<br/>				return this;<br/>			},<br/><br/>			// Check if a given callback is in the list.<br/>			// If no argument is given, return whether or not list has callbacks attached.<br/>			has: function( fn ) {<br/>				return fn ?<br/>					jQuery.inArray( fn, list ) &gt; -1 :<br/>					list.length &gt; 0;<br/>			},<br/><br/>			// Remove all callbacks from the list<br/>			empty: function() {<br/>				if ( list ) {<br/>					list = [];<br/>				}<br/>				return this;<br/>			},<br/><br/>			// Disable .fire and .add<br/>			// Abort any current/pending executions<br/>			// Clear all callbacks and values<br/>			disable: function() {<br/>				locked = queue = [];<br/>				list = memory = "";<br/>				return this;<br/>			},<br/>			disabled: function() {<br/>				return !list;<br/>			},<br/><br/>			// Disable .fire<br/>			// Also disable .add unless we have memory (since it would have no effect)<br/>			// Abort any pending executions<br/>			lock: function() {<br/>				locked = queue = [];<br/>				if ( !memory &amp;&amp; !firing ) {<br/>					list = memory = "";<br/>				}<br/>				return this;<br/>			},<br/>			locked: function() {<br/>				return !!locked;<br/>			},<br/><br/>			// Call all callbacks with the given context and arguments<br/>			fireWith: function( context, args ) {<br/>				if ( !locked ) {<br/>					args = args || [];<br/>					args = [ context, args.slice ? args.slice() : args ];<br/>					queue.push( args );<br/>					if ( !firing ) {<br/>						fire();<br/>					}<br/>				}<br/>				return this;<br/>			},<br/><br/>			// Call all the callbacks with the given arguments<br/>			fire: function() {<br/>				self.fireWith( this, arguments );<br/>				return this;<br/>			},<br/><br/>			// To know if the callbacks have already been called at least once<br/>			fired: function() {<br/>				return !!fired;<br/>			}<br/>		};<br/><br/>	return self;<br/>};<br/><br/><br/>function Identity( v ) {<br/>	return v;<br/>}<br/>function Thrower( ex ) {<br/>	throw ex;<br/>}<br/><br/>function adoptValue( value, resolve, reject, noValue ) {<br/>	var method;<br/><br/>	try {<br/><br/>		// Check for promise aspect first to privilege synchronous behavior<br/>		if ( value &amp;&amp; isFunction( ( method = value.promise ) ) ) {<br/>			method.call( value ).done( resolve ).fail( reject );<br/><br/>		// Other thenables<br/>		} else if ( value &amp;&amp; isFunction( ( method = value.then ) ) ) {<br/>			method.call( value, resolve, reject );<br/><br/>		// Other non-thenables<br/>		} else {<br/><br/>			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:<br/>			// * false: [ value ].slice( 0 ) =&gt; resolve( value )<br/>			// * true: [ value ].slice( 1 ) =&gt; resolve()<br/>			resolve.apply( undefined, [ value ].slice( noValue ) );<br/>		}<br/><br/>	// For Promises/A+, convert exceptions into rejections<br/>	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in<br/>	// Deferred#then to conditionally suppress rejection.<br/>	} catch ( value ) {<br/><br/>		// Support: Android 4.0 only<br/>		// Strict mode functions invoked without .call/.apply get global-object context<br/>		reject.apply( undefined, [ value ] );<br/>	}<br/>}<br/><br/>jQuery.extend( {<br/><br/>	Deferred: function( func ) {<br/>		var tuples = [<br/><br/>				// action, add listener, callbacks,<br/>				// ... .then handlers, argument index, [final state]<br/>				[ "notify", "progress", jQuery.Callbacks( "memory" ),<br/>					jQuery.Callbacks( "memory" ), 2 ],<br/>				[ "resolve", "done", jQuery.Callbacks( "once memory" ),<br/>					jQuery.Callbacks( "once memory" ), 0, "resolved" ],<br/>				[ "reject", "fail", jQuery.Callbacks( "once memory" ),<br/>					jQuery.Callbacks( "once memory" ), 1, "rejected" ]<br/>			],<br/>			state = "pending",<br/>			promise = {<br/>				state: function() {<br/>					return state;<br/>				},<br/>				always: function() {<br/>					deferred.done( arguments ).fail( arguments );<br/>					return this;<br/>				},<br/>				"catch": function( fn ) {<br/>					return promise.then( null, fn );<br/>				},<br/><br/>				// Keep pipe for back-compat<br/>				pipe: function( /* fnDone, fnFail, fnProgress */ ) {<br/>					var fns = arguments;<br/><br/>					return jQuery.Deferred( function( newDefer ) {<br/>						jQuery.each( tuples, function( i, tuple ) {<br/><br/>							// Map tuples (progress, done, fail) to arguments (done, fail, progress)<br/>							var fn = isFunction( fns[ tuple[ 4 ] ] ) &amp;&amp; fns[ tuple[ 4 ] ];<br/><br/>							// deferred.progress(function() { bind to newDefer or newDefer.notify })<br/>							// deferred.done(function() { bind to newDefer or newDefer.resolve })<br/>							// deferred.fail(function() { bind to newDefer or newDefer.reject })<br/>							deferred[ tuple[ 1 ] ]( function() {<br/>								var returned = fn &amp;&amp; fn.apply( this, arguments );<br/>								if ( returned &amp;&amp; isFunction( returned.promise ) ) {<br/>									returned.promise()<br/>										.progress( newDefer.notify )<br/>										.done( newDefer.resolve )<br/>										.fail( newDefer.reject );<br/>								} else {<br/>									newDefer[ tuple[ 0 ] + "With" ](<br/>										this,<br/>										fn ? [ returned ] : arguments<br/>									);<br/>								}<br/>							} );<br/>						} );<br/>						fns = null;<br/>					} ).promise();<br/>				},<br/>				then: function( onFulfilled, onRejected, onProgress ) {<br/>					var maxDepth = 0;<br/>					function resolve( depth, deferred, handler, special ) {<br/>						return function() {<br/>							var that = this,<br/>								args = arguments,<br/>								mightThrow = function() {<br/>									var returned, then;<br/><br/>									// Support: Promises/A+ section 2.3.3.3.3<br/>									// https://promisesaplus.com/#point-59<br/>									// Ignore double-resolution attempts<br/>									if ( depth &lt; maxDepth ) {<br/>										return;<br/>									}<br/><br/>									returned = handler.apply( that, args );<br/><br/>									// Support: Promises/A+ section 2.3.1<br/>									// https://promisesaplus.com/#point-48<br/>									if ( returned === deferred.promise() ) {<br/>										throw new TypeError( "Thenable self-resolution" );<br/>									}<br/><br/>									// Support: Promises/A+ sections 2.3.3.1, 3.5<br/>									// https://promisesaplus.com/#point-54<br/>									// https://promisesaplus.com/#point-75<br/>									// Retrieve `then` only once<br/>									then = returned &amp;&amp;<br/><br/>										// Support: Promises/A+ section 2.3.4<br/>										// https://promisesaplus.com/#point-64<br/>										// Only check objects and functions for thenability<br/>										( typeof returned === "object" ||<br/>											typeof returned === "function" ) &amp;&amp;<br/>										returned.then;<br/><br/>									// Handle a returned thenable<br/>									if ( isFunction( then ) ) {<br/><br/>										// Special processors (notify) just wait for resolution<br/>										if ( special ) {<br/>											then.call(<br/>												returned,<br/>												resolve( maxDepth, deferred, Identity, special ),<br/>												resolve( maxDepth, deferred, Thrower, special )<br/>											);<br/><br/>										// Normal processors (resolve) also hook into progress<br/>										} else {<br/><br/>											// ...and disregard older resolution values<br/>											maxDepth++;<br/><br/>											then.call(<br/>												returned,<br/>												resolve( maxDepth, deferred, Identity, special ),<br/>												resolve( maxDepth, deferred, Thrower, special ),<br/>												resolve( maxDepth, deferred, Identity,<br/>													deferred.notifyWith )<br/>											);<br/>										}<br/><br/>									// Handle all other returned values<br/>									} else {<br/><br/>										// Only substitute handlers pass on context<br/>										// and multiple values (non-spec behavior)<br/>										if ( handler !== Identity ) {<br/>											that = undefined;<br/>											args = [ returned ];<br/>										}<br/><br/>										// Process the value(s)<br/>										// Default process is resolve<br/>										( special || deferred.resolveWith )( that, args );<br/>									}<br/>								},<br/><br/>								// Only normal processors (resolve) catch and reject exceptions<br/>								process = special ?<br/>									mightThrow :<br/>									function() {<br/>										try {<br/>											mightThrow();<br/>										} catch ( e ) {<br/><br/>											if ( jQuery.Deferred.exceptionHook ) {<br/>												jQuery.Deferred.exceptionHook( e,<br/>													process.stackTrace );<br/>											}<br/><br/>											// Support: Promises/A+ section 2.3.3.3.4.1<br/>											// https://promisesaplus.com/#point-61<br/>											// Ignore post-resolution exceptions<br/>											if ( depth + 1 &gt;= maxDepth ) {<br/><br/>												// Only substitute handlers pass on context<br/>												// and multiple values (non-spec behavior)<br/>												if ( handler !== Thrower ) {<br/>													that = undefined;<br/>													args = [ e ];<br/>												}<br/><br/>												deferred.rejectWith( that, args );<br/>											}<br/>										}<br/>									};<br/><br/>							// Support: Promises/A+ section 2.3.3.3.1<br/>							// https://promisesaplus.com/#point-57<br/>							// Re-resolve promises immediately to dodge false rejection from<br/>							// subsequent errors<br/>							if ( depth ) {<br/>								process();<br/>							} else {<br/><br/>								// Call an optional hook to record the stack, in case of exception<br/>								// since it's otherwise lost when execution goes async<br/>								if ( jQuery.Deferred.getStackHook ) {<br/>									process.stackTrace = jQuery.Deferred.getStackHook();<br/>								}<br/>								window.setTimeout( process );<br/>							}<br/>						};<br/>					}<br/><br/>					return jQuery.Deferred( function( newDefer ) {<br/><br/>						// progress_handlers.add( ... )<br/>						tuples[ 0 ][ 3 ].add(<br/>							resolve(<br/>								0,<br/>								newDefer,<br/>								isFunction( onProgress ) ?<br/>									onProgress :<br/>									Identity,<br/>								newDefer.notifyWith<br/>							)<br/>						);<br/><br/>						// fulfilled_handlers.add( ... )<br/>						tuples[ 1 ][ 3 ].add(<br/>							resolve(<br/>								0,<br/>								newDefer,<br/>								isFunction( onFulfilled ) ?<br/>									onFulfilled :<br/>									Identity<br/>							)<br/>						);<br/><br/>						// rejected_handlers.add( ... )<br/>						tuples[ 2 ][ 3 ].add(<br/>							resolve(<br/>								0,<br/>								newDefer,<br/>								isFunction( onRejected ) ?<br/>									onRejected :<br/>									Thrower<br/>							)<br/>						);<br/>					} ).promise();<br/>				},<br/><br/>				// Get a promise for this deferred<br/>				// If obj is provided, the promise aspect is added to the object<br/>				promise: function( obj ) {<br/>					return obj != null ? jQuery.extend( obj, promise ) : promise;<br/>				}<br/>			},<br/>			deferred = {};<br/><br/>		// Add list-specific methods<br/>		jQuery.each( tuples, function( i, tuple ) {<br/>			var list = tuple[ 2 ],<br/>				stateString = tuple[ 5 ];<br/><br/>			// promise.progress = list.add<br/>			// promise.done = list.add<br/>			// promise.fail = list.add<br/>			promise[ tuple[ 1 ] ] = list.add;<br/><br/>			// Handle state<br/>			if ( stateString ) {<br/>				list.add(<br/>					function() {<br/><br/>						// state = "resolved" (i.e., fulfilled)<br/>						// state = "rejected"<br/>						state = stateString;<br/>					},<br/><br/>					// rejected_callbacks.disable<br/>					// fulfilled_callbacks.disable<br/>					tuples[ 3 - i ][ 2 ].disable,<br/><br/>					// rejected_handlers.disable<br/>					// fulfilled_handlers.disable<br/>					tuples[ 3 - i ][ 3 ].disable,<br/><br/>					// progress_callbacks.lock<br/>					tuples[ 0 ][ 2 ].lock,<br/><br/>					// progress_handlers.lock<br/>					tuples[ 0 ][ 3 ].lock<br/>				);<br/>			}<br/><br/>			// progress_handlers.fire<br/>			// fulfilled_handlers.fire<br/>			// rejected_handlers.fire<br/>			list.add( tuple[ 3 ].fire );<br/><br/>			// deferred.notify = function() { deferred.notifyWith(...) }<br/>			// deferred.resolve = function() { deferred.resolveWith(...) }<br/>			// deferred.reject = function() { deferred.rejectWith(...) }<br/>			deferred[ tuple[ 0 ] ] = function() {<br/>				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );<br/>				return this;<br/>			};<br/><br/>			// deferred.notifyWith = list.fireWith<br/>			// deferred.resolveWith = list.fireWith<br/>			// deferred.rejectWith = list.fireWith<br/>			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;<br/>		} );<br/><br/>		// Make the deferred a promise<br/>		promise.promise( deferred );<br/><br/>		// Call given func if any<br/>		if ( func ) {<br/>			func.call( deferred, deferred );<br/>		}<br/><br/>		// All done!<br/>		return deferred;<br/>	},<br/><br/>	// Deferred helper<br/>	when: function( singleValue ) {<br/>		var<br/><br/>			// count of uncompleted subordinates<br/>			remaining = arguments.length,<br/><br/>			// count of unprocessed arguments<br/>			i = remaining,<br/><br/>			// subordinate fulfillment data<br/>			resolveContexts = Array( i ),<br/>			resolveValues = slice.call( arguments ),<br/><br/>			// the master Deferred<br/>			master = jQuery.Deferred(),<br/><br/>			// subordinate callback factory<br/>			updateFunc = function( i ) {<br/>				return function( value ) {<br/>					resolveContexts[ i ] = this;<br/>					resolveValues[ i ] = arguments.length &gt; 1 ? slice.call( arguments ) : value;<br/>					if ( !( --remaining ) ) {<br/>						master.resolveWith( resolveContexts, resolveValues );<br/>					}<br/>				};<br/>			};<br/><br/>		// Single- and empty arguments are adopted like Promise.resolve<br/>		if ( remaining &lt;= 1 ) {<br/>			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,<br/>				!remaining );<br/><br/>			// Use .then() to unwrap secondary thenables (cf. gh-3000)<br/>			if ( master.state() === "pending" ||<br/>				isFunction( resolveValues[ i ] &amp;&amp; resolveValues[ i ].then ) ) {<br/><br/>				return master.then();<br/>			}<br/>		}<br/><br/>		// Multiple arguments are aggregated like Promise.all array elements<br/>		while ( i-- ) {<br/>			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );<br/>		}<br/><br/>		return master.promise();<br/>	}<br/>} );<br/><br/><br/>// These usually indicate a programmer mistake during development,<br/>// warn about them ASAP rather than swallowing them by default.<br/>var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;<br/><br/>jQuery.Deferred.exceptionHook = function( error, stack ) {<br/><br/>	// Support: IE 8 - 9 only<br/>	// Console exists when dev tools are open, which can happen at any time<br/>	if ( window.console &amp;&amp; window.console.warn &amp;&amp; error &amp;&amp; rerrorNames.test( error.name ) ) {<br/>		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );<br/>	}<br/>};<br/><br/><br/><br/><br/>jQuery.readyException = function( error ) {<br/>	window.setTimeout( function() {<br/>		throw error;<br/>	} );<br/>};<br/><br/><br/><br/><br/>// The deferred used on DOM ready<br/>var readyList = jQuery.Deferred();<br/><br/>jQuery.fn.ready = function( fn ) {<br/><br/>	readyList<br/>		.then( fn )<br/><br/>		// Wrap jQuery.readyException in a function so that the lookup<br/>		// happens at the time of error handling instead of callback<br/>		// registration.<br/>		.catch( function( error ) {<br/>			jQuery.readyException( error );<br/>		} );<br/><br/>	return this;<br/>};<br/><br/>jQuery.extend( {<br/><br/>	// Is the DOM ready to be used? Set to true once it occurs.<br/>	isReady: false,<br/><br/>	// A counter to track how many items to wait for before<br/>	// the ready event fires. See #6781<br/>	readyWait: 1,<br/><br/>	// Handle when the DOM is ready<br/>	ready: function( wait ) {<br/><br/>		// Abort if there are pending holds or we're already ready<br/>		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {<br/>			return;<br/>		}<br/><br/>		// Remember that the DOM is ready<br/>		jQuery.isReady = true;<br/><br/>		// If a normal DOM Ready event fired, decrement, and wait if need be<br/>		if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) {<br/>			return;<br/>		}<br/><br/>		// If there are functions bound, to execute<br/>		readyList.resolveWith( document, [ jQuery ] );<br/>	}<br/>} );<br/><br/>jQuery.ready.then = readyList.then;<br/><br/>// The ready event handler and self cleanup method<br/>function completed() {<br/>	document.removeEventListener( "DOMContentLoaded", completed );<br/>	window.removeEventListener( "load", completed );<br/>	jQuery.ready();<br/>}<br/><br/>// Catch cases where $(document).ready() is called<br/>// after the browser event has already occurred.<br/>// Support: IE &lt;=9 - 10 only<br/>// Older IE sometimes signals "interactive" too soon<br/>if ( document.readyState === "complete" ||<br/>	( document.readyState !== "loading" &amp;&amp; !document.documentElement.doScroll ) ) {<br/><br/>	// Handle it asynchronously to allow scripts the opportunity to delay ready<br/>	window.setTimeout( jQuery.ready );<br/><br/>} else {<br/><br/>	// Use the handy event callback<br/>	document.addEventListener( "DOMContentLoaded", completed );<br/><br/>	// A fallback to window.onload, that will always work<br/>	window.addEventListener( "load", completed );<br/>}<br/><br/><br/><br/><br/>// Multifunctional method to get and set values of a collection<br/>// The value/s can optionally be executed if it's a function<br/>var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {<br/>	var i = 0,<br/>		len = elems.length,<br/>		bulk = key == null;<br/><br/>	// Sets many values<br/>	if ( toType( key ) === "object" ) {<br/>		chainable = true;<br/>		for ( i in key ) {<br/>			access( elems, fn, i, key[ i ], true, emptyGet, raw );<br/>		}<br/><br/>	// Sets one value<br/>	} else if ( value !== undefined ) {<br/>		chainable = true;<br/><br/>		if ( !isFunction( value ) ) {<br/>			raw = true;<br/>		}<br/><br/>		if ( bulk ) {<br/><br/>			// Bulk operations run against the entire set<br/>			if ( raw ) {<br/>				fn.call( elems, value );<br/>				fn = null;<br/><br/>			// ...except when executing function values<br/>			} else {<br/>				bulk = fn;<br/>				fn = function( elem, key, value ) {<br/>					return bulk.call( jQuery( elem ), value );<br/>				};<br/>			}<br/>		}<br/><br/>		if ( fn ) {<br/>			for ( ; i &lt; len; i++ ) {<br/>				fn(<br/>					elems[ i ], key, raw ?<br/>					value :<br/>					value.call( elems[ i ], i, fn( elems[ i ], key ) )<br/>				);<br/>			}<br/>		}<br/>	}<br/><br/>	if ( chainable ) {<br/>		return elems;<br/>	}<br/><br/>	// Gets<br/>	if ( bulk ) {<br/>		return fn.call( elems );<br/>	}<br/><br/>	return len ? fn( elems[ 0 ], key ) : emptyGet;<br/>};<br/><br/><br/>// Matches dashed string for camelizing<br/>var rmsPrefix = /^-ms-/,<br/>	rdashAlpha = /-([a-z])/g;<br/><br/>// Used by camelCase as callback to replace()<br/>function fcamelCase( all, letter ) {<br/>	return letter.toUpperCase();<br/>}<br/><br/>// Convert dashed to camelCase; used by the css and data modules<br/>// Support: IE &lt;=9 - 11, Edge 12 - 15<br/>// Microsoft forgot to hump their vendor prefix (#9572)<br/>function camelCase( string ) {<br/>	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );<br/>}<br/>var acceptData = function( owner ) {<br/><br/>	// Accepts only:<br/>	//  - Node<br/>	//    - Node.ELEMENT_NODE<br/>	//    - Node.DOCUMENT_NODE<br/>	//  - Object<br/>	//    - Any<br/>	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );<br/>};<br/><br/><br/><br/><br/>function Data() {<br/>	this.expando = jQuery.expando + Data.uid++;<br/>}<br/><br/>Data.uid = 1;<br/><br/>Data.prototype = {<br/><br/>	cache: function( owner ) {<br/><br/>		// Check if the owner object already has a cache<br/>		var value = owner[ this.expando ];<br/><br/>		// If not, create one<br/>		if ( !value ) {<br/>			value = {};<br/><br/>			// We can accept data for non-element nodes in modern browsers,<br/>			// but we should not, see #8335.<br/>			// Always return an empty object.<br/>			if ( acceptData( owner ) ) {<br/><br/>				// If it is a node unlikely to be stringify-ed or looped over<br/>				// use plain assignment<br/>				if ( owner.nodeType ) {<br/>					owner[ this.expando ] = value;<br/><br/>				// Otherwise secure it in a non-enumerable property<br/>				// configurable must be true to allow the property to be<br/>				// deleted when data is removed<br/>				} else {<br/>					Object.defineProperty( owner, this.expando, {<br/>						value: value,<br/>						configurable: true<br/>					} );<br/>				}<br/>			}<br/>		}<br/><br/>		return value;<br/>	},<br/>	set: function( owner, data, value ) {<br/>		var prop,<br/>			cache = this.cache( owner );<br/><br/>		// Handle: [ owner, key, value ] args<br/>		// Always use camelCase key (gh-2257)<br/>		if ( typeof data === "string" ) {<br/>			cache[ camelCase( data ) ] = value;<br/><br/>		// Handle: [ owner, { properties } ] args<br/>		} else {<br/><br/>			// Copy the properties one-by-one to the cache object<br/>			for ( prop in data ) {<br/>				cache[ camelCase( prop ) ] = data[ prop ];<br/>			}<br/>		}<br/>		return cache;<br/>	},<br/>	get: function( owner, key ) {<br/>		return key === undefined ?<br/>			this.cache( owner ) :<br/><br/>			// Always use camelCase key (gh-2257)<br/>			owner[ this.expando ] &amp;&amp; owner[ this.expando ][ camelCase( key ) ];<br/>	},<br/>	access: function( owner, key, value ) {<br/><br/>		// In cases where either:<br/>		//<br/>		//   1. No key was specified<br/>		//   2. A string key was specified, but no value provided<br/>		//<br/>		// Take the "read" path and allow the get method to determine<br/>		// which value to return, respectively either:<br/>		//<br/>		//   1. The entire cache object<br/>		//   2. The data stored at the key<br/>		//<br/>		if ( key === undefined ||<br/>				( ( key &amp;&amp; typeof key === "string" ) &amp;&amp; value === undefined ) ) {<br/><br/>			return this.get( owner, key );<br/>		}<br/><br/>		// When the key is not a string, or both a key and value<br/>		// are specified, set or extend (existing objects) with either:<br/>		//<br/>		//   1. An object of properties<br/>		//   2. A key and value<br/>		//<br/>		this.set( owner, key, value );<br/><br/>		// Since the "set" path can have two possible entry points<br/>		// return the expected data based on which path was taken[*]<br/>		return value !== undefined ? value : key;<br/>	},<br/>	remove: function( owner, key ) {<br/>		var i,<br/>			cache = owner[ this.expando ];<br/><br/>		if ( cache === undefined ) {<br/>			return;<br/>		}<br/><br/>		if ( key !== undefined ) {<br/><br/>			// Support array or space separated string of keys<br/>			if ( Array.isArray( key ) ) {<br/><br/>				// If key is an array of keys...<br/>				// We always set camelCase keys, so remove that.<br/>				key = key.map( camelCase );<br/>			} else {<br/>				key = camelCase( key );<br/><br/>				// If a key with the spaces exists, use it.<br/>				// Otherwise, create an array by matching non-whitespace<br/>				key = key in cache ?<br/>					[ key ] :<br/>					( key.match( rnothtmlwhite ) || [] );<br/>			}<br/><br/>			i = key.length;<br/><br/>			while ( i-- ) {<br/>				delete cache[ key[ i ] ];<br/>			}<br/>		}<br/><br/>		// Remove the expando if there's no more data<br/>		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {<br/><br/>			// Support: Chrome &lt;=35 - 45<br/>			// Webkit &amp; Blink performance suffers when deleting properties<br/>			// from DOM nodes, so set to undefined instead<br/>			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)<br/>			if ( owner.nodeType ) {<br/>				owner[ this.expando ] = undefined;<br/>			} else {<br/>				delete owner[ this.expando ];<br/>			}<br/>		}<br/>	},<br/>	hasData: function( owner ) {<br/>		var cache = owner[ this.expando ];<br/>		return cache !== undefined &amp;&amp; !jQuery.isEmptyObject( cache );<br/>	}<br/>};<br/>var dataPriv = new Data();<br/><br/>var dataUser = new Data();<br/><br/><br/><br/>//	Implementation Summary<br/>//<br/>//	1. Enforce API surface and semantic compatibility with 1.9.x branch<br/>//	2. Improve the module's maintainability by reducing the storage<br/>//		paths to a single mechanism.<br/>//	3. Use the same single mechanism to support "private" and "user" data.<br/>//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)<br/>//	5. Avoid exposing implementation details on user objects (eg. expando properties)<br/>//	6. Provide a clear path for implementation upgrade to WeakMap in 2014<br/><br/>var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,<br/>	rmultiDash = /[A-Z]/g;<br/><br/>function getData( data ) {<br/>	if ( data === "true" ) {<br/>		return true;<br/>	}<br/><br/>	if ( data === "false" ) {<br/>		return false;<br/>	}<br/><br/>	if ( data === "null" ) {<br/>		return null;<br/>	}<br/><br/>	// Only convert to a number if it doesn't change the string<br/>	if ( data === +data + "" ) {<br/>		return +data;<br/>	}<br/><br/>	if ( rbrace.test( data ) ) {<br/>		return JSON.parse( data );<br/>	}<br/><br/>	return data;<br/>}<br/><br/>function dataAttr( elem, key, data ) {<br/>	var name;<br/><br/>	// If nothing was found internally, try to fetch any<br/>	// data from the HTML5 data-* attribute<br/>	if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {<br/>		name = "data-" + key.replace( rmultiDash, "-$&amp;" ).toLowerCase();<br/>		data = elem.getAttribute( name );<br/><br/>		if ( typeof data === "string" ) {<br/>			try {<br/>				data = getData( data );<br/>			} catch ( e ) {}<br/><br/>			// Make sure we set the data so it isn't changed later<br/>			dataUser.set( elem, key, data );<br/>		} else {<br/>			data = undefined;<br/>		}<br/>	}<br/>	return data;<br/>}<br/><br/>jQuery.extend( {<br/>	hasData: function( elem ) {<br/>		return dataUser.hasData( elem ) || dataPriv.hasData( elem );<br/>	},<br/><br/>	data: function( elem, name, data ) {<br/>		return dataUser.access( elem, name, data );<br/>	},<br/><br/>	removeData: function( elem, name ) {<br/>		dataUser.remove( elem, name );<br/>	},<br/><br/>	// TODO: Now that all calls to _data and _removeData have been replaced<br/>	// with direct calls to dataPriv methods, these can be deprecated.<br/>	_data: function( elem, name, data ) {<br/>		return dataPriv.access( elem, name, data );<br/>	},<br/><br/>	_removeData: function( elem, name ) {<br/>		dataPriv.remove( elem, name );<br/>	}<br/>} );<br/><br/>jQuery.fn.extend( {<br/>	data: function( key, value ) {<br/>		var i, name, data,<br/>			elem = this[ 0 ],<br/>			attrs = elem &amp;&amp; elem.attributes;<br/><br/>		// Gets all values<br/>		if ( key === undefined ) {<br/>			if ( this.length ) {<br/>				data = dataUser.get( elem );<br/><br/>				if ( elem.nodeType === 1 &amp;&amp; !dataPriv.get( elem, "hasDataAttrs" ) ) {<br/>					i = attrs.length;<br/>					while ( i-- ) {<br/><br/>						// Support: IE 11 only<br/>						// The attrs elements can be null (#14894)<br/>						if ( attrs[ i ] ) {<br/>							name = attrs[ i ].name;<br/>							if ( name.indexOf( "data-" ) === 0 ) {<br/>								name = camelCase( name.slice( 5 ) );<br/>								dataAttr( elem, name, data[ name ] );<br/>							}<br/>						}<br/>					}<br/>					dataPriv.set( elem, "hasDataAttrs", true );<br/>				}<br/>			}<br/><br/>			return data;<br/>		}<br/><br/>		// Sets multiple values<br/>		if ( typeof key === "object" ) {<br/>			return this.each( function() {<br/>				dataUser.set( this, key );<br/>			} );<br/>		}<br/><br/>		return access( this, function( value ) {<br/>			var data;<br/><br/>			// The calling jQuery object (element matches) is not empty<br/>			// (and therefore has an element appears at this[ 0 ]) and the<br/>			// `value` parameter was not undefined. An empty jQuery object<br/>			// will result in `undefined` for elem = this[ 0 ] which will<br/>			// throw an exception if an attempt to read a data cache is made.<br/>			if ( elem &amp;&amp; value === undefined ) {<br/><br/>				// Attempt to get data from the cache<br/>				// The key will always be camelCased in Data<br/>				data = dataUser.get( elem, key );<br/>				if ( data !== undefined ) {<br/>					return data;<br/>				}<br/><br/>				// Attempt to "discover" the data in<br/>				// HTML5 custom data-* attrs<br/>				data = dataAttr( elem, key );<br/>				if ( data !== undefined ) {<br/>					return data;<br/>				}<br/><br/>				// We tried really hard, but the data doesn't exist.<br/>				return;<br/>			}<br/><br/>			// Set the data...<br/>			this.each( function() {<br/><br/>				// We always store the camelCased key<br/>				dataUser.set( this, key, value );<br/>			} );<br/>		}, null, value, arguments.length &gt; 1, null, true );<br/>	},<br/><br/>	removeData: function( key ) {<br/>		return this.each( function() {<br/>			dataUser.remove( this, key );<br/>		} );<br/>	}<br/>} );<br/><br/><br/>jQuery.extend( {<br/>	queue: function( elem, type, data ) {<br/>		var queue;<br/><br/>		if ( elem ) {<br/>			type = ( type || "fx" ) + "queue";<br/>			queue = dataPriv.get( elem, type );<br/><br/>			// Speed up dequeue by getting out quickly if this is just a lookup<br/>			if ( data ) {<br/>				if ( !queue || Array.isArray( data ) ) {<br/>					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );<br/>				} else {<br/>					queue.push( data );<br/>				}<br/>			}<br/>			return queue || [];<br/>		}<br/>	},<br/><br/>	dequeue: function( elem, type ) {<br/>		type = type || "fx";<br/><br/>		var queue = jQuery.queue( elem, type ),<br/>			startLength = queue.length,<br/>			fn = queue.shift(),<br/>			hooks = jQuery._queueHooks( elem, type ),<br/>			next = function() {<br/>				jQuery.dequeue( elem, type );<br/>			};<br/><br/>		// If the fx queue is dequeued, always remove the progress sentinel<br/>		if ( fn === "inprogress" ) {<br/>			fn = queue.shift();<br/>			startLength--;<br/>		}<br/><br/>		if ( fn ) {<br/><br/>			// Add a progress sentinel to prevent the fx queue from being<br/>			// automatically dequeued<br/>			if ( type === "fx" ) {<br/>				queue.unshift( "inprogress" );<br/>			}<br/><br/>			// Clear up the last queue stop function<br/>			delete hooks.stop;<br/>			fn.call( elem, next, hooks );<br/>		}<br/><br/>		if ( !startLength &amp;&amp; hooks ) {<br/>			hooks.empty.fire();<br/>		}<br/>	},<br/><br/>	// Not public - generate a queueHooks object, or return the current one<br/>	_queueHooks: function( elem, type ) {<br/>		var key = type + "queueHooks";<br/>		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {<br/>			empty: jQuery.Callbacks( "once memory" ).add( function() {<br/>				dataPriv.remove( elem, [ type + "queue", key ] );<br/>			} )<br/>		} );<br/>	}<br/>} );<br/><br/>jQuery.fn.extend( {<br/>	queue: function( type, data ) {<br/>		var setter = 2;<br/><br/>		if ( typeof type !== "string" ) {<br/>			data = type;<br/>			type = "fx";<br/>			setter--;<br/>		}<br/><br/>		if ( arguments.length &lt; setter ) {<br/>			return jQuery.queue( this[ 0 ], type );<br/>		}<br/><br/>		return data === undefined ?<br/>			this :<br/>			this.each( function() {<br/>				var queue = jQuery.queue( this, type, data );<br/><br/>				// Ensure a hooks for this queue<br/>				jQuery._queueHooks( this, type );<br/><br/>				if ( type === "fx" &amp;&amp; queue[ 0 ] !== "inprogress" ) {<br/>					jQuery.dequeue( this, type );<br/>				}<br/>			} );<br/>	},<br/>	dequeue: function( type ) {<br/>		return this.each( function() {<br/>			jQuery.dequeue( this, type );<br/>		} );<br/>	},<br/>	clearQueue: function( type ) {<br/>		return this.queue( type || "fx", [] );<br/>	},<br/><br/>	// Get a promise resolved when queues of a certain type<br/>	// are emptied (fx is the type by default)<br/>	promise: function( type, obj ) {<br/>		var tmp,<br/>			count = 1,<br/>			defer = jQuery.Deferred(),<br/>			elements = this,<br/>			i = this.length,<br/>			resolve = function() {<br/>				if ( !( --count ) ) {<br/>					defer.resolveWith( elements, [ elements ] );<br/>				}<br/>			};<br/><br/>		if ( typeof type !== "string" ) {<br/>			obj = type;<br/>			type = undefined;<br/>		}<br/>		type = type || "fx";<br/><br/>		while ( i-- ) {<br/>			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );<br/>			if ( tmp &amp;&amp; tmp.empty ) {<br/>				count++;<br/>				tmp.empty.add( resolve );<br/>			}<br/>		}<br/>		resolve();<br/>		return defer.promise( obj );<br/>	}<br/>} );<br/>var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;<br/><br/>var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );<br/><br/><br/>var cssExpand = [ "Top", "Right", "Bottom", "Left" ];<br/><br/>var isHiddenWithinTree = function( elem, el ) {<br/><br/>		// isHiddenWithinTree might be called from jQuery#filter function;<br/>		// in that case, element will be second argument<br/>		elem = el || elem;<br/><br/>		// Inline style trumps all<br/>		return elem.style.display === "none" ||<br/>			elem.style.display === "" &amp;&amp;<br/><br/>			// Otherwise, check computed style<br/>			// Support: Firefox &lt;=43 - 45<br/>			// Disconnected elements can have computed display: none, so first confirm that elem is<br/>			// in the document.<br/>			jQuery.contains( elem.ownerDocument, elem ) &amp;&amp;<br/><br/>			jQuery.css( elem, "display" ) === "none";<br/>	};<br/><br/>var swap = function( elem, options, callback, args ) {<br/>	var ret, name,<br/>		old = {};<br/><br/>	// Remember the old values, and insert the new ones<br/>	for ( name in options ) {<br/>		old[ name ] = elem.style[ name ];<br/>		elem.style[ name ] = options[ name ];<br/>	}<br/><br/>	ret = callback.apply( elem, args || [] );<br/><br/>	// Revert the old values<br/>	for ( name in options ) {<br/>		elem.style[ name ] = old[ name ];<br/>	}<br/><br/>	return ret;<br/>};<br/><br/><br/><br/><br/>function adjustCSS( elem, prop, valueParts, tween ) {<br/>	var adjusted, scale,<br/>		maxIterations = 20,<br/>		currentValue = tween ?<br/>			function() {<br/>				return tween.cur();<br/>			} :<br/>			function() {<br/>				return jQuery.css( elem, prop, "" );<br/>			},<br/>		initial = currentValue(),<br/>		unit = valueParts &amp;&amp; valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),<br/><br/>		// Starting value computation is required for potential unit mismatches<br/>		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" &amp;&amp; +initial ) &amp;&amp;<br/>			rcssNum.exec( jQuery.css( elem, prop ) );<br/><br/>	if ( initialInUnit &amp;&amp; initialInUnit[ 3 ] !== unit ) {<br/><br/>		// Support: Firefox &lt;=54<br/>		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)<br/>		initial = initial / 2;<br/><br/>		// Trust units reported by jQuery.css<br/>		unit = unit || initialInUnit[ 3 ];<br/><br/>		// Iteratively approximate from a nonzero starting point<br/>		initialInUnit = +initial || 1;<br/><br/>		while ( maxIterations-- ) {<br/><br/>			// Evaluate and update our best guess (doubling guesses that zero out).<br/>			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).<br/>			jQuery.style( elem, prop, initialInUnit + unit );<br/>			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) &lt;= 0 ) {<br/>				maxIterations = 0;<br/>			}<br/>			initialInUnit = initialInUnit / scale;<br/><br/>		}<br/><br/>		initialInUnit = initialInUnit * 2;<br/>		jQuery.style( elem, prop, initialInUnit + unit );<br/><br/>		// Make sure we update the tween properties later on<br/>		valueParts = valueParts || [];<br/>	}<br/><br/>	if ( valueParts ) {<br/>		initialInUnit = +initialInUnit || +initial || 0;<br/><br/>		// Apply relative offset (+=/-=) if specified<br/>		adjusted = valueParts[ 1 ] ?<br/>			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :<br/>			+valueParts[ 2 ];<br/>		if ( tween ) {<br/>			tween.unit = unit;<br/>			tween.start = initialInUnit;<br/>			tween.end = adjusted;<br/>		}<br/>	}<br/>	return adjusted;<br/>}<br/><br/><br/>var defaultDisplayMap = {};<br/><br/>function getDefaultDisplay( elem ) {<br/>	var temp,<br/>		doc = elem.ownerDocument,<br/>		nodeName = elem.nodeName,<br/>		display = defaultDisplayMap[ nodeName ];<br/><br/>	if ( display ) {<br/>		return display;<br/>	}<br/><br/>	temp = doc.body.appendChild( doc.createElement( nodeName ) );<br/>	display = jQuery.css( temp, "display" );<br/><br/>	temp.parentNode.removeChild( temp );<br/><br/>	if ( display === "none" ) {<br/>		display = "block";<br/>	}<br/>	defaultDisplayMap[ nodeName ] = display;<br/><br/>	return display;<br/>}<br/><br/>function showHide( elements, show ) {<br/>	var display, elem,<br/>		values = [],<br/>		index = 0,<br/>		length = elements.length;<br/><br/>	// Determine new display value for elements that need to change<br/>	for ( ; index &lt; length; index++ ) {<br/>		elem = elements[ index ];<br/>		if ( !elem.style ) {<br/>			continue;<br/>		}<br/><br/>		display = elem.style.display;<br/>		if ( show ) {<br/><br/>			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)<br/>			// check is required in this first loop unless we have a nonempty display value (either<br/>			// inline or about-to-be-restored)<br/>			if ( display === "none" ) {<br/>				values[ index ] = dataPriv.get( elem, "display" ) || null;<br/>				if ( !values[ index ] ) {<br/>					elem.style.display = "";<br/>				}<br/>			}<br/>			if ( elem.style.display === "" &amp;&amp; isHiddenWithinTree( elem ) ) {<br/>				values[ index ] = getDefaultDisplay( elem );<br/>			}<br/>		} else {<br/>			if ( display !== "none" ) {<br/>				values[ index ] = "none";<br/><br/>				// Remember what we're overwriting<br/>				dataPriv.set( elem, "display", display );<br/>			}<br/>		}<br/>	}<br/><br/>	// Set the display of the elements in a second loop to avoid constant reflow<br/>	for ( index = 0; index &lt; length; index++ ) {<br/>		if ( values[ index ] != null ) {<br/>			elements[ index ].style.display = values[ index ];<br/>		}<br/>	}<br/><br/>	return elements;<br/>}<br/><br/>jQuery.fn.extend( {<br/>	show: function() {<br/>		return showHide( this, true );<br/>	},<br/>	hide: function() {<br/>		return showHide( this );<br/>	},<br/>	toggle: function( state ) {<br/>		if ( typeof state === "boolean" ) {<br/>			return state ? this.show() : this.hide();<br/>		}<br/><br/>		return this.each( function() {<br/>			if ( isHiddenWithinTree( this ) ) {<br/>				jQuery( this ).show();<br/>			} else {<br/>				jQuery( this ).hide();<br/>			}<br/>		} );<br/>	}<br/>} );<br/>var rcheckableType = ( /^(?:checkbox|radio)$/i );<br/><br/>var rtagName = ( /&lt;([a-z][^\/\0&gt;\x20\t\r\n\f]+)/i );<br/><br/>var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );<br/><br/><br/><br/>// We have to close these tags to support XHTML (#13200)<br/>var wrapMap = {<br/><br/>	// Support: IE &lt;=9 only<br/>	option: [ 1, "&lt;select multiple='multiple'&gt;", "&lt;/select&gt;" ],<br/><br/>	// XHTML parsers do not magically insert elements in the<br/>	// same way that tag soup parsers do. So we cannot shorten<br/>	// this by omitting &lt;tbody&gt; or other required elements.<br/>	thead: [ 1, "&lt;table&gt;", "&lt;/table&gt;" ],<br/>	col: [ 2, "&lt;table&gt;&lt;colgroup&gt;", "&lt;/colgroup&gt;&lt;/table&gt;" ],<br/>	tr: [ 2, "&lt;table&gt;&lt;tbody&gt;", "&lt;/tbody&gt;&lt;/table&gt;" ],<br/>	td: [ 3, "&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;", "&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;" ],<br/><br/>	_default: [ 0, "", "" ]<br/>};<br/><br/>// Support: IE &lt;=9 only<br/>wrapMap.optgroup = wrapMap.option;<br/><br/>wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;<br/>wrapMap.th = wrapMap.td;<br/><br/><br/>function getAll( context, tag ) {<br/><br/>	// Support: IE &lt;=9 - 11 only<br/>	// Use typeof to avoid zero-argument method invocation on host objects (#15151)<br/>	var ret;<br/><br/>	if ( typeof context.getElementsByTagName !== "undefined" ) {<br/>		ret = context.getElementsByTagName( tag || "*" );<br/><br/>	} else if ( typeof context.querySelectorAll !== "undefined" ) {<br/>		ret = context.querySelectorAll( tag || "*" );<br/><br/>	} else {<br/>		ret = [];<br/>	}<br/><br/>	if ( tag === undefined || tag &amp;&amp; nodeName( context, tag ) ) {<br/>		return jQuery.merge( [ context ], ret );<br/>	}<br/><br/>	return ret;<br/>}<br/><br/><br/>// Mark scripts as having already been evaluated<br/>function setGlobalEval( elems, refElements ) {<br/>	var i = 0,<br/>		l = elems.length;<br/><br/>	for ( ; i &lt; l; i++ ) {<br/>		dataPriv.set(<br/>			elems[ i ],<br/>			"globalEval",<br/>			!refElements || dataPriv.get( refElements[ i ], "globalEval" )<br/>		);<br/>	}<br/>}<br/><br/><br/>var rhtml = /&lt;|&amp;#?\w+;/;<br/><br/>function buildFragment( elems, context, scripts, selection, ignored ) {<br/>	var elem, tmp, tag, wrap, contains, j,<br/>		fragment = context.createDocumentFragment(),<br/>		nodes = [],<br/>		i = 0,<br/>		l = elems.length;<br/><br/>	for ( ; i &lt; l; i++ ) {<br/>		elem = elems[ i ];<br/><br/>		if ( elem || elem === 0 ) {<br/><br/>			// Add nodes directly<br/>			if ( toType( elem ) === "object" ) {<br/><br/>				// Support: Android &lt;=4.0 only, PhantomJS 1 only<br/>				// push.apply(_, arraylike) throws on ancient WebKit<br/>				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );<br/><br/>			// Convert non-html into a text node<br/>			} else if ( !rhtml.test( elem ) ) {<br/>				nodes.push( context.createTextNode( elem ) );<br/><br/>			// Convert html into DOM nodes<br/>			} else {<br/>				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );<br/><br/>				// Deserialize a standard representation<br/>				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();<br/>				wrap = wrapMap[ tag ] || wrapMap._default;<br/>				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];<br/><br/>				// Descend through wrappers to the right content<br/>				j = wrap[ 0 ];<br/>				while ( j-- ) {<br/>					tmp = tmp.lastChild;<br/>				}<br/><br/>				// Support: Android &lt;=4.0 only, PhantomJS 1 only<br/>				// push.apply(_, arraylike) throws on ancient WebKit<br/>				jQuery.merge( nodes, tmp.childNodes );<br/><br/>				// Remember the top-level container<br/>				tmp = fragment.firstChild;<br/><br/>				// Ensure the created nodes are orphaned (#12392)<br/>				tmp.textContent = "";<br/>			}<br/>		}<br/>	}<br/><br/>	// Remove wrapper from fragment<br/>	fragment.textContent = "";<br/><br/>	i = 0;<br/>	while ( ( elem = nodes[ i++ ] ) ) {<br/><br/>		// Skip elements already in the context collection (trac-4087)<br/>		if ( selection &amp;&amp; jQuery.inArray( elem, selection ) &gt; -1 ) {<br/>			if ( ignored ) {<br/>				ignored.push( elem );<br/>			}<br/>			continue;<br/>		}<br/><br/>		contains = jQuery.contains( elem.ownerDocument, elem );<br/><br/>		// Append to fragment<br/>		tmp = getAll( fragment.appendChild( elem ), "script" );<br/><br/>		// Preserve script evaluation history<br/>		if ( contains ) {<br/>			setGlobalEval( tmp );<br/>		}<br/><br/>		// Capture executables<br/>		if ( scripts ) {<br/>			j = 0;<br/>			while ( ( elem = tmp[ j++ ] ) ) {<br/>				if ( rscriptType.test( elem.type || "" ) ) {<br/>					scripts.push( elem );<br/>				}<br/>			}<br/>		}<br/>	}<br/><br/>	return fragment;<br/>}<br/><br/><br/>( function() {<br/>	var fragment = document.createDocumentFragment(),<br/>		div = fragment.appendChild( document.createElement( "div" ) ),<br/>		input = document.createElement( "input" );<br/><br/>	// Support: Android 4.0 - 4.3 only<br/>	// Check state lost if the name is set (#11217)<br/>	// Support: Windows Web Apps (WWA)<br/>	// `name` and `type` must use .setAttribute for WWA (#14901)<br/>	input.setAttribute( "type", "radio" );<br/>	input.setAttribute( "checked", "checked" );<br/>	input.setAttribute( "name", "t" );<br/><br/>	div.appendChild( input );<br/><br/>	// Support: Android &lt;=4.1 only<br/>	// Older WebKit doesn't clone checked state correctly in fragments<br/>	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;<br/><br/>	// Support: IE &lt;=11 only<br/>	// Make sure textarea (and checkbox) defaultValue is properly cloned<br/>	div.innerHTML = "&lt;textarea&gt;x&lt;/textarea&gt;";<br/>	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;<br/>} )();<br/>var documentElement = document.documentElement;<br/><br/><br/><br/>var<br/>	rkeyEvent = /^key/,<br/>	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,<br/>	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;<br/><br/>function returnTrue() {<br/>	return true;<br/>}<br/><br/>function returnFalse() {<br/>	return false;<br/>}<br/><br/>// Support: IE &lt;=9 only<br/>// See #13393 for more info<br/>function safeActiveElement() {<br/>	try {<br/>		return document.activeElement;<br/>	} catch ( err ) { }<br/>}<br/><br/>function on( elem, types, selector, data, fn, one ) {<br/>	var origFn, type;<br/><br/>	// Types can be a map of types/handlers<br/>	if ( typeof types === "object" ) {<br/><br/>		// ( types-Object, selector, data )<br/>		if ( typeof selector !== "string" ) {<br/><br/>			// ( types-Object, data )<br/>			data = data || selector;<br/>			selector = undefined;<br/>		}<br/>		for ( type in types ) {<br/>			on( elem, type, selector, data, types[ type ], one );<br/>		}<br/>		return elem;<br/>	}<br/><br/>	if ( data == null &amp;&amp; fn == null ) {<br/><br/>		// ( types, fn )<br/>		fn = selector;<br/>		data = selector = undefined;<br/>	} else if ( fn == null ) {<br/>		if ( typeof selector === "string" ) {<br/><br/>			// ( types, selector, fn )<br/>			fn = data;<br/>			data = undefined;<br/>		} else {<br/><br/>			// ( types, data, fn )<br/>			fn = data;<br/>			data = selector;<br/>			selector = undefined;<br/>		}<br/>	}<br/>	if ( fn === false ) {<br/>		fn = returnFalse;<br/>	} else if ( !fn ) {<br/>		return elem;<br/>	}<br/><br/>	if ( one === 1 ) {<br/>		origFn = fn;<br/>		fn = function( event ) {<br/><br/>			// Can use an empty set, since event contains the info<br/>			jQuery().off( event );<br/>			return origFn.apply( this, arguments );<br/>		};<br/><br/>		// Use same guid so caller can remove using origFn<br/>		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );<br/>	}<br/>	return elem.each( function() {<br/>		jQuery.event.add( this, types, fn, data, selector );<br/>	} );<br/>}<br/><br/>/*<br/> * Helper functions for managing events -- not part of the public interface.<br/> * Props to Dean Edwards' addEvent library for many of the ideas.<br/> */<br/>jQuery.event = {<br/><br/>	global: {},<br/><br/>	add: function( elem, types, handler, data, selector ) {<br/><br/>		var handleObjIn, eventHandle, tmp,<br/>			events, t, handleObj,<br/>			special, handlers, type, namespaces, origType,<br/>			elemData = dataPriv.get( elem );<br/><br/>		// Don't attach events to noData or text/comment nodes (but allow plain objects)<br/>		if ( !elemData ) {<br/>			return;<br/>		}<br/><br/>		// Caller can pass in an object of custom data in lieu of the handler<br/>		if ( handler.handler ) {<br/>			handleObjIn = handler;<br/>			handler = handleObjIn.handler;<br/>			selector = handleObjIn.selector;<br/>		}<br/><br/>		// Ensure that invalid selectors throw exceptions at attach time<br/>		// Evaluate against documentElement in case elem is a non-element node (e.g., document)<br/>		if ( selector ) {<br/>			jQuery.find.matchesSelector( documentElement, selector );<br/>		}<br/><br/>		// Make sure that the handler has a unique ID, used to find/remove it later<br/>		if ( !handler.guid ) {<br/>			handler.guid = jQuery.guid++;<br/>		}<br/><br/>		// Init the element's event structure and main handler, if this is the first<br/>		if ( !( events = elemData.events ) ) {<br/>			events = elemData.events = {};<br/>		}<br/>		if ( !( eventHandle = elemData.handle ) ) {<br/>			eventHandle = elemData.handle = function( e ) {<br/><br/>				// Discard the second event of a jQuery.event.trigger() and<br/>				// when an event is called after a page has unloaded<br/>				return typeof jQuery !== "undefined" &amp;&amp; jQuery.event.triggered !== e.type ?<br/>					jQuery.event.dispatch.apply( elem, arguments ) : undefined;<br/>			};<br/>		}<br/><br/>		// Handle multiple events separated by a space<br/>		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];<br/>		t = types.length;<br/>		while ( t-- ) {<br/>			tmp = rtypenamespace.exec( types[ t ] ) || [];<br/>			type = origType = tmp[ 1 ];<br/>			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();<br/><br/>			// There *must* be a type, no attaching namespace-only handlers<br/>			if ( !type ) {<br/>				continue;<br/>			}<br/><br/>			// If event changes its type, use the special event handlers for the changed type<br/>			special = jQuery.event.special[ type ] || {};<br/><br/>			// If selector defined, determine special event api type, otherwise given type<br/>			type = ( selector ? special.delegateType : special.bindType ) || type;<br/><br/>			// Update special based on newly reset type<br/>			special = jQuery.event.special[ type ] || {};<br/><br/>			// handleObj is passed to all event handlers<br/>			handleObj = jQuery.extend( {<br/>				type: type,<br/>				origType: origType,<br/>				data: data,<br/>				handler: handler,<br/>				guid: handler.guid,<br/>				selector: selector,<br/>				needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),<br/>				namespace: namespaces.join( "." )<br/>			}, handleObjIn );<br/><br/>			// Init the event handler queue if we're the first<br/>			if ( !( handlers = events[ type ] ) ) {<br/>				handlers = events[ type ] = [];<br/>				handlers.delegateCount = 0;<br/><br/>				// Only use addEventListener if the special events handler returns false<br/>				if ( !special.setup ||<br/>					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {<br/><br/>					if ( elem.addEventListener ) {<br/>						elem.addEventListener( type, eventHandle );<br/>					}<br/>				}<br/>			}<br/><br/>			if ( special.add ) {<br/>				special.add.call( elem, handleObj );<br/><br/>				if ( !handleObj.handler.guid ) {<br/>					handleObj.handler.guid = handler.guid;<br/>				}<br/>			}<br/><br/>			// Add to the element's handler list, delegates in front<br/>			if ( selector ) {<br/>				handlers.splice( handlers.delegateCount++, 0, handleObj );<br/>			} else {<br/>				handlers.push( handleObj );<br/>			}<br/><br/>			// Keep track of which events have ever been used, for event optimization<br/>			jQuery.event.global[ type ] = true;<br/>		}<br/><br/>	},<br/><br/>	// Detach an event or set of events from an element<br/>	remove: function( elem, types, handler, selector, mappedTypes ) {<br/><br/>		var j, origCount, tmp,<br/>			events, t, handleObj,<br/>			special, handlers, type, namespaces, origType,<br/>			elemData = dataPriv.hasData( elem ) &amp;&amp; dataPriv.get( elem );<br/><br/>		if ( !elemData || !( events = elemData.events ) ) {<br/>			return;<br/>		}<br/><br/>		// Once for each type.namespace in types; type may be omitted<br/>		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];<br/>		t = types.length;<br/>		while ( t-- ) {<br/>			tmp = rtypenamespace.exec( types[ t ] ) || [];<br/>			type = origType = tmp[ 1 ];<br/>			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();<br/><br/>			// Unbind all events (on this namespace, if provided) for the element<br/>			if ( !type ) {<br/>				for ( type in events ) {<br/>					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );<br/>				}<br/>				continue;<br/>			}<br/><br/>			special = jQuery.event.special[ type ] || {};<br/>			type = ( selector ? special.delegateType : special.bindType ) || type;<br/>			handlers = events[ type ] || [];<br/>			tmp = tmp[ 2 ] &amp;&amp;<br/>				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );<br/><br/>			// Remove matching events<br/>			origCount = j = handlers.length;<br/>			while ( j-- ) {<br/>				handleObj = handlers[ j ];<br/><br/>				if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;<br/>					( !handler || handler.guid === handleObj.guid ) &amp;&amp;<br/>					( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;<br/>					( !selector || selector === handleObj.selector ||<br/>						selector === "**" &amp;&amp; handleObj.selector ) ) {<br/>					handlers.splice( j, 1 );<br/><br/>					if ( handleObj.selector ) {<br/>						handlers.delegateCount--;<br/>					}<br/>					if ( special.remove ) {<br/>						special.remove.call( elem, handleObj );<br/>					}<br/>				}<br/>			}<br/><br/>			// Remove generic event handler if we removed something and no more handlers exist<br/>			// (avoids potential for endless recursion during removal of special event handlers)<br/>			if ( origCount &amp;&amp; !handlers.length ) {<br/>				if ( !special.teardown ||<br/>					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {<br/><br/>					jQuery.removeEvent( elem, type, elemData.handle );<br/>				}<br/><br/>				delete events[ type ];<br/>			}<br/>		}<br/><br/>		// Remove data and the expando if it's no longer used<br/>		if ( jQuery.isEmptyObject( events ) ) {<br/>			dataPriv.remove( elem, "handle events" );<br/>		}<br/>	},<br/><br/>	dispatch: function( nativeEvent ) {<br/><br/>		// Make a writable jQuery.Event from the native event object<br/>		var event = jQuery.event.fix( nativeEvent );<br/><br/>		var i, j, ret, matched, handleObj, handlerQueue,<br/>			args = new Array( arguments.length ),<br/>			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],<br/>			special = jQuery.event.special[ event.type ] || {};<br/><br/>		// Use the fix-ed jQuery.Event rather than the (read-only) native event<br/>		args[ 0 ] = event;<br/><br/>		for ( i = 1; i &lt; arguments.length; i++ ) {<br/>			args[ i ] = arguments[ i ];<br/>		}<br/><br/>		event.delegateTarget = this;<br/><br/>		// Call the preDispatch hook for the mapped type, and let it bail if desired<br/>		if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {<br/>			return;<br/>		}<br/><br/>		// Determine handlers<br/>		handlerQueue = jQuery.event.handlers.call( this, event, handlers );<br/><br/>		// Run delegates first; they may want to stop propagation beneath us<br/>		i = 0;<br/>		while ( ( matched = handlerQueue[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) {<br/>			event.currentTarget = matched.elem;<br/><br/>			j = 0;<br/>			while ( ( handleObj = matched.handlers[ j++ ] ) &amp;&amp;<br/>				!event.isImmediatePropagationStopped() ) {<br/><br/>				// Triggered event must either 1) have no namespace, or 2) have namespace(s)<br/>				// a subset or equal to those in the bound event (both can have no namespace).<br/>				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {<br/><br/>					event.handleObj = handleObj;<br/>					event.data = handleObj.data;<br/><br/>					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||<br/>						handleObj.handler ).apply( matched.elem, args );<br/><br/>					if ( ret !== undefined ) {<br/>						if ( ( event.result = ret ) === false ) {<br/>							event.preventDefault();<br/>							event.stopPropagation();<br/>						}<br/>					}<br/>				}<br/>			}<br/>		}<br/><br/>		// Call the postDispatch hook for the mapped type<br/>		if ( special.postDispatch ) {<br/>			special.postDispatch.call( this, event );<br/>		}<br/><br/>		return event.result;<br/>	},<br/><br/>	handlers: function( event, handlers ) {<br/>		var i, handleObj, sel, matchedHandlers, matchedSelectors,<br/>			handlerQueue = [],<br/>			delegateCount = handlers.delegateCount,<br/>			cur = event.target;<br/><br/>		// Find delegate handlers<br/>		if ( delegateCount &amp;&amp;<br/><br/>			// Support: IE &lt;=9<br/>			// Black-hole SVG &lt;use&gt; instance trees (trac-13180)<br/>			cur.nodeType &amp;&amp;<br/><br/>			// Support: Firefox &lt;=42<br/>			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)<br/>			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click<br/>			// Support: IE 11 only<br/>			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)<br/>			!( event.type === "click" &amp;&amp; event.button &gt;= 1 ) ) {<br/><br/>			for ( ; cur !== this; cur = cur.parentNode || this ) {<br/><br/>				// Don't check non-elements (#13208)<br/>				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)<br/>				if ( cur.nodeType === 1 &amp;&amp; !( event.type === "click" &amp;&amp; cur.disabled === true ) ) {<br/>					matchedHandlers = [];<br/>					matchedSelectors = {};<br/>					for ( i = 0; i &lt; delegateCount; i++ ) {<br/>						handleObj = handlers[ i ];<br/><br/>						// Don't conflict with Object.prototype properties (#13203)<br/>						sel = handleObj.selector + " ";<br/><br/>						if ( matchedSelectors[ sel ] === undefined ) {<br/>							matchedSelectors[ sel ] = handleObj.needsContext ?<br/>								jQuery( sel, this ).index( cur ) &gt; -1 :<br/>								jQuery.find( sel, this, null, [ cur ] ).length;<br/>						}<br/>						if ( matchedSelectors[ sel ] ) {<br/>							matchedHandlers.push( handleObj );<br/>						}<br/>					}<br/>					if ( matchedHandlers.length ) {<br/>						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );<br/>					}<br/>				}<br/>			}<br/>		}<br/><br/>		// Add the remaining (directly-bound) handlers<br/>		cur = this;<br/>		if ( delegateCount &lt; handlers.length ) {<br/>			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );<br/>		}<br/><br/>		return handlerQueue;<br/>	},<br/><br/>	addProp: function( name, hook ) {<br/>		Object.defineProperty( jQuery.Event.prototype, name, {<br/>			enumerable: true,<br/>			configurable: true,<br/><br/>			get: isFunction( hook ) ?<br/>				function() {<br/>					if ( this.originalEvent ) {<br/>							return hook( this.originalEvent );<br/>					}<br/>				} :<br/>				function() {<br/>					if ( this.originalEvent ) {<br/>							return this.originalEvent[ name ];<br/>					}<br/>				},<br/><br/>			set: function( value ) {<br/>				Object.defineProperty( this, name, {<br/>					enumerable: true,<br/>					configurable: true,<br/>					writable: true,<br/>					value: value<br/>				} );<br/>			}<br/>		} );<br/>	},<br/><br/>	fix: function( originalEvent ) {<br/>		return originalEvent[ jQuery.expando ] ?<br/>			originalEvent :<br/>			new jQuery.Event( originalEvent );<br/>	},<br/><br/>	special: {<br/>		load: {<br/><br/>			// Prevent triggered image.load events from bubbling to window.load<br/>			noBubble: true<br/>		},<br/>		focus: {<br/><br/>			// Fire native event if possible so blur/focus sequence is correct<br/>			trigger: function() {<br/>				if ( this !== safeActiveElement() &amp;&amp; this.focus ) {<br/>					this.focus();<br/>					return false;<br/>				}<br/>			},<br/>			delegateType: "focusin"<br/>		},<br/>		blur: {<br/>			trigger: function() {<br/>				if ( this === safeActiveElement() &amp;&amp; this.blur ) {<br/>					this.blur();<br/>					return false;<br/>				}<br/>			},<br/>			delegateType: "focusout"<br/>		},<br/>		click: {<br/><br/>			// For checkbox, fire native event so checked state will be right<br/>			trigger: function() {<br/>				if ( this.type === "checkbox" &amp;&amp; this.click &amp;&amp; nodeName( this, "input" ) ) {<br/>					this.click();<br/>					return false;<br/>				}<br/>			},<br/><br/>			// For cross-browser consistency, don't fire native .click() on links<br/>			_default: function( event ) {<br/>				return nodeName( event.target, "a" );<br/>			}<br/>		},<br/><br/>		beforeunload: {<br/>			postDispatch: function( event ) {<br/><br/>				// Support: Firefox 20+<br/>				// Firefox doesn't alert if the returnValue field is not set.<br/>				if ( event.result !== undefined &amp;&amp; event.originalEvent ) {<br/>					event.originalEvent.returnValue = event.result;<br/>				}<br/>			}<br/>		}<br/>	}<br/>};<br/><br/>jQuery.removeEvent = function( elem, type, handle ) {<br/><br/>	// This "if" is needed for plain objects<br/>	if ( elem.removeEventListener ) {<br/>		elem.removeEventListener( type, handle );<br/>	}<br/>};<br/><br/>jQuery.Event = function( src, props ) {<br/><br/>	// Allow instantiation without the 'new' keyword<br/>	if ( !( this instanceof jQuery.Event ) ) {<br/>		return new jQuery.Event( src, props );<br/>	}<br/><br/>	// Event object<br/>	if ( src &amp;&amp; src.type ) {<br/>		this.originalEvent = src;<br/>		this.type = src.type;<br/><br/>		// Events bubbling up the document may have been marked as prevented<br/>		// by a handler lower down the tree; reflect the correct value.<br/>		this.isDefaultPrevented = src.defaultPrevented ||<br/>				src.defaultPrevented === undefined &amp;&amp;<br/><br/>				// Support: Android &lt;=2.3 only<br/>				src.returnValue === false ?<br/>			returnTrue :<br/>			returnFalse;<br/><br/>		// Create target properties<br/>		// Support: Safari &lt;=6 - 7 only<br/>		// Target should not be a text node (#504, #13143)<br/>		this.target = ( src.target &amp;&amp; src.target.nodeType === 3 ) ?<br/>			src.target.parentNode :<br/>			src.target;<br/><br/>		this.currentTarget = src.currentTarget;<br/>		this.relatedTarget = src.relatedTarget;<br/><br/>	// Event type<br/>	} else {<br/>		this.type = src;<br/>	}<br/><br/>	// Put explicitly provided properties onto the event object<br/>	if ( props ) {<br/>		jQuery.extend( this, props );<br/>	}<br/><br/>	// Create a timestamp if incoming event doesn't have one<br/>	this.timeStamp = src &amp;&amp; src.timeStamp || Date.now();<br/><br/>	// Mark it as fixed<br/>	this[ jQuery.expando ] = true;<br/>};<br/><br/>// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding<br/>// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html<br/>jQuery.Event.prototype = {<br/>	constructor: jQuery.Event,<br/>	isDefaultPrevented: returnFalse,<br/>	isPropagationStopped: returnFalse,<br/>	isImmediatePropagationStopped: returnFalse,<br/>	isSimulated: false,<br/><br/>	preventDefault: function() {<br/>		var e = this.originalEvent;<br/><br/>		this.isDefaultPrevented = returnTrue;<br/><br/>		if ( e &amp;&amp; !this.isSimulated ) {<br/>			e.preventDefault();<br/>		}<br/>	},<br/>	stopPropagation: function() {<br/>		var e = this.originalEvent;<br/><br/>		this.isPropagationStopped = returnTrue;<br/><br/>		if ( e &amp;&amp; !this.isSimulated ) {<br/>			e.stopPropagation();<br/>		}<br/>	},<br/>	stopImmediatePropagation: function() {<br/>		var e = this.originalEvent;<br/><br/>		this.isImmediatePropagationStopped = returnTrue;<br/><br/>		if ( e &amp;&amp; !this.isSimulated ) {<br/>			e.stopImmediatePropagation();<br/>		}<br/><br/>		this.stopPropagation();<br/>	}<br/>};<br/><br/>// Includes all common event props including KeyEvent and MouseEvent specific props<br/>jQuery.each( {<br/>	altKey: true,<br/>	bubbles: true,<br/>	cancelable: true,<br/>	changedTouches: true,<br/>	ctrlKey: true,<br/>	detail: true,<br/>	eventPhase: true,<br/>	metaKey: true,<br/>	pageX: true,<br/>	pageY: true,<br/>	shiftKey: true,<br/>	view: true,<br/>	"char": true,<br/>	charCode: true,<br/>	key: true,<br/>	keyCode: true,<br/>	button: true,<br/>	buttons: true,<br/>	clientX: true,<br/>	clientY: true,<br/>	offsetX: true,<br/>	offsetY: true,<br/>	pointerId: true,<br/>	pointerType: true,<br/>	screenX: true,<br/>	screenY: true,<br/>	targetTouches: true,<br/>	toElement: true,<br/>	touches: true,<br/><br/>	which: function( event ) {<br/>		var button = event.button;<br/><br/>		// Add which for key events<br/>		if ( event.which == null &amp;&amp; rkeyEvent.test( event.type ) ) {<br/>			return event.charCode != null ? event.charCode : event.keyCode;<br/>		}<br/><br/>		// Add which for click: 1 === left; 2 === middle; 3 === right<br/>		if ( !event.which &amp;&amp; button !== undefined &amp;&amp; rmouseEvent.test( event.type ) ) {<br/>			if ( button &amp; 1 ) {<br/>				return 1;<br/>			}<br/><br/>			if ( button &amp; 2 ) {<br/>				return 3;<br/>			}<br/><br/>			if ( button &amp; 4 ) {<br/>				return 2;<br/>			}<br/><br/>			return 0;<br/>		}<br/><br/>		return event.which;<br/>	}<br/>}, jQuery.event.addProp );<br/><br/>// Create mouseenter/leave events using mouseover/out and event-time checks<br/>// so that event delegation works in jQuery.<br/>// Do the same for pointerenter/pointerleave and pointerover/pointerout<br/>//<br/>// Support: Safari 7 only<br/>// Safari sends mouseenter too often; see:<br/>// https://bugs.chromium.org/p/chromium/issues/detail?id=470258<br/>// for the description of the bug (it existed in older Chrome versions as well).<br/>jQuery.each( {<br/>	mouseenter: "mouseover",<br/>	mouseleave: "mouseout",<br/>	pointerenter: "pointerover",<br/>	pointerleave: "pointerout"<br/>}, function( orig, fix ) {<br/>	jQuery.event.special[ orig ] = {<br/>		delegateType: fix,<br/>		bindType: fix,<br/><br/>		handle: function( event ) {<br/>			var ret,<br/>				target = this,<br/>				related = event.relatedTarget,<br/>				handleObj = event.handleObj;<br/><br/>			// For mouseenter/leave call the handler if related is outside the target.<br/>			// NB: No relatedTarget if the mouse left/entered the browser window<br/>			if ( !related || ( related !== target &amp;&amp; !jQuery.contains( target, related ) ) ) {<br/>				event.type = handleObj.origType;<br/>				ret = handleObj.handler.apply( this, arguments );<br/>				event.type = fix;<br/>			}<br/>			return ret;<br/>		}<br/>	};<br/>} );<br/><br/>jQuery.fn.extend( {<br/><br/>	on: function( types, selector, data, fn ) {<br/>		return on( this, types, selector, data, fn );<br/>	},<br/>	one: function( types, selector, data, fn ) {<br/>		return on( this, types, selector, data, fn, 1 );<br/>	},<br/>	off: function( types, selector, fn ) {<br/>		var handleObj, type;<br/>		if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {<br/><br/>			// ( event )  dispatched jQuery.Event<br/>			handleObj = types.handleObj;<br/>			jQuery( types.delegateTarget ).off(<br/>				handleObj.namespace ?<br/>					handleObj.origType + "." + handleObj.namespace :<br/>					handleObj.origType,<br/>				handleObj.selector,<br/>				handleObj.handler<br/>			);<br/>			return this;<br/>		}<br/>		if ( typeof types === "object" ) {<br/><br/>			// ( types-object [, selector] )<br/>			for ( type in types ) {<br/>				this.off( type, selector, types[ type ] );<br/>			}<br/>			return this;<br/>		}<br/>		if ( selector === false || typeof selector === "function" ) {<br/><br/>			// ( types [, fn] )<br/>			fn = selector;<br/>			selector = undefined;<br/>		}<br/>		if ( fn === false ) {<br/>			fn = returnFalse;<br/>		}<br/>		return this.each( function() {<br/>			jQuery.event.remove( this, types, fn, selector );<br/>		} );<br/>	}<br/>} );<br/><br/><br/>var<br/><br/>	/* eslint-disable max-len */<br/><br/>	// See https://github.com/eslint/eslint/issues/3229<br/>	rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0&gt;\x20\t\r\n\f]*)[^&gt;]*)\/&gt;/gi,<br/><br/>	/* eslint-enable */<br/><br/>	// Support: IE &lt;=10 - 11, Edge 12 - 13 only<br/>	// In IE/Edge using regex groups here causes severe slowdowns.<br/>	// See https://connect.microsoft.com/IE/feedback/details/1736512/<br/>	rnoInnerhtml = /&lt;script|&lt;style|&lt;link/i,<br/><br/>	// checked="checked" or checked<br/>	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,<br/>	rcleanScript = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g;<br/><br/>// Prefer a tbody over its parent table for containing new rows<br/>function manipulationTarget( elem, content ) {<br/>	if ( nodeName( elem, "table" ) &amp;&amp;<br/>		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {<br/><br/>		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;<br/>	}<br/><br/>	return elem;<br/>}<br/><br/>// Replace/restore the type attribute of script elements for safe DOM manipulation<br/>function disableScript( elem ) {<br/>	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;<br/>	return elem;<br/>}<br/>function restoreScript( elem ) {<br/>	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {<br/>		elem.type = elem.type.slice( 5 );<br/>	} else {<br/>		elem.removeAttribute( "type" );<br/>	}<br/><br/>	return elem;<br/>}<br/><br/>function cloneCopyEvent( src, dest ) {<br/>	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;<br/><br/>	if ( dest.nodeType !== 1 ) {<br/>		return;<br/>	}<br/><br/>	// 1. Copy private data: events, handlers, etc.<br/>	if ( dataPriv.hasData( src ) ) {<br/>		pdataOld = dataPriv.access( src );<br/>		pdataCur = dataPriv.set( dest, pdataOld );<br/>		events = pdataOld.events;<br/><br/>		if ( events ) {<br/>			delete pdataCur.handle;<br/>			pdataCur.events = {};<br/><br/>			for ( type in events ) {<br/>				for ( i = 0, l = events[ type ].length; i &lt; l; i++ ) {<br/>					jQuery.event.add( dest, type, events[ type ][ i ] );<br/>				}<br/>			}<br/>		}<br/>	}<br/><br/>	// 2. Copy user data<br/>	if ( dataUser.hasData( src ) ) {<br/>		udataOld = dataUser.access( src );<br/>		udataCur = jQuery.extend( {}, udataOld );<br/><br/>		dataUser.set( dest, udataCur );<br/>	}<br/>}<br/><br/>// Fix IE bugs, see support tests<br/>function fixInput( src, dest ) {<br/>	var nodeName = dest.nodeName.toLowerCase();<br/><br/>	// Fails to persist the checked state of a cloned checkbox or radio button.<br/>	if ( nodeName === "input" &amp;&amp; rcheckableType.test( src.type ) ) {<br/>		dest.checked = src.checked;<br/><br/>	// Fails to return the selected option to the default selected state when cloning options<br/>	} else if ( nodeName === "input" || nodeName === "textarea" ) {<br/>		dest.defaultValue = src.defaultValue;<br/>	}<br/>}<br/><br/>function domManip( collection, args, callback, ignored ) {<br/><br/>	// Flatten any nested arrays<br/>	args = concat.apply( [], args );<br/><br/>	var fragment, first, scripts, hasScripts, node, doc,<br/>		i = 0,<br/>		l = collection.length,<br/>		iNoClone = l - 1,<br/>		value = args[ 0 ],<br/>		valueIsFunction = isFunction( value );<br/><br/>	// We can't cloneNode fragments that contain checked, in WebKit<br/>	if ( valueIsFunction ||<br/>			( l &gt; 1 &amp;&amp; typeof value === "string" &amp;&amp;<br/>				!support.checkClone &amp;&amp; rchecked.test( value ) ) ) {<br/>		return collection.each( function( index ) {<br/>			var self = collection.eq( index );<br/>			if ( valueIsFunction ) {<br/>				args[ 0 ] = value.call( this, index, self.html() );<br/>			}<br/>			domManip( self, args, callback, ignored );<br/>		} );<br/>	}<br/><br/>	if ( l ) {<br/>		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );<br/>		first = fragment.firstChild;<br/><br/>		if ( fragment.childNodes.length === 1 ) {<br/>			fragment = first;<br/>		}<br/><br/>		// Require either new content or an interest in ignored elements to invoke the callback<br/>		if ( first || ignored ) {<br/>			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );<br/>			hasScripts = scripts.length;<br/><br/>			// Use the original fragment for the last item<br/>			// instead of the first because it can end up<br/>			// being emptied incorrectly in certain situations (#8070).<br/>			for ( ; i &lt; l; i++ ) {<br/>				node = fragment;<br/><br/>				if ( i !== iNoClone ) {<br/>					node = jQuery.clone( node, true, true );<br/><br/>					// Keep references to cloned scripts for later restoration<br/>					if ( hasScripts ) {<br/><br/>						// Support: Android &lt;=4.0 only, PhantomJS 1 only<br/>						// push.apply(_, arraylike) throws on ancient WebKit<br/>						jQuery.merge( scripts, getAll( node, "script" ) );<br/>					}<br/>				}<br/><br/>				callback.call( collection[ i ], node, i );<br/>			}<br/><br/>			if ( hasScripts ) {<br/>				doc = scripts[ scripts.length - 1 ].ownerDocument;<br/><br/>				// Reenable scripts<br/>				jQuery.map( scripts, restoreScript );<br/><br/>				// Evaluate executable scripts on first document insertion<br/>				for ( i = 0; i &lt; hasScripts; i++ ) {<br/>					node = scripts[ i ];<br/>					if ( rscriptType.test( node.type || "" ) &amp;&amp;<br/>						!dataPriv.access( node, "globalEval" ) &amp;&amp;<br/>						jQuery.contains( doc, node ) ) {<br/><br/>						if ( node.src &amp;&amp; ( node.type || "" ).toLowerCase()  !== "module" ) {<br/><br/>							// Optional AJAX dependency, but won't run scripts if not present<br/>							if ( jQuery._evalUrl ) {<br/>								jQuery._evalUrl( node.src );<br/>							}<br/>						} else {<br/>							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );<br/>						}<br/>					}<br/>				}<br/>			}<br/>		}<br/>	}<br/><br/>	return collection;<br/>}<br/><br/>function remove( elem, selector, keepData ) {<br/>	var node,<br/>		nodes = selector ? jQuery.filter( selector, elem ) : elem,<br/>		i = 0;<br/><br/>	for ( ; ( node = nodes[ i ] ) != null; i++ ) {<br/>		if ( !keepData &amp;&amp; node.nodeType === 1 ) {<br/>			jQuery.cleanData( getAll( node ) );<br/>		}<br/><br/>		if ( node.parentNode ) {<br/>			if ( keepData &amp;&amp; jQuery.contains( node.ownerDocument, node ) ) {<br/>				setGlobalEval( getAll( node, "script" ) );<br/>			}<br/>			node.parentNode.removeChild( node );<br/>		}<br/>	}<br/><br/>	return elem;<br/>}<br/><br/>jQuery.extend( {<br/>	htmlPrefilter: function( html ) {<br/>		return html.replace( rxhtmlTag, "&lt;$1&gt;&lt;/$2&gt;" );<br/>	},<br/><br/>	clone: function( elem, dataAndEvents, deepDataAndEvents ) {<br/>		var i, l, srcElements, destElements,<br/>			clone = elem.cloneNode( true ),<br/>			inPage = jQuery.contains( elem.ownerDocument, elem );<br/><br/>		// Fix IE cloning issues<br/>		if ( !support.noCloneChecked &amp;&amp; ( elem.nodeType === 1 || elem.nodeType === 11 ) &amp;&amp;<br/>				!jQuery.isXMLDoc( elem ) ) {<br/><br/>			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2<br/>			destElements = getAll( clone );<br/>			srcElements = getAll( elem );<br/><br/>			for ( i = 0, l = srcElements.length; i &lt; l; i++ ) {<br/>				fixInput( srcElements[ i ], destElements[ i ] );<br/>			}<br/>		}<br/><br/>		// Copy the events from the original to the clone<br/>		if ( dataAndEvents ) {<br/>			if ( deepDataAndEvents ) {<br/>				srcElements = srcElements || getAll( elem );<br/>				destElements = destElements || getAll( clone );<br/><br/>				for ( i = 0, l = srcElements.length; i &lt; l; i++ ) {<br/>					cloneCopyEvent( srcElements[ i ], destElements[ i ] );<br/>				}<br/>			} else {<br/>				cloneCopyEvent( elem, clone );<br/>			}<br/>		}<br/><br/>		// Preserve script evaluation history<br/>		destElements = getAll( clone, "script" );<br/>		if ( destElements.length &gt; 0 ) {<br/>			setGlobalEval( destElements, !inPage &amp;&amp; getAll( elem, "script" ) );<br/>		}<br/><br/>		// Return the cloned set<br/>		return clone;<br/>	},<br/><br/>	cleanData: function( elems ) {<br/>		var data, elem, type,<br/>			special = jQuery.event.special,<br/>			i = 0;<br/><br/>		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {<br/>			if ( acceptData( elem ) ) {<br/>				if ( ( data = elem[ dataPriv.expando ] ) ) {<br/>					if ( data.events ) {<br/>						for ( type in data.events ) {<br/>							if ( special[ type ] ) {<br/>								jQuery.event.remove( elem, type );<br/><br/>							// This is a shortcut to avoid jQuery.event.remove's overhead<br/>							} else {<br/>								jQuery.removeEvent( elem, type, data.handle );<br/>							}<br/>						}<br/>					}<br/><br/>					// Support: Chrome &lt;=35 - 45+<br/>					// Assign undefined instead of using delete, see Data#remove<br/>					elem[ dataPriv.expando ] = undefined;<br/>				}<br/>				if ( elem[ dataUser.expando ] ) {<br/><br/>					// Support: Chrome &lt;=35 - 45+<br/>					// Assign undefined instead of using delete, see Data#remove<br/>					elem[ dataUser.expando ] = undefined;<br/>				}<br/>			}<br/>		}<br/>	}<br/>} );<br/><br/>jQuery.fn.extend( {<br/>	detach: function( selector ) {<br/>		return remove( this, selector, true );<br/>	},<br/><br/>	remove: function( selector ) {<br/>		return remove( this, selector );<br/>	},<br/><br/>	text: function( value ) {<br/>		return access( this, function( value ) {<br/>			return value === undefined ?<br/>				jQuery.text( this ) :<br/>				this.empty().each( function() {<br/>					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {<br/>						this.textContent = value;<br/>					}<br/>				} );<br/>		}, null, value, arguments.length );<br/>	},<br/><br/>	append: function() {<br/>		return domManip( this, arguments, function( elem ) {<br/>			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {<br/>				var target = manipulationTarget( this, elem );<br/>				target.appendChild( elem );<br/>			}<br/>		} );<br/>	},<br/><br/>	prepend: function() {<br/>		return domManip( this, arguments, function( elem ) {<br/>			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {<br/>				var target = manipulationTarget( this, elem );<br/>				target.insertBefore( elem, target.firstChild );<br/>			}<br/>		} );<br/>	},<br/><br/>	before: function() {<br/>		return domManip( this, arguments, function( elem ) {<br/>			if ( this.parentNode ) {<br/>				this.parentNode.insertBefore( elem, this );<br/>			}<br/>		} );<br/>	},<br/><br/>	after: function() {<br/>		return domManip( this, arguments, function( elem ) {<br/>			if ( this.parentNode ) {<br/>				this.parentNode.insertBefore( elem, this.nextSibling );<br/>			}<br/>		} );<br/>	},<br/><br/>	empty: function() {<br/>		var elem,<br/>			i = 0;<br/><br/>		for ( ; ( elem = this[ i ] ) != null; i++ ) {<br/>			if ( elem.nodeType === 1 ) {<br/><br/>				// Prevent memory leaks<br/>				jQuery.cleanData( getAll( elem, false ) );<br/><br/>				// Remove any remaining nodes<br/>				elem.textContent = "";<br/>			}<br/>		}<br/><br/>		return this;<br/>	},<br/><br/>	clone: function( dataAndEvents, deepDataAndEvents ) {<br/>		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;<br/>		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;<br/><br/>		return this.map( function() {<br/>			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );<br/>		} );<br/>	},<br/><br/>	html: function( value ) {<br/>		return access( this, function( value ) {<br/>			var elem = this[ 0 ] || {},<br/>				i = 0,<br/>				l = this.length;<br/><br/>			if ( value === undefined &amp;&amp; elem.nodeType === 1 ) {<br/>				return elem.innerHTML;<br/>			}<br/><br/>			// See if we can take a shortcut and just use innerHTML<br/>			if ( typeof value === "string" &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;<br/>				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {<br/><br/>				value = jQuery.htmlPrefilter( value );<br/><br/>				try {<br/>					for ( ; i &lt; l; i++ ) {<br/>						elem = this[ i ] || {};<br/><br/>						// Remove element nodes and prevent memory leaks<br/>						if ( elem.nodeType === 1 ) {<br/>							jQuery.cleanData( getAll( elem, false ) );<br/>							elem.innerHTML = value;<br/>						}<br/>					}<br/><br/>					elem = 0;<br/><br/>				// If using innerHTML throws an exception, use the fallback method<br/>				} catch ( e ) {}<br/>			}<br/><br/>			if ( elem ) {<br/>				this.empty().append( value );<br/>			}<br/>		}, null, value, arguments.length );<br/>	},<br/><br/>	replaceWith: function() {<br/>		var ignored = [];<br/><br/>		// Make the changes, replacing each non-ignored context element with the new content<br/>		return domManip( this, arguments, function( elem ) {<br/>			var parent = this.parentNode;<br/><br/>			if ( jQuery.inArray( this, ignored ) &lt; 0 ) {<br/>				jQuery.cleanData( getAll( this ) );<br/>				if ( parent ) {<br/>					parent.replaceChild( elem, this );<br/>				}<br/>			}<br/><br/>		// Force callback invocation<br/>		}, ignored );<br/>	}<br/>} );<br/><br/>jQuery.each( {<br/>	appendTo: "append",<br/>	prependTo: "prepend",<br/>	insertBefore: "before",<br/>	insertAfter: "after",<br/>	replaceAll: "replaceWith"<br/>}, function( name, original ) {<br/>	jQuery.fn[ name ] = function( selector ) {<br/>		var elems,<br/>			ret = [],<br/>			insert = jQuery( selector ),<br/>			last = insert.length - 1,<br/>			i = 0;<br/><br/>		for ( ; i &lt;= last; i++ ) {<br/>			elems = i === last ? this : this.clone( true );<br/>			jQuery( insert[ i ] )[ original ]( elems );<br/><br/>			// Support: Android &lt;=4.0 only, PhantomJS 1 only<br/>			// .get() because push.apply(_, arraylike) throws on ancient WebKit<br/>			push.apply( ret, elems.get() );<br/>		}<br/><br/>		return this.pushStack( ret );<br/>	};<br/>} );<br/>var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );<br/><br/>var getStyles = function( elem ) {<br/><br/>		// Support: IE &lt;=11 only, Firefox &lt;=30 (#15098, #14150)<br/>		// IE throws on elements created in popups<br/>		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"<br/>		var view = elem.ownerDocument.defaultView;<br/><br/>		if ( !view || !view.opener ) {<br/>			view = window;<br/>		}<br/><br/>		return view.getComputedStyle( elem );<br/>	};<br/><br/>var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );<br/><br/><br/><br/>( function() {<br/><br/>	// Executing both pixelPosition &amp; boxSizingReliable tests require only one layout<br/>	// so they're executed at the same time to save the second computation.<br/>	function computeStyleTests() {<br/><br/>		// This is a singleton, we need to execute it only once<br/>		if ( !div ) {<br/>			return;<br/>		}<br/><br/>		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +<br/>			"margin-top:1px;padding:0;border:0";<br/>		div.style.cssText =<br/>			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +<br/>			"margin:auto;border:1px;padding:1px;" +<br/>			"width:60%;top:1%";<br/>		documentElement.appendChild( container ).appendChild( div );<br/><br/>		var divStyle = window.getComputedStyle( div );<br/>		pixelPositionVal = divStyle.top !== "1%";<br/><br/>		// Support: Android 4.0 - 4.3 only, Firefox &lt;=3 - 44<br/>		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;<br/><br/>		// Support: Android 4.0 - 4.3 only, Safari &lt;=9.1 - 10.1, iOS &lt;=7.0 - 9.3<br/>		// Some styles come back with percentage values, even though they shouldn't<br/>		div.style.right = "60%";<br/>		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;<br/><br/>		// Support: IE 9 - 11 only<br/>		// Detect misreporting of content dimensions for box-sizing:border-box elements<br/>		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;<br/><br/>		// Support: IE 9 only<br/>		// Detect overflow:scroll screwiness (gh-3699)<br/>		div.style.position = "absolute";<br/>		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";<br/><br/>		documentElement.removeChild( container );<br/><br/>		// Nullify the div so it wouldn't be stored in the memory and<br/>		// it will also be a sign that checks already performed<br/>		div = null;<br/>	}<br/><br/>	function roundPixelMeasures( measure ) {<br/>		return Math.round( parseFloat( measure ) );<br/>	}<br/><br/>	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,<br/>		reliableMarginLeftVal,<br/>		container = document.createElement( "div" ),<br/>		div = document.createElement( "div" );<br/><br/>	// Finish early in limited (non-browser) environments<br/>	if ( !div.style ) {<br/>		return;<br/>	}<br/><br/>	// Support: IE &lt;=9 - 11 only<br/>	// Style of cloned element affects source element cloned (#8908)<br/>	div.style.backgroundClip = "content-box";<br/>	div.cloneNode( true ).style.backgroundClip = "";<br/>	support.clearCloneStyle = div.style.backgroundClip === "content-box";<br/><br/>	jQuery.extend( support, {<br/>		boxSizingReliable: function() {<br/>			computeStyleTests();<br/>			return boxSizingReliableVal;<br/>		},<br/>		pixelBoxStyles: function() {<br/>			computeStyleTests();<br/>			return pixelBoxStylesVal;<br/>		},<br/>		pixelPosition: function() {<br/>			computeStyleTests();<br/>			return pixelPositionVal;<br/>		},<br/>		reliableMarginLeft: function() {<br/>			computeStyleTests();<br/>			return reliableMarginLeftVal;<br/>		},<br/>		scrollboxSize: function() {<br/>			computeStyleTests();<br/>			return scrollboxSizeVal;<br/>		}<br/>	} );<br/>} )();<br/><br/><br/>function curCSS( elem, name, computed ) {<br/>	var width, minWidth, maxWidth, ret,<br/><br/>		// Support: Firefox 51+<br/>		// Retrieving style before computed somehow<br/>		// fixes an issue with getting wrong values<br/>		// on detached elements<br/>		style = elem.style;<br/><br/>	computed = computed || getStyles( elem );<br/><br/>	// getPropertyValue is needed for:<br/>	//   .css('filter') (IE 9 only, #12537)<br/>	//   .css('--customProperty) (#3144)<br/>	if ( computed ) {<br/>		ret = computed.getPropertyValue( name ) || computed[ name ];<br/><br/>		if ( ret === "" &amp;&amp; !jQuery.contains( elem.ownerDocument, elem ) ) {<br/>			ret = jQuery.style( elem, name );<br/>		}<br/><br/>		// A tribute to the "awesome hack by Dean Edwards"<br/>		// Android Browser returns percentage for some values,<br/>		// but width seems to be reliably pixels.<br/>		// This is against the CSSOM draft spec:<br/>		// https://drafts.csswg.org/cssom/#resolved-values<br/>		if ( !support.pixelBoxStyles() &amp;&amp; rnumnonpx.test( ret ) &amp;&amp; rboxStyle.test( name ) ) {<br/><br/>			// Remember the original values<br/>			width = style.width;<br/>			minWidth = style.minWidth;<br/>			maxWidth = style.maxWidth;<br/><br/>			// Put in the new values to get a computed value out<br/>			style.minWidth = style.maxWidth = style.width = ret;<br/>			ret = computed.width;<br/><br/>			// Revert the changed values<br/>			style.width = width;<br/>			style.minWidth = minWidth;<br/>			style.maxWidth = maxWidth;<br/>		}<br/>	}<br/><br/>	return ret !== undefined ?<br/><br/>		// Support: IE &lt;=9 - 11 only<br/>		// IE returns zIndex value as an integer.<br/>		ret + "" :<br/>		ret;<br/>}<br/><br/><br/>function addGetHookIf( conditionFn, hookFn ) {<br/><br/>	// Define the hook, we'll check on the first run if it's really needed.<br/>	return {<br/>		get: function() {<br/>			if ( conditionFn() ) {<br/><br/>				// Hook not needed (or it's not possible to use it due<br/>				// to missing dependency), remove it.<br/>				delete this.get;<br/>				return;<br/>			}<br/><br/>			// Hook needed; redefine it so that the support test is not executed again.<br/>			return ( this.get = hookFn ).apply( this, arguments );<br/>		}<br/>	};<br/>}<br/><br/><br/>var<br/><br/>	// Swappable if display is none or starts with table<br/>	// except "table", "table-cell", or "table-caption"<br/>	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display<br/>	rdisplayswap = /^(none|table(?!-c[ea]).+)/,<br/>	rcustomProp = /^--/,<br/>	cssShow = { position: "absolute", visibility: "hidden", display: "block" },<br/>	cssNormalTransform = {<br/>		letterSpacing: "0",<br/>		fontWeight: "400"<br/>	},<br/><br/>	cssPrefixes = [ "Webkit", "Moz", "ms" ],<br/>	emptyStyle = document.createElement( "div" ).style;<br/><br/>// Return a css property mapped to a potentially vendor prefixed property<br/>function vendorPropName( name ) {<br/><br/>	// Shortcut for names that are not vendor prefixed<br/>	if ( name in emptyStyle ) {<br/>		return name;<br/>	}<br/><br/>	// Check for vendor prefixed names<br/>	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),<br/>		i = cssPrefixes.length;<br/><br/>	while ( i-- ) {<br/>		name = cssPrefixes[ i ] + capName;<br/>		if ( name in emptyStyle ) {<br/>			return name;<br/>		}<br/>	}<br/>}<br/><br/>// Return a property mapped along what jQuery.cssProps suggests or to<br/>// a vendor prefixed property.<br/>function finalPropName( name ) {<br/>	var ret = jQuery.cssProps[ name ];<br/>	if ( !ret ) {<br/>		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;<br/>	}<br/>	return ret;<br/>}<br/><br/>function setPositiveNumber( elem, value, subtract ) {<br/><br/>	// Any relative (+/-) values have already been<br/>	// normalized at this point<br/>	var matches = rcssNum.exec( value );<br/>	return matches ?<br/><br/>		// Guard against undefined "subtract", e.g., when used as in cssHooks<br/>		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :<br/>		value;<br/>}<br/><br/>function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {<br/>	var i = dimension === "width" ? 1 : 0,<br/>		extra = 0,<br/>		delta = 0;<br/><br/>	// Adjustment may not be necessary<br/>	if ( box === ( isBorderBox ? "border" : "content" ) ) {<br/>		return 0;<br/>	}<br/><br/>	for ( ; i &lt; 4; i += 2 ) {<br/><br/>		// Both box models exclude margin<br/>		if ( box === "margin" ) {<br/>			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );<br/>		}<br/><br/>		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"<br/>		if ( !isBorderBox ) {<br/><br/>			// Add padding<br/>			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );<br/><br/>			// For "border" or "margin", add border<br/>			if ( box !== "padding" ) {<br/>				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );<br/><br/>			// But still keep track of it otherwise<br/>			} else {<br/>				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );<br/>			}<br/><br/>		// If we get here with a border-box (content + padding + border), we're seeking "content" or<br/>		// "padding" or "margin"<br/>		} else {<br/><br/>			// For "content", subtract padding<br/>			if ( box === "content" ) {<br/>				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );<br/>			}<br/><br/>			// For "content" or "padding", subtract border<br/>			if ( box !== "margin" ) {<br/>				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );<br/>			}<br/>		}<br/>	}<br/><br/>	// Account for positive content-box scroll gutter when requested by providing computedVal<br/>	if ( !isBorderBox &amp;&amp; computedVal &gt;= 0 ) {<br/><br/>		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border<br/>		// Assuming integer scroll gutter, subtract the rest and round down<br/>		delta += Math.max( 0, Math.ceil(<br/>			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -<br/>			computedVal -<br/>			delta -<br/>			extra -<br/>			0.5<br/>		) );<br/>	}<br/><br/>	return delta;<br/>}<br/><br/>function getWidthOrHeight( elem, dimension, extra ) {<br/><br/>	// Start with computed style<br/>	var styles = getStyles( elem ),<br/>		val = curCSS( elem, dimension, styles ),<br/>		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",<br/>		valueIsBorderBox = isBorderBox;<br/><br/>	// Support: Firefox &lt;=54<br/>	// Return a confounding non-pixel value or feign ignorance, as appropriate.<br/>	if ( rnumnonpx.test( val ) ) {<br/>		if ( !extra ) {<br/>			return val;<br/>		}<br/>		val = "auto";<br/>	}<br/><br/>	// Check for style in case a browser which returns unreliable values<br/>	// for getComputedStyle silently falls back to the reliable elem.style<br/>	valueIsBorderBox = valueIsBorderBox &amp;&amp;<br/>		( support.boxSizingReliable() || val === elem.style[ dimension ] );<br/><br/>	// Fall back to offsetWidth/offsetHeight when value is "auto"<br/>	// This happens for inline elements with no explicit setting (gh-3571)<br/>	// Support: Android &lt;=4.1 - 4.3 only<br/>	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)<br/>	if ( val === "auto" ||<br/>		!parseFloat( val ) &amp;&amp; jQuery.css( elem, "display", false, styles ) === "inline" ) {<br/><br/>		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];<br/><br/>		// offsetWidth/offsetHeight provide border-box values<br/>		valueIsBorderBox = true;<br/>	}<br/><br/>	// Normalize "" and auto<br/>	val = parseFloat( val ) || 0;<br/><br/>	// Adjust for the element's box model<br/>	return ( val +<br/>		boxModelAdjustment(<br/>			elem,<br/>			dimension,<br/>			extra || ( isBorderBox ? "border" : "content" ),<br/>			valueIsBorderBox,<br/>			styles,<br/><br/>			// Provide the current computed size to request scroll gutter calculation (gh-3589)<br/>			val<br/>		)<br/>	) + "px";<br/>}<br/><br/>jQuery.extend( {<br/><br/>	// Add in style property hooks for overriding the default<br/>	// behavior of getting and setting a style property<br/>	cssHooks: {<br/>		opacity: {<br/>			get: function( elem, computed ) {<br/>				if ( computed ) {<br/><br/>					// We should always get a number back from opacity<br/>					var ret = curCSS( elem, "opacity" );<br/>					return ret === "" ? "1" : ret;<br/>				}<br/>			}<br/>		}<br/>	},<br/><br/>	// Don't automatically add "px" to these possibly-unitless properties<br/>	cssNumber: {<br/>		"animationIterationCount": true,<br/>		"columnCount": true,<br/>		"fillOpacity": true,<br/>		"flexGrow": true,<br/>		"flexShrink": true,<br/>		"fontWeight": true,<br/>		"lineHeight": true,<br/>		"opacity": true,<br/>		"order": true,<br/>		"orphans": true,<br/>		"widows": true,<br/>		"zIndex": true,<br/>		"zoom": true<br/>	},<br/><br/>	// Add in properties whose names you wish to fix before<br/>	// setting or getting the value<br/>	cssProps: {},<br/><br/>	// Get and set the style property on a DOM Node<br/>	style: function( elem, name, value, extra ) {<br/><br/>		// Don't set styles on text and comment nodes<br/>		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {<br/>			return;<br/>		}<br/><br/>		// Make sure that we're working with the right name<br/>		var ret, type, hooks,<br/>			origName = camelCase( name ),<br/>			isCustomProp = rcustomProp.test( name ),<br/>			style = elem.style;<br/><br/>		// Make sure that we're working with the right name. We don't<br/>		// want to query the value if it is a CSS custom property<br/>		// since they are user-defined.<br/>		if ( !isCustomProp ) {<br/>			name = finalPropName( origName );<br/>		}<br/><br/>		// Gets hook for the prefixed version, then unprefixed version<br/>		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];<br/><br/>		// Check if we're setting a value<br/>		if ( value !== undefined ) {<br/>			type = typeof value;<br/><br/>			// Convert "+=" or "-=" to relative numbers (#7345)<br/>			if ( type === "string" &amp;&amp; ( ret = rcssNum.exec( value ) ) &amp;&amp; ret[ 1 ] ) {<br/>				value = adjustCSS( elem, name, ret );<br/><br/>				// Fixes bug #9237<br/>				type = "number";<br/>			}<br/><br/>			// Make sure that null and NaN values aren't set (#7116)<br/>			if ( value == null || value !== value ) {<br/>				return;<br/>			}<br/><br/>			// If a number was passed in, add the unit (except for certain CSS properties)<br/>			if ( type === "number" ) {<br/>				value += ret &amp;&amp; ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );<br/>			}<br/><br/>			// background-* props affect original clone's values<br/>			if ( !support.clearCloneStyle &amp;&amp; value === "" &amp;&amp; name.indexOf( "background" ) === 0 ) {<br/>				style[ name ] = "inherit";<br/>			}<br/><br/>			// If a hook was provided, use that value, otherwise just set the specified value<br/>			if ( !hooks || !( "set" in hooks ) ||<br/>				( value = hooks.set( elem, value, extra ) ) !== undefined ) {<br/><br/>				if ( isCustomProp ) {<br/>					style.setProperty( name, value );<br/>				} else {<br/>					style[ name ] = value;<br/>				}<br/>			}<br/><br/>		} else {<br/><br/>			// If a hook was provided get the non-computed value from there<br/>			if ( hooks &amp;&amp; "get" in hooks &amp;&amp;<br/>				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {<br/><br/>				return ret;<br/>			}<br/><br/>			// Otherwise just get the value from the style object<br/>			return style[ name ];<br/>		}<br/>	},<br/><br/>	css: function( elem, name, extra, styles ) {<br/>		var val, num, hooks,<br/>			origName = camelCase( name ),<br/>			isCustomProp = rcustomProp.test( name );<br/><br/>		// Make sure that we're working with the right name. We don't<br/>		// want to modify the value if it is a CSS custom property<br/>		// since they are user-defined.<br/>		if ( !isCustomProp ) {<br/>			name = finalPropName( origName );<br/>		}<br/><br/>		// Try prefixed name followed by the unprefixed name<br/>		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];<br/><br/>		// If a hook was provided get the computed value from there<br/>		if ( hooks &amp;&amp; "get" in hooks ) {<br/>			val = hooks.get( elem, true, extra );<br/>		}<br/><br/>		// Otherwise, if a way to get the computed value exists, use that<br/>		if ( val === undefined ) {<br/>			val = curCSS( elem, name, styles );<br/>		}<br/><br/>		// Convert "normal" to computed value<br/>		if ( val === "normal" &amp;&amp; name in cssNormalTransform ) {<br/>			val = cssNormalTransform[ name ];<br/>		}<br/><br/>		// Make numeric if forced or a qualifier was provided and val looks numeric<br/>		if ( extra === "" || extra ) {<br/>			num = parseFloat( val );<br/>			return extra === true || isFinite( num ) ? num || 0 : val;<br/>		}<br/><br/>		return val;<br/>	}<br/>} );<br/><br/>jQuery.each( [ "height", "width" ], function( i, dimension ) {<br/>	jQuery.cssHooks[ dimension ] = {<br/>		get: function( elem, computed, extra ) {<br/>			if ( computed ) {<br/><br/>				// Certain elements can have dimension info if we invisibly show them<br/>				// but it must have a current display style that would benefit<br/>				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &amp;&amp;<br/><br/>					// Support: Safari 8+<br/>					// Table columns in Safari have non-zero offsetWidth &amp; zero<br/>					// getBoundingClientRect().width unless display is changed.<br/>					// Support: IE &lt;=11 only<br/>					// Running getBoundingClientRect on a disconnected node<br/>					// in IE throws an error.<br/>					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?<br/>						swap( elem, cssShow, function() {<br/>							return getWidthOrHeight( elem, dimension, extra );<br/>						} ) :<br/>						getWidthOrHeight( elem, dimension, extra );<br/>			}<br/>		},<br/><br/>		set: function( elem, value, extra ) {<br/>			var matches,<br/>				styles = getStyles( elem ),<br/>				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",<br/>				subtract = extra &amp;&amp; boxModelAdjustment(<br/>					elem,<br/>					dimension,<br/>					extra,<br/>					isBorderBox,<br/>					styles<br/>				);<br/><br/>			// Account for unreliable border-box dimensions by comparing offset* to computed and<br/>			// faking a content-box to get border and padding (gh-3699)<br/>			if ( isBorderBox &amp;&amp; support.scrollboxSize() === styles.position ) {<br/>				subtract -= Math.ceil(<br/>					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -<br/>					parseFloat( styles[ dimension ] ) -<br/>					boxModelAdjustment( elem, dimension, "border", false, styles ) -<br/>					0.5<br/>				);<br/>			}<br/><br/>			// Convert to pixels if value adjustment is needed<br/>			if ( subtract &amp;&amp; ( matches = rcssNum.exec( value ) ) &amp;&amp;<br/>				( matches[ 3 ] || "px" ) !== "px" ) {<br/><br/>				elem.style[ dimension ] = value;<br/>				value = jQuery.css( elem, dimension );<br/>			}<br/><br/>			return setPositiveNumber( elem, value, subtract );<br/>		}<br/>	};<br/>} );<br/><br/>jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,<br/>	function( elem, computed ) {<br/>		if ( computed ) {<br/>			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||<br/>				elem.getBoundingClientRect().left -<br/>					swap( elem, { marginLeft: 0 }, function() {<br/>						return elem.getBoundingClientRect().left;<br/>					} )<br/>				) + "px";<br/>		}<br/>	}<br/>);<br/><br/>// These hooks are used by animate to expand properties<br/>jQuery.each( {<br/>	margin: "",<br/>	padding: "",<br/>	border: "Width"<br/>}, function( prefix, suffix ) {<br/>	jQuery.cssHooks[ prefix + suffix ] = {<br/>		expand: function( value ) {<br/>			var i = 0,<br/>				expanded = {},<br/><br/>				// Assumes a single number if not a string<br/>				parts = typeof value === "string" ? value.split( " " ) : [ value ];<br/><br/>			for ( ; i &lt; 4; i++ ) {<br/>				expanded[ prefix + cssExpand[ i ] + suffix ] =<br/>					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];<br/>			}<br/><br/>			return expanded;<br/>		}<br/>	};<br/><br/>	if ( prefix !== "margin" ) {<br/>		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;<br/>	}<br/>} );<br/><br/>jQuery.fn.extend( {<br/>	css: function( name, value ) {<br/>		return access( this, function( elem, name, value ) {<br/>			var styles, len,<br/>				map = {},<br/>				i = 0;<br/><br/>			if ( Array.isArray( name ) ) {<br/>				styles = getStyles( elem );<br/>				len = name.length;<br/><br/>				for ( ; i &lt; len; i++ ) {<br/>					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );<br/>				}<br/><br/>				return map;<br/>			}<br/><br/>			return value !== undefined ?<br/>				jQuery.style( elem, name, value ) :<br/>				jQuery.css( elem, name );<br/>		}, name, value, arguments.length &gt; 1 );<br/>	}<br/>} );<br/><br/><br/>function Tween( elem, options, prop, end, easing ) {<br/>	return new Tween.prototype.init( elem, options, prop, end, easing );<br/>}<br/>jQuery.Tween = Tween;<br/><br/>Tween.prototype = {<br/>	constructor: Tween,<br/>	init: function( elem, options, prop, end, easing, unit ) {<br/>		this.elem = elem;<br/>		this.prop = prop;<br/>		this.easing = easing || jQuery.easing._default;<br/>		this.options = options;<br/>		this.start = this.now = this.cur();<br/>		this.end = end;<br/>		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );<br/>	},<br/>	cur: function() {<br/>		var hooks = Tween.propHooks[ this.prop ];<br/><br/>		return hooks &amp;&amp; hooks.get ?<br/>			hooks.get( this ) :<br/>			Tween.propHooks._default.get( this );<br/>	},<br/>	run: function( percent ) {<br/>		var eased,<br/>			hooks = Tween.propHooks[ this.prop ];<br/><br/>		if ( this.options.duration ) {<br/>			this.pos = eased = jQuery.easing[ this.easing ](<br/>				percent, this.options.duration * percent, 0, 1, this.options.duration<br/>			);<br/>		} else {<br/>			this.pos = eased = percent;<br/>		}<br/>		this.now = ( this.end - this.start ) * eased + this.start;<br/><br/>		if ( this.options.step ) {<br/>			this.options.step.call( this.elem, this.now, this );<br/>		}<br/><br/>		if ( hooks &amp;&amp; hooks.set ) {<br/>			hooks.set( this );<br/>		} else {<br/>			Tween.propHooks._default.set( this );<br/>		}<br/>		return this;<br/>	}<br/>};<br/><br/>Tween.prototype.init.prototype = Tween.prototype;<br/><br/>Tween.propHooks = {<br/>	_default: {<br/>		get: function( tween ) {<br/>			var result;<br/><br/>			// Use a property on the element directly when it is not a DOM element,<br/>			// or when there is no matching style property that exists.<br/>			if ( tween.elem.nodeType !== 1 ||<br/>				tween.elem[ tween.prop ] != null &amp;&amp; tween.elem.style[ tween.prop ] == null ) {<br/>				return tween.elem[ tween.prop ];<br/>			}<br/><br/>			// Passing an empty string as a 3rd parameter to .css will automatically<br/>			// attempt a parseFloat and fallback to a string if the parse fails.<br/>			// Simple values such as "10px" are parsed to Float;<br/>			// complex values such as "rotate(1rad)" are returned as-is.<br/>			result = jQuery.css( tween.elem, tween.prop, "" );<br/><br/>			// Empty strings, null, undefined and "auto" are converted to 0.<br/>			return !result || result === "auto" ? 0 : result;<br/>		},<br/>		set: function( tween ) {<br/><br/>			// Use step hook for back compat.<br/>			// Use cssHook if its there.<br/>			// Use .style if available and use plain properties where available.<br/>			if ( jQuery.fx.step[ tween.prop ] ) {<br/>				jQuery.fx.step[ tween.prop ]( tween );<br/>			} else if ( tween.elem.nodeType === 1 &amp;&amp;<br/>				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||<br/>					jQuery.cssHooks[ tween.prop ] ) ) {<br/>				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );<br/>			} else {<br/>				tween.elem[ tween.prop ] = tween.now;<br/>			}<br/>		}<br/>	}<br/>};<br/><br/>// Support: IE &lt;=9 only<br/>// Panic based approach to setting things on disconnected nodes<br/>Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {<br/>	set: function( tween ) {<br/>		if ( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) {<br/>			tween.elem[ tween.prop ] = tween.now;<br/>		}<br/>	}<br/>};<br/><br/>jQuery.easing = {<br/>	linear: function( p ) {<br/>		return p;<br/>	},<br/>	swing: function( p ) {<br/>		return 0.5 - Math.cos( p * Math.PI ) / 2;<br/>	},<br/>	_default: "swing"<br/>};<br/><br/>jQuery.fx = Tween.prototype.init;<br/><br/>// Back compat &lt;1.8 extension point<br/>jQuery.fx.step = {};<br/><br/><br/><br/><br/>var<br/>	fxNow, inProgress,<br/>	rfxtypes = /^(?:toggle|show|hide)$/,<br/>	rrun = /queueHooks$/;<br/><br/>function schedule() {<br/>	if ( inProgress ) {<br/>		if ( document.hidden === false &amp;&amp; window.requestAnimationFrame ) {<br/>			window.requestAnimationFrame( schedule );<br/>		} else {<br/>			window.setTimeout( schedule, jQuery.fx.interval );<br/>		}<br/><br/>		jQuery.fx.tick();<br/>	}<br/>}<br/><br/>// Animations created synchronously will run synchronously<br/>function createFxNow() {<br/>	window.setTimeout( function() {<br/>		fxNow = undefined;<br/>	} );<br/>	return ( fxNow = Date.now() );<br/>}<br/><br/>// Generate parameters to create a standard animation<br/>function genFx( type, includeWidth ) {<br/>	var which,<br/>		i = 0,<br/>		attrs = { height: type };<br/><br/>	// If we include width, step value is 1 to do all cssExpand values,<br/>	// otherwise step value is 2 to skip over Left and Right<br/>	includeWidth = includeWidth ? 1 : 0;<br/>	for ( ; i &lt; 4; i += 2 - includeWidth ) {<br/>		which = cssExpand[ i ];<br/>		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;<br/>	}<br/><br/>	if ( includeWidth ) {<br/>		attrs.opacity = attrs.width = type;<br/>	}<br/><br/>	return attrs;<br/>}<br/><br/>function createTween( value, prop, animation ) {<br/>	var tween,<br/>		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),<br/>		index = 0,<br/>		length = collection.length;<br/>	for ( ; index &lt; length; index++ ) {<br/>		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {<br/><br/>			// We're done with this property<br/>			return tween;<br/>		}<br/>	}<br/>}<br/><br/>function defaultPrefilter( elem, props, opts ) {<br/>	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,<br/>		isBox = "width" in props || "height" in props,<br/>		anim = this,<br/>		orig = {},<br/>		style = elem.style,<br/>		hidden = elem.nodeType &amp;&amp; isHiddenWithinTree( elem ),<br/>		dataShow = dataPriv.get( elem, "fxshow" );<br/><br/>	// Queue-skipping animations hijack the fx hooks<br/>	if ( !opts.queue ) {<br/>		hooks = jQuery._queueHooks( elem, "fx" );<br/>		if ( hooks.unqueued == null ) {<br/>			hooks.unqueued = 0;<br/>			oldfire = hooks.empty.fire;<br/>			hooks.empty.fire = function() {<br/>				if ( !hooks.unqueued ) {<br/>					oldfire();<br/>				}<br/>			};<br/>		}<br/>		hooks.unqueued++;<br/><br/>		anim.always( function() {<br/><br/>			// Ensure the complete handler is called before this completes<br/>			anim.always( function() {<br/>				hooks.unqueued--;<br/>				if ( !jQuery.queue( elem, "fx" ).length ) {<br/>					hooks.empty.fire();<br/>				}<br/>			} );<br/>		} );<br/>	}<br/><br/>	// Detect show/hide animations<br/>	for ( prop in props ) {<br/>		value = props[ prop ];<br/>		if ( rfxtypes.test( value ) ) {<br/>			delete props[ prop ];<br/>			toggle = toggle || value === "toggle";<br/>			if ( value === ( hidden ? "hide" : "show" ) ) {<br/><br/>				// Pretend to be hidden if this is a "show" and<br/>				// there is still data from a stopped show/hide<br/>				if ( value === "show" &amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !== undefined ) {<br/>					hidden = true;<br/><br/>				// Ignore all other no-op show/hide data<br/>				} else {<br/>					continue;<br/>				}<br/>			}<br/>			orig[ prop ] = dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem, prop );<br/>		}<br/>	}<br/><br/>	// Bail out if this is a no-op like .hide().hide()<br/>	propTween = !jQuery.isEmptyObject( props );<br/>	if ( !propTween &amp;&amp; jQuery.isEmptyObject( orig ) ) {<br/>		return;<br/>	}<br/><br/>	// Restrict "overflow" and "display" styles during box animations<br/>	if ( isBox &amp;&amp; elem.nodeType === 1 ) {<br/><br/>		// Support: IE &lt;=9 - 11, Edge 12 - 15<br/>		// Record all 3 overflow attributes because IE does not infer the shorthand<br/>		// from identically-valued overflowX and overflowY and Edge just mirrors<br/>		// the overflowX value there.<br/>		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];<br/><br/>		// Identify a display type, preferring old show/hide data over the CSS cascade<br/>		restoreDisplay = dataShow &amp;&amp; dataShow.display;<br/>		if ( restoreDisplay == null ) {<br/>			restoreDisplay = dataPriv.get( elem, "display" );<br/>		}<br/>		display = jQuery.css( elem, "display" );<br/>		if ( display === "none" ) {<br/>			if ( restoreDisplay ) {<br/>				display = restoreDisplay;<br/>			} else {<br/><br/>				// Get nonempty value(s) by temporarily forcing visibility<br/>				showHide( [ elem ], true );<br/>				restoreDisplay = elem.style.display || restoreDisplay;<br/>				display = jQuery.css( elem, "display" );<br/>				showHide( [ elem ] );<br/>			}<br/>		}<br/><br/>		// Animate inline elements as inline-block<br/>		if ( display === "inline" || display === "inline-block" &amp;&amp; restoreDisplay != null ) {<br/>			if ( jQuery.css( elem, "float" ) === "none" ) {<br/><br/>				// Restore the original display value at the end of pure show/hide animations<br/>				if ( !propTween ) {<br/>					anim.done( function() {<br/>						style.display = restoreDisplay;<br/>					} );<br/>					if ( restoreDisplay == null ) {<br/>						display = style.display;<br/>						restoreDisplay = display === "none" ? "" : display;<br/>					}<br/>				}<br/>				style.display = "inline-block";<br/>			}<br/>		}<br/>	}<br/><br/>	if ( opts.overflow ) {<br/>		style.overflow = "hidden";<br/>		anim.always( function() {<br/>			style.overflow = opts.overflow[ 0 ];<br/>			style.overflowX = opts.overflow[ 1 ];<br/>			style.overflowY = opts.overflow[ 2 ];<br/>		} );<br/>	}<br/><br/>	// Implement show/hide animations<br/>	propTween = false;<br/>	for ( prop in orig ) {<br/><br/>		// General show/hide setup for this element animation<br/>		if ( !propTween ) {<br/>			if ( dataShow ) {<br/>				if ( "hidden" in dataShow ) {<br/>					hidden = dataShow.hidden;<br/>				}<br/>			} else {<br/>				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );<br/>			}<br/><br/>			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"<br/>			if ( toggle ) {<br/>				dataShow.hidden = !hidden;<br/>			}<br/><br/>			// Show elements before animating them<br/>			if ( hidden ) {<br/>				showHide( [ elem ], true );<br/>			}<br/><br/>			/* eslint-disable no-loop-func */<br/><br/>			anim.done( function() {<br/><br/>			/* eslint-enable no-loop-func */<br/><br/>				// The final step of a "hide" animation is actually hiding the element<br/>				if ( !hidden ) {<br/>					showHide( [ elem ] );<br/>				}<br/>				dataPriv.remove( elem, "fxshow" );<br/>				for ( prop in orig ) {<br/>					jQuery.style( elem, prop, orig[ prop ] );<br/>				}<br/>			} );<br/>		}<br/><br/>		// Per-property setup<br/>		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );<br/>		if ( !( prop in dataShow ) ) {<br/>			dataShow[ prop ] = propTween.start;<br/>			if ( hidden ) {<br/>				propTween.end = propTween.start;<br/>				propTween.start = 0;<br/>			}<br/>		}<br/>	}<br/>}<br/><br/>function propFilter( props, specialEasing ) {<br/>	var index, name, easing, value, hooks;<br/><br/>	// camelCase, specialEasing and expand cssHook pass<br/>	for ( index in props ) {<br/>		name = camelCase( index );<br/>		easing = specialEasing[ name ];<br/>		value = props[ index ];<br/>		if ( Array.isArray( value ) ) {<br/>			easing = value[ 1 ];<br/>			value = props[ index ] = value[ 0 ];<br/>		}<br/><br/>		if ( index !== name ) {<br/>			props[ name ] = value;<br/>			delete props[ index ];<br/>		}<br/><br/>		hooks = jQuery.cssHooks[ name ];<br/>		if ( hooks &amp;&amp; "expand" in hooks ) {<br/>			value = hooks.expand( value );<br/>			delete props[ name ];<br/><br/>			// Not quite $.extend, this won't overwrite existing keys.<br/>			// Reusing 'index' because we have the correct "name"<br/>			for ( index in value ) {<br/>				if ( !( index in props ) ) {<br/>					props[ index ] = value[ index ];<br/>					specialEasing[ index ] = easing;<br/>				}<br/>			}<br/>		} else {<br/>			specialEasing[ name ] = easing;<br/>		}<br/>	}<br/>}<br/><br/>function Animation( elem, properties, options ) {<br/>	var result,<br/>		stopped,<br/>		index = 0,<br/>		length = Animation.prefilters.length,<br/>		deferred = jQuery.Deferred().always( function() {<br/><br/>			// Don't match elem in the :animated selector<br/>			delete tick.elem;<br/>		} ),<br/>		tick = function() {<br/>			if ( stopped ) {<br/>				return false;<br/>			}<br/>			var currentTime = fxNow || createFxNow(),<br/>				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),<br/><br/>				// Support: Android 2.3 only<br/>				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)<br/>				temp = remaining / animation.duration || 0,<br/>				percent = 1 - temp,<br/>				index = 0,<br/>				length = animation.tweens.length;<br/><br/>			for ( ; index &lt; length; index++ ) {<br/>				animation.tweens[ index ].run( percent );<br/>			}<br/><br/>			deferred.notifyWith( elem, [ animation, percent, remaining ] );<br/><br/>			// If there's more to do, yield<br/>			if ( percent &lt; 1 &amp;&amp; length ) {<br/>				return remaining;<br/>			}<br/><br/>			// If this was an empty animation, synthesize a final progress notification<br/>			if ( !length ) {<br/>				deferred.notifyWith( elem, [ animation, 1, 0 ] );<br/>			}<br/><br/>			// Resolve the animation and report its conclusion<br/>			deferred.resolveWith( elem, [ animation ] );<br/>			return false;<br/>		},<br/>		animation = deferred.promise( {<br/>			elem: elem,<br/>			props: jQuery.extend( {}, properties ),<br/>			opts: jQuery.extend( true, {<br/>				specialEasing: {},<br/>				easing: jQuery.easing._default<br/>			}, options ),<br/>			originalProperties: properties,<br/>			originalOptions: options,<br/>			startTime: fxNow || createFxNow(),<br/>			duration: options.duration,<br/>			tweens: [],<br/>			createTween: function( prop, end ) {<br/>				var tween = jQuery.Tween( elem, animation.opts, prop, end,<br/>						animation.opts.specialEasing[ prop ] || animation.opts.easing );<br/>				animation.tweens.push( tween );<br/>				return tween;<br/>			},<br/>			stop: function( gotoEnd ) {<br/>				var index = 0,<br/><br/>					// If we are going to the end, we want to run all the tweens<br/>					// otherwise we skip this part<br/>					length = gotoEnd ? animation.tweens.length : 0;<br/>				if ( stopped ) {<br/>					return this;<br/>				}<br/>				stopped = true;<br/>				for ( ; index &lt; length; index++ ) {<br/>					animation.tweens[ index ].run( 1 );<br/>				}<br/><br/>				// Resolve when we played the last frame; otherwise, reject<br/>				if ( gotoEnd ) {<br/>					deferred.notifyWith( elem, [ animation, 1, 0 ] );<br/>					deferred.resolveWith( elem, [ animation, gotoEnd ] );<br/>				} else {<br/>					deferred.rejectWith( elem, [ animation, gotoEnd ] );<br/>				}<br/>				return this;<br/>			}<br/>		} ),<br/>		props = animation.props;<br/><br/>	propFilter( props, animation.opts.specialEasing );<br/><br/>	for ( ; index &lt; length; index++ ) {<br/>		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );<br/>		if ( result ) {<br/>			if ( isFunction( result.stop ) ) {<br/>				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =<br/>					result.stop.bind( result );<br/>			}<br/>			return result;<br/>		}<br/>	}<br/><br/>	jQuery.map( props, createTween, animation );<br/><br/>	if ( isFunction( animation.opts.start ) ) {<br/>		animation.opts.start.call( elem, animation );<br/>	}<br/><br/>	// Attach callbacks from options<br/>	animation<br/>		.progress( animation.opts.progress )<br/>		.done( animation.opts.done, animation.opts.complete )<br/>		.fail( animation.opts.fail )<br/>		.always( animation.opts.always );<br/><br/>	jQuery.fx.timer(<br/>		jQuery.extend( tick, {<br/>			elem: elem,<br/>			anim: animation,<br/>			queue: animation.opts.queue<br/>		} )<br/>	);<br/><br/>	return animation;<br/>}<br/><br/>jQuery.Animation = jQuery.extend( Animation, {<br/><br/>	tweeners: {<br/>		"*": [ function( prop, value ) {<br/>			var tween = this.createTween( prop, value );<br/>			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );<br/>			return tween;<br/>		} ]<br/>	},<br/><br/>	tweener: function( props, callback ) {<br/>		if ( isFunction( props ) ) {<br/>			callback = props;<br/>			props = [ "*" ];<br/>		} else {<br/>			props = props.match( rnothtmlwhite );<br/>		}<br/><br/>		var prop,<br/>			index = 0,<br/>			length = props.length;<br/><br/>		for ( ; index &lt; length; index++ ) {<br/>			prop = props[ index ];<br/>			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];<br/>			Animation.tweeners[ prop ].unshift( callback );<br/>		}<br/>	},<br/><br/>	prefilters: [ defaultPrefilter ],<br/><br/>	prefilter: function( callback, prepend ) {<br/>		if ( prepend ) {<br/>			Animation.prefilters.unshift( callback );<br/>		} else {<br/>			Animation.prefilters.push( callback );<br/>		}<br/>	}<br/>} );<br/><br/>jQuery.speed = function( speed, easing, fn ) {<br/>	var opt = speed &amp;&amp; typeof speed === "object" ? jQuery.extend( {}, speed ) : {<br/>		complete: fn || !fn &amp;&amp; easing ||<br/>			isFunction( speed ) &amp;&amp; speed,<br/>		duration: speed,<br/>		easing: fn &amp;&amp; easing || easing &amp;&amp; !isFunction( easing ) &amp;&amp; easing<br/>	};<br/><br/>	// Go to the end state if fx are off<br/>	if ( jQuery.fx.off ) {<br/>		opt.duration = 0;<br/><br/>	} else {<br/>		if ( typeof opt.duration !== "number" ) {<br/>			if ( opt.duration in jQuery.fx.speeds ) {<br/>				opt.duration = jQuery.fx.speeds[ opt.duration ];<br/><br/>			} else {<br/>				opt.duration = jQuery.fx.speeds._default;<br/>			}<br/>		}<br/>	}<br/><br/>	// Normalize opt.queue - true/undefined/null -&gt; "fx"<br/>	if ( opt.queue == null || opt.queue === true ) {<br/>		opt.queue = "fx";<br/>	}<br/><br/>	// Queueing<br/>	opt.old = opt.complete;<br/><br/>	opt.complete = function() {<br/>		if ( isFunction( opt.old ) ) {<br/>			opt.old.call( this );<br/>		}<br/><br/>		if ( opt.queue ) {<br/>			jQuery.dequeue( this, opt.queue );<br/>		}<br/>	};<br/><br/>	return opt;<br/>};<br/><br/>jQuery.fn.extend( {<br/>	fadeTo: function( speed, to, easing, callback ) {<br/><br/>		// Show any hidden elements after setting opacity to 0<br/>		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()<br/><br/>			// Animate to the value specified<br/>			.end().animate( { opacity: to }, speed, easing, callback );<br/>	},<br/>	animate: function( prop, speed, easing, callback ) {<br/>		var empty = jQuery.isEmptyObject( prop ),<br/>			optall = jQuery.speed( speed, easing, callback ),<br/>			doAnimation = function() {<br/><br/>				// Operate on a copy of prop so per-property easing won't be lost<br/>				var anim = Animation( this, jQuery.extend( {}, prop ), optall );<br/><br/>				// Empty animations, or finishing resolves immediately<br/>				if ( empty || dataPriv.get( this, "finish" ) ) {<br/>					anim.stop( true );<br/>				}<br/>			};<br/>			doAnimation.finish = doAnimation;<br/><br/>		return empty || optall.queue === false ?<br/>			this.each( doAnimation ) :<br/>			this.queue( optall.queue, doAnimation );<br/>	},<br/>	stop: function( type, clearQueue, gotoEnd ) {<br/>		var stopQueue = function( hooks ) {<br/>			var stop = hooks.stop;<br/>			delete hooks.stop;<br/>			stop( gotoEnd );<br/>		};<br/><br/>		if ( typeof type !== "string" ) {<br/>			gotoEnd = clearQueue;<br/>			clearQueue = type;<br/>			type = undefined;<br/>		}<br/>		if ( clearQueue &amp;&amp; type !== false ) {<br/>			this.queue( type || "fx", [] );<br/>		}<br/><br/>		return this.each( function() {<br/>			var dequeue = true,<br/>				index = type != null &amp;&amp; type + "queueHooks",<br/>				timers = jQuery.timers,<br/>				data = dataPriv.get( this );<br/><br/>			if ( index ) {<br/>				if ( data[ index ] &amp;&amp; data[ index ].stop ) {<br/>					stopQueue( data[ index ] );<br/>				}<br/>			} else {<br/>				for ( index in data ) {<br/>					if ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) {<br/>						stopQueue( data[ index ] );<br/>					}<br/>				}<br/>			}<br/><br/>			for ( index = timers.length; index--; ) {<br/>				if ( timers[ index ].elem === this &amp;&amp;<br/>					( type == null || timers[ index ].queue === type ) ) {<br/><br/>					timers[ index ].anim.stop( gotoEnd );<br/>					dequeue = false;<br/>					timers.splice( index, 1 );<br/>				}<br/>			}<br/><br/>			// Start the next in the queue if the last step wasn't forced.<br/>			// Timers currently will call their complete callbacks, which<br/>			// will dequeue but only if they were gotoEnd.<br/>			if ( dequeue || !gotoEnd ) {<br/>				jQuery.dequeue( this, type );<br/>			}<br/>		} );<br/>	},<br/>	finish: function( type ) {<br/>		if ( type !== false ) {<br/>			type = type || "fx";<br/>		}<br/>		return this.each( function() {<br/>			var index,<br/>				data = dataPriv.get( this ),<br/>				queue = data[ type + "queue" ],<br/>				hooks = data[ type + "queueHooks" ],<br/>				timers = jQuery.timers,<br/>				length = queue ? queue.length : 0;<br/><br/>			// Enable finishing flag on private data<br/>			data.finish = true;<br/><br/>			// Empty the queue first<br/>			jQuery.queue( this, type, [] );<br/><br/>			if ( hooks &amp;&amp; hooks.stop ) {<br/>				hooks.stop.call( this, true );<br/>			}<br/><br/>			// Look for any active animations, and finish them<br/>			for ( index = timers.length; index--; ) {<br/>				if ( timers[ index ].elem === this &amp;&amp; timers[ index ].queue === type ) {<br/>					timers[ index ].anim.stop( true );<br/>					timers.splice( index, 1 );<br/>				}<br/>			}<br/><br/>			// Look for any animations in the old queue and finish them<br/>			for ( index = 0; index &lt; length; index++ ) {<br/>				if ( queue[ index ] &amp;&amp; queue[ index ].finish ) {<br/>					queue[ index ].finish.call( this );<br/>				}<br/>			}<br/><br/>			// Turn off finishing flag<br/>			delete data.finish;<br/>		} );<br/>	}<br/>} );<br/><br/>jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {<br/>	var cssFn = jQuery.fn[ name ];<br/>	jQuery.fn[ name ] = function( speed, easing, callback ) {<br/>		return speed == null || typeof speed === "boolean" ?<br/>			cssFn.apply( this, arguments ) :<br/>			this.animate( genFx( name, true ), speed, easing, callback );<br/>	};<br/>} );<br/><br/>// Generate shortcuts for custom animations<br/>jQuery.each( {<br/>	slideDown: genFx( "show" ),<br/>	slideUp: genFx( "hide" ),<br/>	slideToggle: genFx( "toggle" ),<br/>	fadeIn: { opacity: "show" },<br/>	fadeOut: { opacity: "hide" },<br/>	fadeToggle: { opacity: "toggle" }<br/>}, function( name, props ) {<br/>	jQuery.fn[ name ] = function( speed, easing, callback ) {<br/>		return this.animate( props, speed, easing, callback );<br/>	};<br/>} );<br/><br/>jQuery.timers = [];<br/>jQuery.fx.tick = function() {<br/>	var timer,<br/>		i = 0,<br/>		timers = jQuery.timers;<br/><br/>	fxNow = Date.now();<br/><br/>	for ( ; i &lt; timers.length; i++ ) {<br/>		timer = timers[ i ];<br/><br/>		// Run the timer and safely remove it when done (allowing for external removal)<br/>		if ( !timer() &amp;&amp; timers[ i ] === timer ) {<br/>			timers.splice( i--, 1 );<br/>		}<br/>	}<br/><br/>	if ( !timers.length ) {<br/>		jQuery.fx.stop();<br/>	}<br/>	fxNow = undefined;<br/>};<br/><br/>jQuery.fx.timer = function( timer ) {<br/>	jQuery.timers.push( timer );<br/>	jQuery.fx.start();<br/>};<br/><br/>jQuery.fx.interval = 13;<br/>jQuery.fx.start = function() {<br/>	if ( inProgress ) {<br/>		return;<br/>	}<br/><br/>	inProgress = true;<br/>	schedule();<br/>};<br/><br/>jQuery.fx.stop = function() {<br/>	inProgress = null;<br/>};<br/><br/>jQuery.fx.speeds = {<br/>	slow: 600,<br/>	fast: 200,<br/><br/>	// Default speed<br/>	_default: 400<br/>};<br/><br/><br/>// Based off of the plugin by Clint Helfers, with permission.<br/>// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/<br/>jQuery.fn.delay = function( time, type ) {<br/>	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;<br/>	type = type || "fx";<br/><br/>	return this.queue( type, function( next, hooks ) {<br/>		var timeout = window.setTimeout( next, time );<br/>		hooks.stop = function() {<br/>			window.clearTimeout( timeout );<br/>		};<br/>	} );<br/>};<br/><br/><br/>( function() {<br/>	var input = document.createElement( "input" ),<br/>		select = document.createElement( "select" ),<br/>		opt = select.appendChild( document.createElement( "option" ) );<br/><br/>	input.type = "checkbox";<br/><br/>	// Support: Android &lt;=4.3 only<br/>	// Default value for a checkbox should be "on"<br/>	support.checkOn = input.value !== "";<br/><br/>	// Support: IE &lt;=11 only<br/>	// Must access selectedIndex to make default options select<br/>	support.optSelected = opt.selected;<br/><br/>	// Support: IE &lt;=11 only<br/>	// An input loses its value after becoming a radio<br/>	input = document.createElement( "input" );<br/>	input.value = "t";<br/>	input.type = "radio";<br/>	support.radioValue = input.value === "t";<br/>} )();<br/><br/><br/>var boolHook,<br/>	attrHandle = jQuery.expr.attrHandle;<br/><br/>jQuery.fn.extend( {<br/>	attr: function( name, value ) {<br/>		return access( this, jQuery.attr, name, value, arguments.length &gt; 1 );<br/>	},<br/><br/>	removeAttr: function( name ) {<br/>		return this.each( function() {<br/>			jQuery.removeAttr( this, name );<br/>		} );<br/>	}<br/>} );<br/><br/>jQuery.extend( {<br/>	attr: function( elem, name, value ) {<br/>		var ret, hooks,<br/>			nType = elem.nodeType;<br/><br/>		// Don't get/set attributes on text, comment and attribute nodes<br/>		if ( nType === 3 || nType === 8 || nType === 2 ) {<br/>			return;<br/>		}<br/><br/>		// Fallback to prop when attributes are not supported<br/>		if ( typeof elem.getAttribute === "undefined" ) {<br/>			return jQuery.prop( elem, name, value );<br/>		}<br/><br/>		// Attribute hooks are determined by the lowercase version<br/>		// Grab necessary hook if one is defined<br/>		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {<br/>			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||<br/>				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );<br/>		}<br/><br/>		if ( value !== undefined ) {<br/>			if ( value === null ) {<br/>				jQuery.removeAttr( elem, name );<br/>				return;<br/>			}<br/><br/>			if ( hooks &amp;&amp; "set" in hooks &amp;&amp;<br/>				( ret = hooks.set( elem, value, name ) ) !== undefined ) {<br/>				return ret;<br/>			}<br/><br/>			elem.setAttribute( name, value + "" );<br/>			return value;<br/>		}<br/><br/>		if ( hooks &amp;&amp; "get" in hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== null ) {<br/>			return ret;<br/>		}<br/><br/>		ret = jQuery.find.attr( elem, name );<br/><br/>		// Non-existent attributes return null, we normalize to undefined<br/>		return ret == null ? undefined : ret;<br/>	},<br/><br/>	attrHooks: {<br/>		type: {<br/>			set: function( elem, value ) {<br/>				if ( !support.radioValue &amp;&amp; value === "radio" &amp;&amp;<br/>					nodeName( elem, "input" ) ) {<br/>					var val = elem.value;<br/>					elem.setAttribute( "type", value );<br/>					if ( val ) {<br/>						elem.value = val;<br/>					}<br/>					return value;<br/>				}<br/>			}<br/>		}<br/>	},<br/><br/>	removeAttr: function( elem, value ) {<br/>		var name,<br/>			i = 0,<br/><br/>			// Attribute names can contain non-HTML whitespace characters<br/>			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2<br/>			attrNames = value &amp;&amp; value.match( rnothtmlwhite );<br/><br/>		if ( attrNames &amp;&amp; elem.nodeType === 1 ) {<br/>			while ( ( name = attrNames[ i++ ] ) ) {<br/>				elem.removeAttribute( name );<br/>			}<br/>		}<br/>	}<br/>} );<br/><br/>// Hooks for boolean attributes<br/>boolHook = {<br/>	set: function( elem, value, name ) {<br/>		if ( value === false ) {<br/><br/>			// Remove boolean attributes when set to false<br/>			jQuery.removeAttr( elem, name );<br/>		} else {<br/>			elem.setAttribute( name, name );<br/>		}<br/>		return name;<br/>	}<br/>};<br/><br/>jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {<br/>	var getter = attrHandle[ name ] || jQuery.find.attr;<br/><br/>	attrHandle[ name ] = function( elem, name, isXML ) {<br/>		var ret, handle,<br/>			lowercaseName = name.toLowerCase();<br/><br/>		if ( !isXML ) {<br/><br/>			// Avoid an infinite loop by temporarily removing this function from the getter<br/>			handle = attrHandle[ lowercaseName ];<br/>			attrHandle[ lowercaseName ] = ret;<br/>			ret = getter( elem, name, isXML ) != null ?<br/>				lowercaseName :<br/>				null;<br/>			attrHandle[ lowercaseName ] = handle;<br/>		}<br/>		return ret;<br/>	};<br/>} );<br/><br/><br/><br/><br/>var rfocusable = /^(?:input|select|textarea|button)$/i,<br/>	rclickable = /^(?:a|area)$/i;<br/><br/>jQuery.fn.extend( {<br/>	prop: function( name, value ) {<br/>		return access( this, jQuery.prop, name, value, arguments.length &gt; 1 );<br/>	},<br/><br/>	removeProp: function( name ) {<br/>		return this.each( function() {<br/>			delete this[ jQuery.propFix[ name ] || name ];<br/>		} );<br/>	}<br/>} );<br/><br/>jQuery.extend( {<br/>	prop: function( elem, name, value ) {<br/>		var ret, hooks,<br/>			nType = elem.nodeType;<br/><br/>		// Don't get/set properties on text, comment and attribute nodes<br/>		if ( nType === 3 || nType === 8 || nType === 2 ) {<br/>			return;<br/>		}<br/><br/>		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {<br/><br/>			// Fix name and attach hooks<br/>			name = jQuery.propFix[ name ] || name;<br/>			hooks = jQuery.propHooks[ name ];<br/>		}<br/><br/>		if ( value !== undefined ) {<br/>			if ( hooks &amp;&amp; "set" in hooks &amp;&amp;<br/>				( ret = hooks.set( elem, value, name ) ) !== undefined ) {<br/>				return ret;<br/>			}<br/><br/>			return ( elem[ name ] = value );<br/>		}<br/><br/>		if ( hooks &amp;&amp; "get" in hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== null ) {<br/>			return ret;<br/>		}<br/><br/>		return elem[ name ];<br/>	},<br/><br/>	propHooks: {<br/>		tabIndex: {<br/>			get: function( elem ) {<br/><br/>				// Support: IE &lt;=9 - 11 only<br/>				// elem.tabIndex doesn't always return the<br/>				// correct value when it hasn't been explicitly set<br/>				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/<br/>				// Use proper attribute retrieval(#12072)<br/>				var tabindex = jQuery.find.attr( elem, "tabindex" );<br/><br/>				if ( tabindex ) {<br/>					return parseInt( tabindex, 10 );<br/>				}<br/><br/>				if (<br/>					rfocusable.test( elem.nodeName ) ||<br/>					rclickable.test( elem.nodeName ) &amp;&amp;<br/>					elem.href<br/>				) {<br/>					return 0;<br/>				}<br/><br/>				return -1;<br/>			}<br/>		}<br/>	},<br/><br/>	propFix: {<br/>		"for": "htmlFor",<br/>		"class": "className"<br/>	}<br/>} );<br/><br/>// Support: IE &lt;=11 only<br/>// Accessing the selectedIndex property<br/>// forces the browser to respect setting selected<br/>// on the option<br/>// The getter ensures a default option is selected<br/>// when in an optgroup<br/>// eslint rule "no-unused-expressions" is disabled for this code<br/>// since it considers such accessions noop<br/>if ( !support.optSelected ) {<br/>	jQuery.propHooks.selected = {<br/>		get: function( elem ) {<br/><br/>			/* eslint no-unused-expressions: "off" */<br/><br/>			var parent = elem.parentNode;<br/>			if ( parent &amp;&amp; parent.parentNode ) {<br/>				parent.parentNode.selectedIndex;<br/>			}<br/>			return null;<br/>		},<br/>		set: function( elem ) {<br/><br/>			/* eslint no-unused-expressions: "off" */<br/><br/>			var parent = elem.parentNode;<br/>			if ( parent ) {<br/>				parent.selectedIndex;<br/><br/>				if ( parent.parentNode ) {<br/>					parent.parentNode.selectedIndex;<br/>				}<br/>			}<br/>		}<br/>	};<br/>}<br/><br/>jQuery.each( [<br/>	"tabIndex",<br/>	"readOnly",<br/>	"maxLength",<br/>	"cellSpacing",<br/>	"cellPadding",<br/>	"rowSpan",<br/>	"colSpan",<br/>	"useMap",<br/>	"frameBorder",<br/>	"contentEditable"<br/>], function() {<br/>	jQuery.propFix[ this.toLowerCase() ] = this;<br/>} );<br/><br/><br/><br/><br/>	// Strip and collapse whitespace according to HTML spec<br/>	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace<br/>	function stripAndCollapse( value ) {<br/>		var tokens = value.match( rnothtmlwhite ) || [];<br/>		return tokens.join( " " );<br/>	}<br/><br/><br/>function getClass( elem ) {<br/>	return elem.getAttribute &amp;&amp; elem.getAttribute( "class" ) || "";<br/>}<br/><br/>function classesToArray( value ) {<br/>	if ( Array.isArray( value ) ) {<br/>		return value;<br/>	}<br/>	if ( typeof value === "string" ) {<br/>		return value.match( rnothtmlwhite ) || [];<br/>	}<br/>	return [];<br/>}<br/><br/>jQuery.fn.extend( {<br/>	addClass: function( value ) {<br/>		var classes, elem, cur, curValue, clazz, j, finalValue,<br/>			i = 0;<br/><br/>		if ( isFunction( value ) ) {<br/>			return this.each( function( j ) {<br/>				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );<br/>			} );<br/>		}<br/><br/>		classes = classesToArray( value );<br/><br/>		if ( classes.length ) {<br/>			while ( ( elem = this[ i++ ] ) ) {<br/>				curValue = getClass( elem );<br/>				cur = elem.nodeType === 1 &amp;&amp; ( " " + stripAndCollapse( curValue ) + " " );<br/><br/>				if ( cur ) {<br/>					j = 0;<br/>					while ( ( clazz = classes[ j++ ] ) ) {<br/>						if ( cur.indexOf( " " + clazz + " " ) &lt; 0 ) {<br/>							cur += clazz + " ";<br/>						}<br/>					}<br/><br/>					// Only assign if different to avoid unneeded rendering.<br/>					finalValue = stripAndCollapse( cur );<br/>					if ( curValue !== finalValue ) {<br/>						elem.setAttribute( "class", finalValue );<br/>					}<br/>				}<br/>			}<br/>		}<br/><br/>		return this;<br/>	},<br/><br/>	removeClass: function( value ) {<br/>		var classes, elem, cur, curValue, clazz, j, finalValue,<br/>			i = 0;<br/><br/>		if ( isFunction( value ) ) {<br/>			return this.each( function( j ) {<br/>				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );<br/>			} );<br/>		}<br/><br/>		if ( !arguments.length ) {<br/>			return this.attr( "class", "" );<br/>		}<br/><br/>		classes = classesToArray( value );<br/><br/>		if ( classes.length ) {<br/>			while ( ( elem = this[ i++ ] ) ) {<br/>				curValue = getClass( elem );<br/><br/>				// This expression is here for better compressibility (see addClass)<br/>				cur = elem.nodeType === 1 &amp;&amp; ( " " + stripAndCollapse( curValue ) + " " );<br/><br/>				if ( cur ) {<br/>					j = 0;<br/>					while ( ( clazz = classes[ j++ ] ) ) {<br/><br/>						// Remove *all* instances<br/>						while ( cur.indexOf( " " + clazz + " " ) &gt; -1 ) {<br/>							cur = cur.replace( " " + clazz + " ", " " );<br/>						}<br/>					}<br/><br/>					// Only assign if different to avoid unneeded rendering.<br/>					finalValue = stripAndCollapse( cur );<br/>					if ( curValue !== finalValue ) {<br/>						elem.setAttribute( "class", finalValue );<br/>					}<br/>				}<br/>			}<br/>		}<br/><br/>		return this;<br/>	},<br/><br/>	toggleClass: function( value, stateVal ) {<br/>		var type = typeof value,<br/>			isValidValue = type === "string" || Array.isArray( value );<br/><br/>		if ( typeof stateVal === "boolean" &amp;&amp; isValidValue ) {<br/>			return stateVal ? this.addClass( value ) : this.removeClass( value );<br/>		}<br/><br/>		if ( isFunction( value ) ) {<br/>			return this.each( function( i ) {<br/>				jQuery( this ).toggleClass(<br/>					value.call( this, i, getClass( this ), stateVal ),<br/>					stateVal<br/>				);<br/>			} );<br/>		}<br/><br/>		return this.each( function() {<br/>			var className, i, self, classNames;<br/><br/>			if ( isValidValue ) {<br/><br/>				// Toggle individual class names<br/>				i = 0;<br/>				self = jQuery( this );<br/>				classNames = classesToArray( value );<br/><br/>				while ( ( className = classNames[ i++ ] ) ) {<br/><br/>					// Check each className given, space separated list<br/>					if ( self.hasClass( className ) ) {<br/>						self.removeClass( className );<br/>					} else {<br/>						self.addClass( className );<br/>					}<br/>				}<br/><br/>			// Toggle whole class name<br/>			} else if ( value === undefined || type === "boolean" ) {<br/>				className = getClass( this );<br/>				if ( className ) {<br/><br/>					// Store className if set<br/>					dataPriv.set( this, "__className__", className );<br/>				}<br/><br/>				// If the element has a class name or if we're passed `false`,<br/>				// then remove the whole classname (if there was one, the above saved it).<br/>				// Otherwise bring back whatever was previously saved (if anything),<br/>				// falling back to the empty string if nothing was stored.<br/>				if ( this.setAttribute ) {<br/>					this.setAttribute( "class",<br/>						className || value === false ?<br/>						"" :<br/>						dataPriv.get( this, "__className__" ) || ""<br/>					);<br/>				}<br/>			}<br/>		} );<br/>	},<br/><br/>	hasClass: function( selector ) {<br/>		var className, elem,<br/>			i = 0;<br/><br/>		className = " " + selector + " ";<br/>		while ( ( elem = this[ i++ ] ) ) {<br/>			if ( elem.nodeType === 1 &amp;&amp;<br/>				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) &gt; -1 ) {<br/>					return true;<br/>			}<br/>		}<br/><br/>		return false;<br/>	}<br/>} );<br/><br/><br/><br/><br/>var rreturn = /\r/g;<br/><br/>jQuery.fn.extend( {<br/>	val: function( value ) {<br/>		var hooks, ret, valueIsFunction,<br/>			elem = this[ 0 ];<br/><br/>		if ( !arguments.length ) {<br/>			if ( elem ) {<br/>				hooks = jQuery.valHooks[ elem.type ] ||<br/>					jQuery.valHooks[ elem.nodeName.toLowerCase() ];<br/><br/>				if ( hooks &amp;&amp;<br/>					"get" in hooks &amp;&amp;<br/>					( ret = hooks.get( elem, "value" ) ) !== undefined<br/>				) {<br/>					return ret;<br/>				}<br/><br/>				ret = elem.value;<br/><br/>				// Handle most common string cases<br/>				if ( typeof ret === "string" ) {<br/>					return ret.replace( rreturn, "" );<br/>				}<br/><br/>				// Handle cases where value is null/undef or number<br/>				return ret == null ? "" : ret;<br/>			}<br/><br/>			return;<br/>		}<br/><br/>		valueIsFunction = isFunction( value );<br/><br/>		return this.each( function( i ) {<br/>			var val;<br/><br/>			if ( this.nodeType !== 1 ) {<br/>				return;<br/>			}<br/><br/>			if ( valueIsFunction ) {<br/>				val = value.call( this, i, jQuery( this ).val() );<br/>			} else {<br/>				val = value;<br/>			}<br/><br/>			// Treat null/undefined as ""; convert numbers to string<br/>			if ( val == null ) {<br/>				val = "";<br/><br/>			} else if ( typeof val === "number" ) {<br/>				val += "";<br/><br/>			} else if ( Array.isArray( val ) ) {<br/>				val = jQuery.map( val, function( value ) {<br/>					return value == null ? "" : value + "";<br/>				} );<br/>			}<br/><br/>			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];<br/><br/>			// If set returns undefined, fall back to normal setting<br/>			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {<br/>				this.value = val;<br/>			}<br/>		} );<br/>	}<br/>} );<br/><br/>jQuery.extend( {<br/>	valHooks: {<br/>		option: {<br/>			get: function( elem ) {<br/><br/>				var val = jQuery.find.attr( elem, "value" );<br/>				return val != null ?<br/>					val :<br/><br/>					// Support: IE &lt;=10 - 11 only<br/>					// option.text throws exceptions (#14686, #14858)<br/>					// Strip and collapse whitespace<br/>					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace<br/>					stripAndCollapse( jQuery.text( elem ) );<br/>			}<br/>		},<br/>		select: {<br/>			get: function( elem ) {<br/>				var value, option, i,<br/>					options = elem.options,<br/>					index = elem.selectedIndex,<br/>					one = elem.type === "select-one",<br/>					values = one ? null : [],<br/>					max = one ? index + 1 : options.length;<br/><br/>				if ( index &lt; 0 ) {<br/>					i = max;<br/><br/>				} else {<br/>					i = one ? index : 0;<br/>				}<br/><br/>				// Loop through all the selected options<br/>				for ( ; i &lt; max; i++ ) {<br/>					option = options[ i ];<br/><br/>					// Support: IE &lt;=9 only<br/>					// IE8-9 doesn't update selected after form reset (#2551)<br/>					if ( ( option.selected || i === index ) &amp;&amp;<br/><br/>							// Don't return options that are disabled or in a disabled optgroup<br/>							!option.disabled &amp;&amp;<br/>							( !option.parentNode.disabled ||<br/>								!nodeName( option.parentNode, "optgroup" ) ) ) {<br/><br/>						// Get the specific value for the option<br/>						value = jQuery( option ).val();<br/><br/>						// We don't need an array for one selects<br/>						if ( one ) {<br/>							return value;<br/>						}<br/><br/>						// Multi-Selects return an array<br/>						values.push( value );<br/>					}<br/>				}<br/><br/>				return values;<br/>			},<br/><br/>			set: function( elem, value ) {<br/>				var optionSet, option,<br/>					options = elem.options,<br/>					values = jQuery.makeArray( value ),<br/>					i = options.length;<br/><br/>				while ( i-- ) {<br/>					option = options[ i ];<br/><br/>					/* eslint-disable no-cond-assign */<br/><br/>					if ( option.selected =<br/>						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) &gt; -1<br/>					) {<br/>						optionSet = true;<br/>					}<br/><br/>					/* eslint-enable no-cond-assign */<br/>				}<br/><br/>				// Force browsers to behave consistently when non-matching value is set<br/>				if ( !optionSet ) {<br/>					elem.selectedIndex = -1;<br/>				}<br/>				return values;<br/>			}<br/>		}<br/>	}<br/>} );<br/><br/>// Radios and checkboxes getter/setter<br/>jQuery.each( [ "radio", "checkbox" ], function() {<br/>	jQuery.valHooks[ this ] = {<br/>		set: function( elem, value ) {<br/>			if ( Array.isArray( value ) ) {<br/>				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) &gt; -1 );<br/>			}<br/>		}<br/>	};<br/>	if ( !support.checkOn ) {<br/>		jQuery.valHooks[ this ].get = function( elem ) {<br/>			return elem.getAttribute( "value" ) === null ? "on" : elem.value;<br/>		};<br/>	}<br/>} );<br/><br/><br/><br/><br/>// Return jQuery for attributes-only inclusion<br/><br/><br/>support.focusin = "onfocusin" in window;<br/><br/><br/>var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,<br/>	stopPropagationCallback = function( e ) {<br/>		e.stopPropagation();<br/>	};<br/><br/>jQuery.extend( jQuery.event, {<br/><br/>	trigger: function( event, data, elem, onlyHandlers ) {<br/><br/>		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,<br/>			eventPath = [ elem || document ],<br/>			type = hasOwn.call( event, "type" ) ? event.type : event,<br/>			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];<br/><br/>		cur = lastElement = tmp = elem = elem || document;<br/><br/>		// Don't do events on text and comment nodes<br/>		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {<br/>			return;<br/>		}<br/><br/>		// focus/blur morphs to focusin/out; ensure we're not firing them right now<br/>		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {<br/>			return;<br/>		}<br/><br/>		if ( type.indexOf( "." ) &gt; -1 ) {<br/><br/>			// Namespaced trigger; create a regexp to match event type in handle()<br/>			namespaces = type.split( "." );<br/>			type = namespaces.shift();<br/>			namespaces.sort();<br/>		}<br/>		ontype = type.indexOf( ":" ) &lt; 0 &amp;&amp; "on" + type;<br/><br/>		// Caller can pass in a jQuery.Event object, Object, or just an event type string<br/>		event = event[ jQuery.expando ] ?<br/>			event :<br/>			new jQuery.Event( type, typeof event === "object" &amp;&amp; event );<br/><br/>		// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)<br/>		event.isTrigger = onlyHandlers ? 2 : 3;<br/>		event.namespace = namespaces.join( "." );<br/>		event.rnamespace = event.namespace ?<br/>			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :<br/>			null;<br/><br/>		// Clean up the event in case it is being reused<br/>		event.result = undefined;<br/>		if ( !event.target ) {<br/>			event.target = elem;<br/>		}<br/><br/>		// Clone any incoming data and prepend the event, creating the handler arg list<br/>		data = data == null ?<br/>			[ event ] :<br/>			jQuery.makeArray( data, [ event ] );<br/><br/>		// Allow special events to draw outside the lines<br/>		special = jQuery.event.special[ type ] || {};<br/>		if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {<br/>			return;<br/>		}<br/><br/>		// Determine event propagation path in advance, per W3C events spec (#9951)<br/>		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)<br/>		if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !isWindow( elem ) ) {<br/><br/>			bubbleType = special.delegateType || type;<br/>			if ( !rfocusMorph.test( bubbleType + type ) ) {<br/>				cur = cur.parentNode;<br/>			}<br/>			for ( ; cur; cur = cur.parentNode ) {<br/>				eventPath.push( cur );<br/>				tmp = cur;<br/>			}<br/><br/>			// Only add window if we got to document (e.g., not plain obj or detached DOM)<br/>			if ( tmp === ( elem.ownerDocument || document ) ) {<br/>				eventPath.push( tmp.defaultView || tmp.parentWindow || window );<br/>			}<br/>		}<br/><br/>		// Fire handlers on the event path<br/>		i = 0;<br/>		while ( ( cur = eventPath[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) {<br/>			lastElement = cur;<br/>			event.type = i &gt; 1 ?<br/>				bubbleType :<br/>				special.bindType || type;<br/><br/>			// jQuery handler<br/>			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &amp;&amp;<br/>				dataPriv.get( cur, "handle" );<br/>			if ( handle ) {<br/>				handle.apply( cur, data );<br/>			}<br/><br/>			// Native handler<br/>			handle = ontype &amp;&amp; cur[ ontype ];<br/>			if ( handle &amp;&amp; handle.apply &amp;&amp; acceptData( cur ) ) {<br/>				event.result = handle.apply( cur, data );<br/>				if ( event.result === false ) {<br/>					event.preventDefault();<br/>				}<br/>			}<br/>		}<br/>		event.type = type;<br/><br/>		// If nobody prevented the default action, do it now<br/>		if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {<br/><br/>			if ( ( !special._default ||<br/>				special._default.apply( eventPath.pop(), data ) === false ) &amp;&amp;<br/>				acceptData( elem ) ) {<br/><br/>				// Call a native DOM method on the target with the same name as the event.<br/>				// Don't do default actions on window, that's where global variables be (#6170)<br/>				if ( ontype &amp;&amp; isFunction( elem[ type ] ) &amp;&amp; !isWindow( elem ) ) {<br/><br/>					// Don't re-trigger an onFOO event when we call its FOO() method<br/>					tmp = elem[ ontype ];<br/><br/>					if ( tmp ) {<br/>						elem[ ontype ] = null;<br/>					}<br/><br/>					// Prevent re-triggering of the same event, since we already bubbled it above<br/>					jQuery.event.triggered = type;<br/><br/>					if ( event.isPropagationStopped() ) {<br/>						lastElement.addEventListener( type, stopPropagationCallback );<br/>					}<br/><br/>					elem[ type ]();<br/><br/>					if ( event.isPropagationStopped() ) {<br/>						lastElement.removeEventListener( type, stopPropagationCallback );<br/>					}<br/><br/>					jQuery.event.triggered = undefined;<br/><br/>					if ( tmp ) {<br/>						elem[ ontype ] = tmp;<br/>					}<br/>				}<br/>			}<br/>		}<br/><br/>		return event.result;<br/>	},<br/><br/>	// Piggyback on a donor event to simulate a different one<br/>	// Used only for `focus(in | out)` events<br/>	simulate: function( type, elem, event ) {<br/>		var e = jQuery.extend(<br/>			new jQuery.Event(),<br/>			event,<br/>			{<br/>				type: type,<br/>				isSimulated: true<br/>			}<br/>		);<br/><br/>		jQuery.event.trigger( e, null, elem );<br/>	}<br/><br/>} );<br/><br/>jQuery.fn.extend( {<br/><br/>	trigger: function( type, data ) {<br/>		return this.each( function() {<br/>			jQuery.event.trigger( type, data, this );<br/>		} );<br/>	},<br/>	triggerHandler: function( type, data ) {<br/>		var elem = this[ 0 ];<br/>		if ( elem ) {<br/>			return jQuery.event.trigger( type, data, elem, true );<br/>		}<br/>	}<br/>} );<br/><br/><br/>// Support: Firefox &lt;=44<br/>// Firefox doesn't have focus(in | out) events<br/>// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787<br/>//<br/>// Support: Chrome &lt;=48 - 49, Safari &lt;=9.0 - 9.1<br/>// focus(in | out) events fire after focus &amp; blur events,<br/>// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order<br/>// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857<br/>if ( !support.focusin ) {<br/>	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {<br/><br/>		// Attach a single capturing handler on the document while someone wants focusin/focusout<br/>		var handler = function( event ) {<br/>			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );<br/>		};<br/><br/>		jQuery.event.special[ fix ] = {<br/>			setup: function() {<br/>				var doc = this.ownerDocument || this,<br/>					attaches = dataPriv.access( doc, fix );<br/><br/>				if ( !attaches ) {<br/>					doc.addEventListener( orig, handler, true );<br/>				}<br/>				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );<br/>			},<br/>			teardown: function() {<br/>				var doc = this.ownerDocument || this,<br/>					attaches = dataPriv.access( doc, fix ) - 1;<br/><br/>				if ( !attaches ) {<br/>					doc.removeEventListener( orig, handler, true );<br/>					dataPriv.remove( doc, fix );<br/><br/>				} else {<br/>					dataPriv.access( doc, fix, attaches );<br/>				}<br/>			}<br/>		};<br/>	} );<br/>}<br/>var location = window.location;<br/><br/>var nonce = Date.now();<br/><br/>var rquery = ( /\?/ );<br/><br/><br/><br/>// Cross-browser xml parsing<br/>jQuery.parseXML = function( data ) {<br/>	var xml;<br/>	if ( !data || typeof data !== "string" ) {<br/>		return null;<br/>	}<br/><br/>	// Support: IE 9 - 11 only<br/>	// IE throws on parseFromString with invalid input.<br/>	try {<br/>		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );<br/>	} catch ( e ) {<br/>		xml = undefined;<br/>	}<br/><br/>	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {<br/>		jQuery.error( "Invalid XML: " + data );<br/>	}<br/>	return xml;<br/>};<br/><br/><br/>var<br/>	rbracket = /\[\]$/,<br/>	rCRLF = /\r?\n/g,<br/>	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,<br/>	rsubmittable = /^(?:input|select|textarea|keygen)/i;<br/><br/>function buildParams( prefix, obj, traditional, add ) {<br/>	var name;<br/><br/>	if ( Array.isArray( obj ) ) {<br/><br/>		// Serialize array item.<br/>		jQuery.each( obj, function( i, v ) {<br/>			if ( traditional || rbracket.test( prefix ) ) {<br/><br/>				// Treat each array item as a scalar.<br/>				add( prefix, v );<br/><br/>			} else {<br/><br/>				// Item is non-scalar (array or object), encode its numeric index.<br/>				buildParams(<br/>					prefix + "[" + ( typeof v === "object" &amp;&amp; v != null ? i : "" ) + "]",<br/>					v,<br/>					traditional,<br/>					add<br/>				);<br/>			}<br/>		} );<br/><br/>	} else if ( !traditional &amp;&amp; toType( obj ) === "object" ) {<br/><br/>		// Serialize object item.<br/>		for ( name in obj ) {<br/>			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );<br/>		}<br/><br/>	} else {<br/><br/>		// Serialize scalar item.<br/>		add( prefix, obj );<br/>	}<br/>}<br/><br/>// Serialize an array of form elements or a set of<br/>// key/values into a query string<br/>jQuery.param = function( a, traditional ) {<br/>	var prefix,<br/>		s = [],<br/>		add = function( key, valueOrFunction ) {<br/><br/>			// If value is a function, invoke it and use its return value<br/>			var value = isFunction( valueOrFunction ) ?<br/>				valueOrFunction() :<br/>				valueOrFunction;<br/><br/>			s[ s.length ] = encodeURIComponent( key ) + "=" +<br/>				encodeURIComponent( value == null ? "" : value );<br/>		};<br/><br/>	// If an array was passed in, assume that it is an array of form elements.<br/>	if ( Array.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {<br/><br/>		// Serialize the form elements<br/>		jQuery.each( a, function() {<br/>			add( this.name, this.value );<br/>		} );<br/><br/>	} else {<br/><br/>		// If traditional, encode the "old" way (the way 1.3.2 or older<br/>		// did it), otherwise encode params recursively.<br/>		for ( prefix in a ) {<br/>			buildParams( prefix, a[ prefix ], traditional, add );<br/>		}<br/>	}<br/><br/>	// Return the resulting serialization<br/>	return s.join( "&amp;" );<br/>};<br/><br/>jQuery.fn.extend( {<br/>	serialize: function() {<br/>		return jQuery.param( this.serializeArray() );<br/>	},<br/>	serializeArray: function() {<br/>		return this.map( function() {<br/><br/>			// Can add propHook for "elements" to filter or add form elements<br/>			var elements = jQuery.prop( this, "elements" );<br/>			return elements ? jQuery.makeArray( elements ) : this;<br/>		} )<br/>		.filter( function() {<br/>			var type = this.type;<br/><br/>			// Use .is( ":disabled" ) so that fieldset[disabled] works<br/>			return this.name &amp;&amp; !jQuery( this ).is( ":disabled" ) &amp;&amp;<br/>				rsubmittable.test( this.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp;<br/>				( this.checked || !rcheckableType.test( type ) );<br/>		} )<br/>		.map( function( i, elem ) {<br/>			var val = jQuery( this ).val();<br/><br/>			if ( val == null ) {<br/>				return null;<br/>			}<br/><br/>			if ( Array.isArray( val ) ) {<br/>				return jQuery.map( val, function( val ) {<br/>					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };<br/>				} );<br/>			}<br/><br/>			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };<br/>		} ).get();<br/>	}<br/>} );<br/><br/><br/>var<br/>	r20 = /%20/g,<br/>	rhash = /#.*$/,<br/>	rantiCache = /([?&amp;])_=[^&amp;]*/,<br/>	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,<br/><br/>	// #7653, #8125, #8152: local protocol detection<br/>	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,<br/>	rnoContent = /^(?:GET|HEAD)$/,<br/>	rprotocol = /^\/\//,<br/><br/>	/* Prefilters<br/>	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)<br/>	 * 2) These are called:<br/>	 *    - BEFORE asking for a transport<br/>	 *    - AFTER param serialization (s.data is a string if s.processData is true)<br/>	 * 3) key is the dataType<br/>	 * 4) the catchall symbol "*" can be used<br/>	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed<br/>	 */<br/>	prefilters = {},<br/><br/>	/* Transports bindings<br/>	 * 1) key is the dataType<br/>	 * 2) the catchall symbol "*" can be used<br/>	 * 3) selection will start with transport dataType and THEN go to "*" if needed<br/>	 */<br/>	transports = {},<br/><br/>	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression<br/>	allTypes = "*/".concat( "*" ),<br/><br/>	// Anchor tag for parsing the document origin<br/>	originAnchor = document.createElement( "a" );<br/>	originAnchor.href = location.href;<br/><br/>// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport<br/>function addToPrefiltersOrTransports( structure ) {<br/><br/>	// dataTypeExpression is optional and defaults to "*"<br/>	return function( dataTypeExpression, func ) {<br/><br/>		if ( typeof dataTypeExpression !== "string" ) {<br/>			func = dataTypeExpression;<br/>			dataTypeExpression = "*";<br/>		}<br/><br/>		var dataType,<br/>			i = 0,<br/>			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];<br/><br/>		if ( isFunction( func ) ) {<br/><br/>			// For each dataType in the dataTypeExpression<br/>			while ( ( dataType = dataTypes[ i++ ] ) ) {<br/><br/>				// Prepend if requested<br/>				if ( dataType[ 0 ] === "+" ) {<br/>					dataType = dataType.slice( 1 ) || "*";<br/>					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );<br/><br/>				// Otherwise append<br/>				} else {<br/>					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );<br/>				}<br/>			}<br/>		}<br/>	};<br/>}<br/><br/>// Base inspection function for prefilters and transports<br/>function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {<br/><br/>	var inspected = {},<br/>		seekingTransport = ( structure === transports );<br/><br/>	function inspect( dataType ) {<br/>		var selected;<br/>		inspected[ dataType ] = true;<br/>		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {<br/>			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );<br/>			if ( typeof dataTypeOrTransport === "string" &amp;&amp;<br/>				!seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) {<br/><br/>				options.dataTypes.unshift( dataTypeOrTransport );<br/>				inspect( dataTypeOrTransport );<br/>				return false;<br/>			} else if ( seekingTransport ) {<br/>				return !( selected = dataTypeOrTransport );<br/>			}<br/>		} );<br/>		return selected;<br/>	}<br/><br/>	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] &amp;&amp; inspect( "*" );<br/>}<br/><br/>// A special extend for ajax options<br/>// that takes "flat" options (not to be deep extended)<br/>// Fixes #9887<br/>function ajaxExtend( target, src ) {<br/>	var key, deep,<br/>		flatOptions = jQuery.ajaxSettings.flatOptions || {};<br/><br/>	for ( key in src ) {<br/>		if ( src[ key ] !== undefined ) {<br/>			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];<br/>		}<br/>	}<br/>	if ( deep ) {<br/>		jQuery.extend( true, target, deep );<br/>	}<br/><br/>	return target;<br/>}<br/><br/>/* Handles responses to an ajax request:<br/> * - finds the right dataType (mediates between content-type and expected dataType)<br/> * - returns the corresponding response<br/> */<br/>function ajaxHandleResponses( s, jqXHR, responses ) {<br/><br/>	var ct, type, finalDataType, firstDataType,<br/>		contents = s.contents,<br/>		dataTypes = s.dataTypes;<br/><br/>	// Remove auto dataType and get content-type in the process<br/>	while ( dataTypes[ 0 ] === "*" ) {<br/>		dataTypes.shift();<br/>		if ( ct === undefined ) {<br/>			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );<br/>		}<br/>	}<br/><br/>	// Check if we're dealing with a known content-type<br/>	if ( ct ) {<br/>		for ( type in contents ) {<br/>			if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {<br/>				dataTypes.unshift( type );<br/>				break;<br/>			}<br/>		}<br/>	}<br/><br/>	// Check to see if we have a response for the expected dataType<br/>	if ( dataTypes[ 0 ] in responses ) {<br/>		finalDataType = dataTypes[ 0 ];<br/>	} else {<br/><br/>		// Try convertible dataTypes<br/>		for ( type in responses ) {<br/>			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {<br/>				finalDataType = type;<br/>				break;<br/>			}<br/>			if ( !firstDataType ) {<br/>				firstDataType = type;<br/>			}<br/>		}<br/><br/>		// Or just use first one<br/>		finalDataType = finalDataType || firstDataType;<br/>	}<br/><br/>	// If we found a dataType<br/>	// We add the dataType to the list if needed<br/>	// and return the corresponding response<br/>	if ( finalDataType ) {<br/>		if ( finalDataType !== dataTypes[ 0 ] ) {<br/>			dataTypes.unshift( finalDataType );<br/>		}<br/>		return responses[ finalDataType ];<br/>	}<br/>}<br/><br/>/* Chain conversions given the request and the original response<br/> * Also sets the responseXXX fields on the jqXHR instance<br/> */<br/>function ajaxConvert( s, response, jqXHR, isSuccess ) {<br/>	var conv2, current, conv, tmp, prev,<br/>		converters = {},<br/><br/>		// Work with a copy of dataTypes in case we need to modify it for conversion<br/>		dataTypes = s.dataTypes.slice();<br/><br/>	// Create converters map with lowercased keys<br/>	if ( dataTypes[ 1 ] ) {<br/>		for ( conv in s.converters ) {<br/>			converters[ conv.toLowerCase() ] = s.converters[ conv ];<br/>		}<br/>	}<br/><br/>	current = dataTypes.shift();<br/><br/>	// Convert to each sequential dataType<br/>	while ( current ) {<br/><br/>		if ( s.responseFields[ current ] ) {<br/>			jqXHR[ s.responseFields[ current ] ] = response;<br/>		}<br/><br/>		// Apply the dataFilter if provided<br/>		if ( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) {<br/>			response = s.dataFilter( response, s.dataType );<br/>		}<br/><br/>		prev = current;<br/>		current = dataTypes.shift();<br/><br/>		if ( current ) {<br/><br/>			// There's only work to do if current dataType is non-auto<br/>			if ( current === "*" ) {<br/><br/>				current = prev;<br/><br/>			// Convert response if prev dataType is non-auto and differs from current<br/>			} else if ( prev !== "*" &amp;&amp; prev !== current ) {<br/><br/>				// Seek a direct converter<br/>				conv = converters[ prev + " " + current ] || converters[ "* " + current ];<br/><br/>				// If none found, seek a pair<br/>				if ( !conv ) {<br/>					for ( conv2 in converters ) {<br/><br/>						// If conv2 outputs current<br/>						tmp = conv2.split( " " );<br/>						if ( tmp[ 1 ] === current ) {<br/><br/>							// If prev can be converted to accepted input<br/>							conv = converters[ prev + " " + tmp[ 0 ] ] ||<br/>								converters[ "* " + tmp[ 0 ] ];<br/>							if ( conv ) {<br/><br/>								// Condense equivalence converters<br/>								if ( conv === true ) {<br/>									conv = converters[ conv2 ];<br/><br/>								// Otherwise, insert the intermediate dataType<br/>								} else if ( converters[ conv2 ] !== true ) {<br/>									current = tmp[ 0 ];<br/>									dataTypes.unshift( tmp[ 1 ] );<br/>								}<br/>								break;<br/>							}<br/>						}<br/>					}<br/>				}<br/><br/>				// Apply converter (if not an equivalence)<br/>				if ( conv !== true ) {<br/><br/>					// Unless errors are allowed to bubble, catch and return them<br/>					if ( conv &amp;&amp; s.throws ) {<br/>						response = conv( response );<br/>					} else {<br/>						try {<br/>							response = conv( response );<br/>						} catch ( e ) {<br/>							return {<br/>								state: "parsererror",<br/>								error: conv ? e : "No conversion from " + prev + " to " + current<br/>							};<br/>						}<br/>					}<br/>				}<br/>			}<br/>		}<br/>	}<br/><br/>	return { state: "success", data: response };<br/>}<br/><br/>jQuery.extend( {<br/><br/>	// Counter for holding the number of active queries<br/>	active: 0,<br/><br/>	// Last-Modified header cache for next request<br/>	lastModified: {},<br/>	etag: {},<br/><br/>	ajaxSettings: {<br/>		url: location.href,<br/>		type: "GET",<br/>		isLocal: rlocalProtocol.test( location.protocol ),<br/>		global: true,<br/>		processData: true,<br/>		async: true,<br/>		contentType: "application/x-www-form-urlencoded; charset=UTF-8",<br/><br/>		/*<br/>		timeout: 0,<br/>		data: null,<br/>		dataType: null,<br/>		username: null,<br/>		password: null,<br/>		cache: null,<br/>		throws: false,<br/>		traditional: false,<br/>		headers: {},<br/>		*/<br/><br/>		accepts: {<br/>			"*": allTypes,<br/>			text: "text/plain",<br/>			html: "text/html",<br/>			xml: "application/xml, text/xml",<br/>			json: "application/json, text/javascript"<br/>		},<br/><br/>		contents: {<br/>			xml: /\bxml\b/,<br/>			html: /\bhtml/,<br/>			json: /\bjson\b/<br/>		},<br/><br/>		responseFields: {<br/>			xml: "responseXML",<br/>			text: "responseText",<br/>			json: "responseJSON"<br/>		},<br/><br/>		// Data converters<br/>		// Keys separate source (or catchall "*") and destination types with a single space<br/>		converters: {<br/><br/>			// Convert anything to text<br/>			"* text": String,<br/><br/>			// Text to html (true = no transformation)<br/>			"text html": true,<br/><br/>			// Evaluate text as a json expression<br/>			"text json": JSON.parse,<br/><br/>			// Parse text as xml<br/>			"text xml": jQuery.parseXML<br/>		},<br/><br/>		// For options that shouldn't be deep extended:<br/>		// you can add your own custom options here if<br/>		// and when you create one that shouldn't be<br/>		// deep extended (see ajaxExtend)<br/>		flatOptions: {<br/>			url: true,<br/>			context: true<br/>		}<br/>	},<br/><br/>	// Creates a full fledged settings object into target<br/>	// with both ajaxSettings and settings fields.<br/>	// If target is omitted, writes into ajaxSettings.<br/>	ajaxSetup: function( target, settings ) {<br/>		return settings ?<br/><br/>			// Building a settings object<br/>			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :<br/><br/>			// Extending ajaxSettings<br/>			ajaxExtend( jQuery.ajaxSettings, target );<br/>	},<br/><br/>	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),<br/>	ajaxTransport: addToPrefiltersOrTransports( transports ),<br/><br/>	// Main method<br/>	ajax: function( url, options ) {<br/><br/>		// If url is an object, simulate pre-1.5 signature<br/>		if ( typeof url === "object" ) {<br/>			options = url;<br/>			url = undefined;<br/>		}<br/><br/>		// Force options to be an object<br/>		options = options || {};<br/><br/>		var transport,<br/><br/>			// URL without anti-cache param<br/>			cacheURL,<br/><br/>			// Response headers<br/>			responseHeadersString,<br/>			responseHeaders,<br/><br/>			// timeout handle<br/>			timeoutTimer,<br/><br/>			// Url cleanup var<br/>			urlAnchor,<br/><br/>			// Request state (becomes false upon send and true upon completion)<br/>			completed,<br/><br/>			// To know if global events are to be dispatched<br/>			fireGlobals,<br/><br/>			// Loop variable<br/>			i,<br/><br/>			// uncached part of the url<br/>			uncached,<br/><br/>			// Create the final options object<br/>			s = jQuery.ajaxSetup( {}, options ),<br/><br/>			// Callbacks context<br/>			callbackContext = s.context || s,<br/><br/>			// Context for global events is callbackContext if it is a DOM node or jQuery collection<br/>			globalEventContext = s.context &amp;&amp;<br/>				( callbackContext.nodeType || callbackContext.jquery ) ?<br/>					jQuery( callbackContext ) :<br/>					jQuery.event,<br/><br/>			// Deferreds<br/>			deferred = jQuery.Deferred(),<br/>			completeDeferred = jQuery.Callbacks( "once memory" ),<br/><br/>			// Status-dependent callbacks<br/>			statusCode = s.statusCode || {},<br/><br/>			// Headers (they are sent all at once)<br/>			requestHeaders = {},<br/>			requestHeadersNames = {},<br/><br/>			// Default abort message<br/>			strAbort = "canceled",<br/><br/>			// Fake xhr<br/>			jqXHR = {<br/>				readyState: 0,<br/><br/>				// Builds headers hashtable if needed<br/>				getResponseHeader: function( key ) {<br/>					var match;<br/>					if ( completed ) {<br/>						if ( !responseHeaders ) {<br/>							responseHeaders = {};<br/>							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {<br/>								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];<br/>							}<br/>						}<br/>						match = responseHeaders[ key.toLowerCase() ];<br/>					}<br/>					return match == null ? null : match;<br/>				},<br/><br/>				// Raw string<br/>				getAllResponseHeaders: function() {<br/>					return completed ? responseHeadersString : null;<br/>				},<br/><br/>				// Caches the header<br/>				setRequestHeader: function( name, value ) {<br/>					if ( completed == null ) {<br/>						name = requestHeadersNames[ name.toLowerCase() ] =<br/>							requestHeadersNames[ name.toLowerCase() ] || name;<br/>						requestHeaders[ name ] = value;<br/>					}<br/>					return this;<br/>				},<br/><br/>				// Overrides response content-type header<br/>				overrideMimeType: function( type ) {<br/>					if ( completed == null ) {<br/>						s.mimeType = type;<br/>					}<br/>					return this;<br/>				},<br/><br/>				// Status-dependent callbacks<br/>				statusCode: function( map ) {<br/>					var code;<br/>					if ( map ) {<br/>						if ( completed ) {<br/><br/>							// Execute the appropriate callbacks<br/>							jqXHR.always( map[ jqXHR.status ] );<br/>						} else {<br/><br/>							// Lazy-add the new callbacks in a way that preserves old ones<br/>							for ( code in map ) {<br/>								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];<br/>							}<br/>						}<br/>					}<br/>					return this;<br/>				},<br/><br/>				// Cancel the request<br/>				abort: function( statusText ) {<br/>					var finalText = statusText || strAbort;<br/>					if ( transport ) {<br/>						transport.abort( finalText );<br/>					}<br/>					done( 0, finalText );<br/>					return this;<br/>				}<br/>			};<br/><br/>		// Attach deferreds<br/>		deferred.promise( jqXHR );<br/><br/>		// Add protocol if not provided (prefilters might expect it)<br/>		// Handle falsy url in the settings object (#10093: consistency with old signature)<br/>		// We also use the url parameter if available<br/>		s.url = ( ( url || s.url || location.href ) + "" )<br/>			.replace( rprotocol, location.protocol + "//" );<br/><br/>		// Alias method option to type as per ticket #12004<br/>		s.type = options.method || options.type || s.method || s.type;<br/><br/>		// Extract dataTypes list<br/>		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];<br/><br/>		// A cross-domain request is in order when the origin doesn't match the current origin.<br/>		if ( s.crossDomain == null ) {<br/>			urlAnchor = document.createElement( "a" );<br/><br/>			// Support: IE &lt;=8 - 11, Edge 12 - 15<br/>			// IE throws exception on accessing the href property if url is malformed,<br/>			// e.g. http://example.com:80x/<br/>			try {<br/>				urlAnchor.href = s.url;<br/><br/>				// Support: IE &lt;=8 - 11 only<br/>				// Anchor's host property isn't correctly set when s.url is relative<br/>				urlAnchor.href = urlAnchor.href;<br/>				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==<br/>					urlAnchor.protocol + "//" + urlAnchor.host;<br/>			} catch ( e ) {<br/><br/>				// If there is an error parsing the URL, assume it is crossDomain,<br/>				// it can be rejected by the transport if it is invalid<br/>				s.crossDomain = true;<br/>			}<br/>		}<br/><br/>		// Convert data if not already a string<br/>		if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== "string" ) {<br/>			s.data = jQuery.param( s.data, s.traditional );<br/>		}<br/><br/>		// Apply prefilters<br/>		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );<br/><br/>		// If request was aborted inside a prefilter, stop there<br/>		if ( completed ) {<br/>			return jqXHR;<br/>		}<br/><br/>		// We can fire global events as of now if asked to<br/>		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)<br/>		fireGlobals = jQuery.event &amp;&amp; s.global;<br/><br/>		// Watch for a new set of requests<br/>		if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {<br/>			jQuery.event.trigger( "ajaxStart" );<br/>		}<br/><br/>		// Uppercase the type<br/>		s.type = s.type.toUpperCase();<br/><br/>		// Determine if request has content<br/>		s.hasContent = !rnoContent.test( s.type );<br/><br/>		// Save the URL in case we're toying with the If-Modified-Since<br/>		// and/or If-None-Match header later on<br/>		// Remove hash to simplify url manipulation<br/>		cacheURL = s.url.replace( rhash, "" );<br/><br/>		// More options handling for requests with no content<br/>		if ( !s.hasContent ) {<br/><br/>			// Remember the hash so we can put it back<br/>			uncached = s.url.slice( cacheURL.length );<br/><br/>			// If data is available and should be processed, append data to url<br/>			if ( s.data &amp;&amp; ( s.processData || typeof s.data === "string" ) ) {<br/>				cacheURL += ( rquery.test( cacheURL ) ? "&amp;" : "?" ) + s.data;<br/><br/>				// #9682: remove data so that it's not used in an eventual retry<br/>				delete s.data;<br/>			}<br/><br/>			// Add or update anti-cache param if needed<br/>			if ( s.cache === false ) {<br/>				cacheURL = cacheURL.replace( rantiCache, "$1" );<br/>				uncached = ( rquery.test( cacheURL ) ? "&amp;" : "?" ) + "_=" + ( nonce++ ) + uncached;<br/>			}<br/><br/>			// Put hash and anti-cache on the URL that will be requested (gh-1732)<br/>			s.url = cacheURL + uncached;<br/><br/>		// Change '%20' to '+' if this is encoded form body content (gh-2658)<br/>		} else if ( s.data &amp;&amp; s.processData &amp;&amp;<br/>			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {<br/>			s.data = s.data.replace( r20, "+" );<br/>		}<br/><br/>		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.<br/>		if ( s.ifModified ) {<br/>			if ( jQuery.lastModified[ cacheURL ] ) {<br/>				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );<br/>			}<br/>			if ( jQuery.etag[ cacheURL ] ) {<br/>				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );<br/>			}<br/>		}<br/><br/>		// Set the correct header, if data is being sent<br/>		if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {<br/>			jqXHR.setRequestHeader( "Content-Type", s.contentType );<br/>		}<br/><br/>		// Set the Accepts header for the server, depending on the dataType<br/>		jqXHR.setRequestHeader(<br/>			"Accept",<br/>			s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[ 0 ] ] ?<br/>				s.accepts[ s.dataTypes[ 0 ] ] +<br/>					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :<br/>				s.accepts[ "*" ]<br/>		);<br/><br/>		// Check for headers option<br/>		for ( i in s.headers ) {<br/>			jqXHR.setRequestHeader( i, s.headers[ i ] );<br/>		}<br/><br/>		// Allow custom headers/mimetypes and early abort<br/>		if ( s.beforeSend &amp;&amp;<br/>			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {<br/><br/>			// Abort if not done already and return<br/>			return jqXHR.abort();<br/>		}<br/><br/>		// Aborting is no longer a cancellation<br/>		strAbort = "abort";<br/><br/>		// Install callbacks on deferreds<br/>		completeDeferred.add( s.complete );<br/>		jqXHR.done( s.success );<br/>		jqXHR.fail( s.error );<br/><br/>		// Get transport<br/>		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );<br/><br/>		// If no transport, we auto-abort<br/>		if ( !transport ) {<br/>			done( -1, "No Transport" );<br/>		} else {<br/>			jqXHR.readyState = 1;<br/><br/>			// Send global event<br/>			if ( fireGlobals ) {<br/>				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );<br/>			}<br/><br/>			// If request was aborted inside ajaxSend, stop there<br/>			if ( completed ) {<br/>				return jqXHR;<br/>			}<br/><br/>			// Timeout<br/>			if ( s.async &amp;&amp; s.timeout &gt; 0 ) {<br/>				timeoutTimer = window.setTimeout( function() {<br/>					jqXHR.abort( "timeout" );<br/>				}, s.timeout );<br/>			}<br/><br/>			try {<br/>				completed = false;<br/>				transport.send( requestHeaders, done );<br/>			} catch ( e ) {<br/><br/>				// Rethrow post-completion exceptions<br/>				if ( completed ) {<br/>					throw e;<br/>				}<br/><br/>				// Propagate others as results<br/>				done( -1, e );<br/>			}<br/>		}<br/><br/>		// Callback for when everything is done<br/>		function done( status, nativeStatusText, responses, headers ) {<br/>			var isSuccess, success, error, response, modified,<br/>				statusText = nativeStatusText;<br/><br/>			// Ignore repeat invocations<br/>			if ( completed ) {<br/>				return;<br/>			}<br/><br/>			completed = true;<br/><br/>			// Clear timeout if it exists<br/>			if ( timeoutTimer ) {<br/>				window.clearTimeout( timeoutTimer );<br/>			}<br/><br/>			// Dereference transport for early garbage collection<br/>			// (no matter how long the jqXHR object will be used)<br/>			transport = undefined;<br/><br/>			// Cache response headers<br/>			responseHeadersString = headers || "";<br/><br/>			// Set readyState<br/>			jqXHR.readyState = status &gt; 0 ? 4 : 0;<br/><br/>			// Determine if successful<br/>			isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304;<br/><br/>			// Get response data<br/>			if ( responses ) {<br/>				response = ajaxHandleResponses( s, jqXHR, responses );<br/>			}<br/><br/>			// Convert no matter what (that way responseXXX fields are always set)<br/>			response = ajaxConvert( s, response, jqXHR, isSuccess );<br/><br/>			// If successful, handle type chaining<br/>			if ( isSuccess ) {<br/><br/>				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.<br/>				if ( s.ifModified ) {<br/>					modified = jqXHR.getResponseHeader( "Last-Modified" );<br/>					if ( modified ) {<br/>						jQuery.lastModified[ cacheURL ] = modified;<br/>					}<br/>					modified = jqXHR.getResponseHeader( "etag" );<br/>					if ( modified ) {<br/>						jQuery.etag[ cacheURL ] = modified;<br/>					}<br/>				}<br/><br/>				// if no content<br/>				if ( status === 204 || s.type === "HEAD" ) {<br/>					statusText = "nocontent";<br/><br/>				// if not modified<br/>				} else if ( status === 304 ) {<br/>					statusText = "notmodified";<br/><br/>				// If we have data, let's convert it<br/>				} else {<br/>					statusText = response.state;<br/>					success = response.data;<br/>					error = response.error;<br/>					isSuccess = !error;<br/>				}<br/>			} else {<br/><br/>				// Extract error from statusText and normalize for non-aborts<br/>				error = statusText;<br/>				if ( status || !statusText ) {<br/>					statusText = "error";<br/>					if ( status &lt; 0 ) {<br/>						status = 0;<br/>					}<br/>				}<br/>			}<br/><br/>			// Set data for the fake xhr object<br/>			jqXHR.status = status;<br/>			jqXHR.statusText = ( nativeStatusText || statusText ) + "";<br/><br/>			// Success/Error<br/>			if ( isSuccess ) {<br/>				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );<br/>			} else {<br/>				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );<br/>			}<br/><br/>			// Status-dependent callbacks<br/>			jqXHR.statusCode( statusCode );<br/>			statusCode = undefined;<br/><br/>			if ( fireGlobals ) {<br/>				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",<br/>					[ jqXHR, s, isSuccess ? success : error ] );<br/>			}<br/><br/>			// Complete<br/>			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );<br/><br/>			if ( fireGlobals ) {<br/>				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );<br/><br/>				// Handle the global AJAX counter<br/>				if ( !( --jQuery.active ) ) {<br/>					jQuery.event.trigger( "ajaxStop" );<br/>				}<br/>			}<br/>		}<br/><br/>		return jqXHR;<br/>	},<br/><br/>	getJSON: function( url, data, callback ) {<br/>		return jQuery.get( url, data, callback, "json" );<br/>	},<br/><br/>	getScript: function( url, callback ) {<br/>		return jQuery.get( url, undefined, callback, "script" );<br/>	}<br/>} );<br/><br/>jQuery.each( [ "get", "post" ], function( i, method ) {<br/>	jQuery[ method ] = function( url, data, callback, type ) {<br/><br/>		// Shift arguments if data argument was omitted<br/>		if ( isFunction( data ) ) {<br/>			type = type || callback;<br/>			callback = data;<br/>			data = undefined;<br/>		}<br/><br/>		// The url can be an options object (which then must have .url)<br/>		return jQuery.ajax( jQuery.extend( {<br/>			url: url,<br/>			type: method,<br/>			dataType: type,<br/>			data: data,<br/>			success: callback<br/>		}, jQuery.isPlainObject( url ) &amp;&amp; url ) );<br/>	};<br/>} );<br/><br/><br/>jQuery._evalUrl = function( url ) {<br/>	return jQuery.ajax( {<br/>		url: url,<br/><br/>		// Make this explicit, since user can override this through ajaxSetup (#11264)<br/>		type: "GET",<br/>		dataType: "script",<br/>		cache: true,<br/>		async: false,<br/>		global: false,<br/>		"throws": true<br/>	} );<br/>};<br/><br/><br/>jQuery.fn.extend( {<br/>	wrapAll: function( html ) {<br/>		var wrap;<br/><br/>		if ( this[ 0 ] ) {<br/>			if ( isFunction( html ) ) {<br/>				html = html.call( this[ 0 ] );<br/>			}<br/><br/>			// The elements to wrap the target around<br/>			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );<br/><br/>			if ( this[ 0 ].parentNode ) {<br/>				wrap.insertBefore( this[ 0 ] );<br/>			}<br/><br/>			wrap.map( function() {<br/>				var elem = this;<br/><br/>				while ( elem.firstElementChild ) {<br/>					elem = elem.firstElementChild;<br/>				}<br/><br/>				return elem;<br/>			} ).append( this );<br/>		}<br/><br/>		return this;<br/>	},<br/><br/>	wrapInner: function( html ) {<br/>		if ( isFunction( html ) ) {<br/>			return this.each( function( i ) {<br/>				jQuery( this ).wrapInner( html.call( this, i ) );<br/>			} );<br/>		}<br/><br/>		return this.each( function() {<br/>			var self = jQuery( this ),<br/>				contents = self.contents();<br/><br/>			if ( contents.length ) {<br/>				contents.wrapAll( html );<br/><br/>			} else {<br/>				self.append( html );<br/>			}<br/>		} );<br/>	},<br/><br/>	wrap: function( html ) {<br/>		var htmlIsFunction = isFunction( html );<br/><br/>		return this.each( function( i ) {<br/>			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );<br/>		} );<br/>	},<br/><br/>	unwrap: function( selector ) {<br/>		this.parent( selector ).not( "body" ).each( function() {<br/>			jQuery( this ).replaceWith( this.childNodes );<br/>		} );<br/>		return this;<br/>	}<br/>} );<br/><br/><br/>jQuery.expr.pseudos.hidden = function( elem ) {<br/>	return !jQuery.expr.pseudos.visible( elem );<br/>};<br/>jQuery.expr.pseudos.visible = function( elem ) {<br/>	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );<br/>};<br/><br/><br/><br/><br/>jQuery.ajaxSettings.xhr = function() {<br/>	try {<br/>		return new window.XMLHttpRequest();<br/>	} catch ( e ) {}<br/>};<br/><br/>var xhrSuccessStatus = {<br/><br/>		// File protocol always yields status code 0, assume 200<br/>		0: 200,<br/><br/>		// Support: IE &lt;=9 only<br/>		// #1450: sometimes IE returns 1223 when it should be 204<br/>		1223: 204<br/>	},<br/>	xhrSupported = jQuery.ajaxSettings.xhr();<br/><br/>support.cors = !!xhrSupported &amp;&amp; ( "withCredentials" in xhrSupported );<br/>support.ajax = xhrSupported = !!xhrSupported;<br/><br/>jQuery.ajaxTransport( function( options ) {<br/>	var callback, errorCallback;<br/><br/>	// Cross domain only allowed if supported through XMLHttpRequest<br/>	if ( support.cors || xhrSupported &amp;&amp; !options.crossDomain ) {<br/>		return {<br/>			send: function( headers, complete ) {<br/>				var i,<br/>					xhr = options.xhr();<br/><br/>				xhr.open(<br/>					options.type,<br/>					options.url,<br/>					options.async,<br/>					options.username,<br/>					options.password<br/>				);<br/><br/>				// Apply custom fields if provided<br/>				if ( options.xhrFields ) {<br/>					for ( i in options.xhrFields ) {<br/>						xhr[ i ] = options.xhrFields[ i ];<br/>					}<br/>				}<br/><br/>				// Override mime type if needed<br/>				if ( options.mimeType &amp;&amp; xhr.overrideMimeType ) {<br/>					xhr.overrideMimeType( options.mimeType );<br/>				}<br/><br/>				// X-Requested-With header<br/>				// For cross-domain requests, seeing as conditions for a preflight are<br/>				// akin to a jigsaw puzzle, we simply never set it to be sure.<br/>				// (it can always be set on a per-request basis or even using ajaxSetup)<br/>				// For same-domain requests, won't change header if already provided.<br/>				if ( !options.crossDomain &amp;&amp; !headers[ "X-Requested-With" ] ) {<br/>					headers[ "X-Requested-With" ] = "XMLHttpRequest";<br/>				}<br/><br/>				// Set headers<br/>				for ( i in headers ) {<br/>					xhr.setRequestHeader( i, headers[ i ] );<br/>				}<br/><br/>				// Callback<br/>				callback = function( type ) {<br/>					return function() {<br/>						if ( callback ) {<br/>							callback = errorCallback = xhr.onload =<br/>								xhr.onerror = xhr.onabort = xhr.ontimeout =<br/>									xhr.onreadystatechange = null;<br/><br/>							if ( type === "abort" ) {<br/>								xhr.abort();<br/>							} else if ( type === "error" ) {<br/><br/>								// Support: IE &lt;=9 only<br/>								// On a manual native abort, IE9 throws<br/>								// errors on any property access that is not readyState<br/>								if ( typeof xhr.status !== "number" ) {<br/>									complete( 0, "error" );<br/>								} else {<br/>									complete(<br/><br/>										// File: protocol always yields status 0; see #8605, #14207<br/>										xhr.status,<br/>										xhr.statusText<br/>									);<br/>								}<br/>							} else {<br/>								complete(<br/>									xhrSuccessStatus[ xhr.status ] || xhr.status,<br/>									xhr.statusText,<br/><br/>									// Support: IE &lt;=9 only<br/>									// IE9 has no XHR2 but throws on binary (trac-11426)<br/>									// For XHR2 non-text, let the caller handle it (gh-2498)<br/>									( xhr.responseType || "text" ) !== "text"  ||<br/>									typeof xhr.responseText !== "string" ?<br/>										{ binary: xhr.response } :<br/>										{ text: xhr.responseText },<br/>									xhr.getAllResponseHeaders()<br/>								);<br/>							}<br/>						}<br/>					};<br/>				};<br/><br/>				// Listen to events<br/>				xhr.onload = callback();<br/>				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );<br/><br/>				// Support: IE 9 only<br/>				// Use onreadystatechange to replace onabort<br/>				// to handle uncaught aborts<br/>				if ( xhr.onabort !== undefined ) {<br/>					xhr.onabort = errorCallback;<br/>				} else {<br/>					xhr.onreadystatechange = function() {<br/><br/>						// Check readyState before timeout as it changes<br/>						if ( xhr.readyState === 4 ) {<br/><br/>							// Allow onerror to be called first,<br/>							// but that will not handle a native abort<br/>							// Also, save errorCallback to a variable<br/>							// as xhr.onerror cannot be accessed<br/>							window.setTimeout( function() {<br/>								if ( callback ) {<br/>									errorCallback();<br/>								}<br/>							} );<br/>						}<br/>					};<br/>				}<br/><br/>				// Create the abort callback<br/>				callback = callback( "abort" );<br/><br/>				try {<br/><br/>					// Do send the request (this may raise an exception)<br/>					xhr.send( options.hasContent &amp;&amp; options.data || null );<br/>				} catch ( e ) {<br/><br/>					// #14683: Only rethrow if this hasn't been notified as an error yet<br/>					if ( callback ) {<br/>						throw e;<br/>					}<br/>				}<br/>			},<br/><br/>			abort: function() {<br/>				if ( callback ) {<br/>					callback();<br/>				}<br/>			}<br/>		};<br/>	}<br/>} );<br/><br/><br/><br/><br/>// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)<br/>jQuery.ajaxPrefilter( function( s ) {<br/>	if ( s.crossDomain ) {<br/>		s.contents.script = false;<br/>	}<br/>} );<br/><br/>// Install script dataType<br/>jQuery.ajaxSetup( {<br/>	accepts: {<br/>		script: "text/javascript, application/javascript, " +<br/>			"application/ecmascript, application/x-ecmascript"<br/>	},<br/>	contents: {<br/>		script: /\b(?:java|ecma)script\b/<br/>	},<br/>	converters: {<br/>		"text script": function( text ) {<br/>			jQuery.globalEval( text );<br/>			return text;<br/>		}<br/>	}<br/>} );<br/><br/>// Handle cache's special case and crossDomain<br/>jQuery.ajaxPrefilter( "script", function( s ) {<br/>	if ( s.cache === undefined ) {<br/>		s.cache = false;<br/>	}<br/>	if ( s.crossDomain ) {<br/>		s.type = "GET";<br/>	}<br/>} );<br/><br/>// Bind script tag hack transport<br/>jQuery.ajaxTransport( "script", function( s ) {<br/><br/>	// This transport only deals with cross domain requests<br/>	if ( s.crossDomain ) {<br/>		var script, callback;<br/>		return {<br/>			send: function( _, complete ) {<br/>				script = jQuery( "&lt;script&gt;" ).prop( {<br/>					charset: s.scriptCharset,<br/>					src: s.url<br/>				} ).on(<br/>					"load error",<br/>					callback = function( evt ) {<br/>						script.remove();<br/>						callback = null;<br/>						if ( evt ) {<br/>							complete( evt.type === "error" ? 404 : 200, evt.type );<br/>						}<br/>					}<br/>				);<br/><br/>				// Use native DOM manipulation to avoid our domManip AJAX trickery<br/>				document.head.appendChild( script[ 0 ] );<br/>			},<br/>			abort: function() {<br/>				if ( callback ) {<br/>					callback();<br/>				}<br/>			}<br/>		};<br/>	}<br/>} );<br/><br/><br/><br/><br/>var oldCallbacks = [],<br/>	rjsonp = /(=)\?(?=&amp;|$)|\?\?/;<br/><br/>// Default jsonp settings<br/>jQuery.ajaxSetup( {<br/>	jsonp: "callback",<br/>	jsonpCallback: function() {<br/>		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );<br/>		this[ callback ] = true;<br/>		return callback;<br/>	}<br/>} );<br/><br/>// Detect, normalize options and install callbacks for jsonp requests<br/>jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {<br/><br/>	var callbackName, overwritten, responseContainer,<br/>		jsonProp = s.jsonp !== false &amp;&amp; ( rjsonp.test( s.url ) ?<br/>			"url" :<br/>			typeof s.data === "string" &amp;&amp;<br/>				( s.contentType || "" )<br/>					.indexOf( "application/x-www-form-urlencoded" ) === 0 &amp;&amp;<br/>				rjsonp.test( s.data ) &amp;&amp; "data"<br/>		);<br/><br/>	// Handle iff the expected data type is "jsonp" or we have a parameter to set<br/>	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {<br/><br/>		// Get callback name, remembering preexisting value associated with it<br/>		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?<br/>			s.jsonpCallback() :<br/>			s.jsonpCallback;<br/><br/>		// Insert callback into url or form data<br/>		if ( jsonProp ) {<br/>			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );<br/>		} else if ( s.jsonp !== false ) {<br/>			s.url += ( rquery.test( s.url ) ? "&amp;" : "?" ) + s.jsonp + "=" + callbackName;<br/>		}<br/><br/>		// Use data converter to retrieve json after script execution<br/>		s.converters[ "script json" ] = function() {<br/>			if ( !responseContainer ) {<br/>				jQuery.error( callbackName + " was not called" );<br/>			}<br/>			return responseContainer[ 0 ];<br/>		};<br/><br/>		// Force json dataType<br/>		s.dataTypes[ 0 ] = "json";<br/><br/>		// Install callback<br/>		overwritten = window[ callbackName ];<br/>		window[ callbackName ] = function() {<br/>			responseContainer = arguments;<br/>		};<br/><br/>		// Clean-up function (fires after converters)<br/>		jqXHR.always( function() {<br/><br/>			// If previous value didn't exist - remove it<br/>			if ( overwritten === undefined ) {<br/>				jQuery( window ).removeProp( callbackName );<br/><br/>			// Otherwise restore preexisting value<br/>			} else {<br/>				window[ callbackName ] = overwritten;<br/>			}<br/><br/>			// Save back as free<br/>			if ( s[ callbackName ] ) {<br/><br/>				// Make sure that re-using the options doesn't screw things around<br/>				s.jsonpCallback = originalSettings.jsonpCallback;<br/><br/>				// Save the callback name for future use<br/>				oldCallbacks.push( callbackName );<br/>			}<br/><br/>			// Call if it was a function and we have a response<br/>			if ( responseContainer &amp;&amp; isFunction( overwritten ) ) {<br/>				overwritten( responseContainer[ 0 ] );<br/>			}<br/><br/>			responseContainer = overwritten = undefined;<br/>		} );<br/><br/>		// Delegate to script<br/>		return "script";<br/>	}<br/>} );<br/><br/><br/><br/><br/>// Support: Safari 8 only<br/>// In Safari 8 documents created via document.implementation.createHTMLDocument<br/>// collapse sibling forms: the second one becomes a child of the first one.<br/>// Because of that, this security measure has to be disabled in Safari 8.<br/>// https://bugs.webkit.org/show_bug.cgi?id=137337<br/>support.createHTMLDocument = ( function() {<br/>	var body = document.implementation.createHTMLDocument( "" ).body;<br/>	body.innerHTML = "&lt;form&gt;&lt;/form&gt;&lt;form&gt;&lt;/form&gt;";<br/>	return body.childNodes.length === 2;<br/>} )();<br/><br/><br/>// Argument "data" should be string of html<br/>// context (optional): If specified, the fragment will be created in this context,<br/>// defaults to document<br/>// keepScripts (optional): If true, will include scripts passed in the html string<br/>jQuery.parseHTML = function( data, context, keepScripts ) {<br/>	if ( typeof data !== "string" ) {<br/>		return [];<br/>	}<br/>	if ( typeof context === "boolean" ) {<br/>		keepScripts = context;<br/>		context = false;<br/>	}<br/><br/>	var base, parsed, scripts;<br/><br/>	if ( !context ) {<br/><br/>		// Stop scripts or inline event handlers from being executed immediately<br/>		// by using document.implementation<br/>		if ( support.createHTMLDocument ) {<br/>			context = document.implementation.createHTMLDocument( "" );<br/><br/>			// Set the base href for the created document<br/>			// so any parsed elements with URLs<br/>			// are based on the document's URL (gh-2965)<br/>			base = context.createElement( "base" );<br/>			base.href = document.location.href;<br/>			context.head.appendChild( base );<br/>		} else {<br/>			context = document;<br/>		}<br/>	}<br/><br/>	parsed = rsingleTag.exec( data );<br/>	scripts = !keepScripts &amp;&amp; [];<br/><br/>	// Single tag<br/>	if ( parsed ) {<br/>		return [ context.createElement( parsed[ 1 ] ) ];<br/>	}<br/><br/>	parsed = buildFragment( [ data ], context, scripts );<br/><br/>	if ( scripts &amp;&amp; scripts.length ) {<br/>		jQuery( scripts ).remove();<br/>	}<br/><br/>	return jQuery.merge( [], parsed.childNodes );<br/>};<br/><br/><br/>/**<br/> * Load a url into a page<br/> */<br/>jQuery.fn.load = function( url, params, callback ) {<br/>	var selector, type, response,<br/>		self = this,<br/>		off = url.indexOf( " " );<br/><br/>	if ( off &gt; -1 ) {<br/>		selector = stripAndCollapse( url.slice( off ) );<br/>		url = url.slice( 0, off );<br/>	}<br/><br/>	// If it's a function<br/>	if ( isFunction( params ) ) {<br/><br/>		// We assume that it's the callback<br/>		callback = params;<br/>		params = undefined;<br/><br/>	// Otherwise, build a param string<br/>	} else if ( params &amp;&amp; typeof params === "object" ) {<br/>		type = "POST";<br/>	}<br/><br/>	// If we have elements to modify, make the request<br/>	if ( self.length &gt; 0 ) {<br/>		jQuery.ajax( {<br/>			url: url,<br/><br/>			// If "type" variable is undefined, then "GET" method will be used.<br/>			// Make value of this field explicit since<br/>			// user can override it through ajaxSetup method<br/>			type: type || "GET",<br/>			dataType: "html",<br/>			data: params<br/>		} ).done( function( responseText ) {<br/><br/>			// Save response for use in complete callback<br/>			response = arguments;<br/><br/>			self.html( selector ?<br/><br/>				// If a selector was specified, locate the right elements in a dummy div<br/>				// Exclude scripts to avoid IE 'Permission Denied' errors<br/>				jQuery( "&lt;div&gt;" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :<br/><br/>				// Otherwise use the full result<br/>				responseText );<br/><br/>		// If the request succeeds, this function gets "data", "status", "jqXHR"<br/>		// but they are ignored because response was set above.<br/>		// If it fails, this function gets "jqXHR", "status", "error"<br/>		} ).always( callback &amp;&amp; function( jqXHR, status ) {<br/>			self.each( function() {<br/>				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );<br/>			} );<br/>		} );<br/>	}<br/><br/>	return this;<br/>};<br/><br/><br/><br/><br/>// Attach a bunch of functions for handling common AJAX events<br/>jQuery.each( [<br/>	"ajaxStart",<br/>	"ajaxStop",<br/>	"ajaxComplete",<br/>	"ajaxError",<br/>	"ajaxSuccess",<br/>	"ajaxSend"<br/>], function( i, type ) {<br/>	jQuery.fn[ type ] = function( fn ) {<br/>		return this.on( type, fn );<br/>	};<br/>} );<br/><br/><br/><br/><br/>jQuery.expr.pseudos.animated = function( elem ) {<br/>	return jQuery.grep( jQuery.timers, function( fn ) {<br/>		return elem === fn.elem;<br/>	} ).length;<br/>};<br/><br/><br/><br/><br/>jQuery.offset = {<br/>	setOffset: function( elem, options, i ) {<br/>		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,<br/>			position = jQuery.css( elem, "position" ),<br/>			curElem = jQuery( elem ),<br/>			props = {};<br/><br/>		// Set position first, in-case top/left are set even on static elem<br/>		if ( position === "static" ) {<br/>			elem.style.position = "relative";<br/>		}<br/><br/>		curOffset = curElem.offset();<br/>		curCSSTop = jQuery.css( elem, "top" );<br/>		curCSSLeft = jQuery.css( elem, "left" );<br/>		calculatePosition = ( position === "absolute" || position === "fixed" ) &amp;&amp;<br/>			( curCSSTop + curCSSLeft ).indexOf( "auto" ) &gt; -1;<br/><br/>		// Need to be able to calculate position if either<br/>		// top or left is auto and position is either absolute or fixed<br/>		if ( calculatePosition ) {<br/>			curPosition = curElem.position();<br/>			curTop = curPosition.top;<br/>			curLeft = curPosition.left;<br/><br/>		} else {<br/>			curTop = parseFloat( curCSSTop ) || 0;<br/>			curLeft = parseFloat( curCSSLeft ) || 0;<br/>		}<br/><br/>		if ( isFunction( options ) ) {<br/><br/>			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)<br/>			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );<br/>		}<br/><br/>		if ( options.top != null ) {<br/>			props.top = ( options.top - curOffset.top ) + curTop;<br/>		}<br/>		if ( options.left != null ) {<br/>			props.left = ( options.left - curOffset.left ) + curLeft;<br/>		}<br/><br/>		if ( "using" in options ) {<br/>			options.using.call( elem, props );<br/><br/>		} else {<br/>			curElem.css( props );<br/>		}<br/>	}<br/>};<br/><br/>jQuery.fn.extend( {<br/><br/>	// offset() relates an element's border box to the document origin<br/>	offset: function( options ) {<br/><br/>		// Preserve chaining for setter<br/>		if ( arguments.length ) {<br/>			return options === undefined ?<br/>				this :<br/>				this.each( function( i ) {<br/>					jQuery.offset.setOffset( this, options, i );<br/>				} );<br/>		}<br/><br/>		var rect, win,<br/>			elem = this[ 0 ];<br/><br/>		if ( !elem ) {<br/>			return;<br/>		}<br/><br/>		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)<br/>		// Support: IE &lt;=11 only<br/>		// Running getBoundingClientRect on a<br/>		// disconnected node in IE throws an error<br/>		if ( !elem.getClientRects().length ) {<br/>			return { top: 0, left: 0 };<br/>		}<br/><br/>		// Get document-relative position by adding viewport scroll to viewport-relative gBCR<br/>		rect = elem.getBoundingClientRect();<br/>		win = elem.ownerDocument.defaultView;<br/>		return {<br/>			top: rect.top + win.pageYOffset,<br/>			left: rect.left + win.pageXOffset<br/>		};<br/>	},<br/><br/>	// position() relates an element's margin box to its offset parent's padding box<br/>	// This corresponds to the behavior of CSS absolute positioning<br/>	position: function() {<br/>		if ( !this[ 0 ] ) {<br/>			return;<br/>		}<br/><br/>		var offsetParent, offset, doc,<br/>			elem = this[ 0 ],<br/>			parentOffset = { top: 0, left: 0 };<br/><br/>		// position:fixed elements are offset from the viewport, which itself always has zero offset<br/>		if ( jQuery.css( elem, "position" ) === "fixed" ) {<br/><br/>			// Assume position:fixed implies availability of getBoundingClientRect<br/>			offset = elem.getBoundingClientRect();<br/><br/>		} else {<br/>			offset = this.offset();<br/><br/>			// Account for the *real* offset parent, which can be the document or its root element<br/>			// when a statically positioned element is identified<br/>			doc = elem.ownerDocument;<br/>			offsetParent = elem.offsetParent || doc.documentElement;<br/>			while ( offsetParent &amp;&amp;<br/>				( offsetParent === doc.body || offsetParent === doc.documentElement ) &amp;&amp;<br/>				jQuery.css( offsetParent, "position" ) === "static" ) {<br/><br/>				offsetParent = offsetParent.parentNode;<br/>			}<br/>			if ( offsetParent &amp;&amp; offsetParent !== elem &amp;&amp; offsetParent.nodeType === 1 ) {<br/><br/>				// Incorporate borders into its offset, since they are outside its content origin<br/>				parentOffset = jQuery( offsetParent ).offset();<br/>				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );<br/>				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );<br/>			}<br/>		}<br/><br/>		// Subtract parent offsets and element margins<br/>		return {<br/>			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),<br/>			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )<br/>		};<br/>	},<br/><br/>	// This method will return documentElement in the following cases:<br/>	// 1) For the element inside the iframe without offsetParent, this method will return<br/>	//    documentElement of the parent window<br/>	// 2) For the hidden or detached element<br/>	// 3) For body or html element, i.e. in case of the html node - it will return itself<br/>	//<br/>	// but those exceptions were never presented as a real life use-cases<br/>	// and might be considered as more preferable results.<br/>	//<br/>	// This logic, however, is not guaranteed and can change at any point in the future<br/>	offsetParent: function() {<br/>		return this.map( function() {<br/>			var offsetParent = this.offsetParent;<br/><br/>			while ( offsetParent &amp;&amp; jQuery.css( offsetParent, "position" ) === "static" ) {<br/>				offsetParent = offsetParent.offsetParent;<br/>			}<br/><br/>			return offsetParent || documentElement;<br/>		} );<br/>	}<br/>} );<br/><br/>// Create scrollLeft and scrollTop methods<br/>jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {<br/>	var top = "pageYOffset" === prop;<br/><br/>	jQuery.fn[ method ] = function( val ) {<br/>		return access( this, function( elem, method, val ) {<br/><br/>			// Coalesce documents and windows<br/>			var win;<br/>			if ( isWindow( elem ) ) {<br/>				win = elem;<br/>			} else if ( elem.nodeType === 9 ) {<br/>				win = elem.defaultView;<br/>			}<br/><br/>			if ( val === undefined ) {<br/>				return win ? win[ prop ] : elem[ method ];<br/>			}<br/><br/>			if ( win ) {<br/>				win.scrollTo(<br/>					!top ? val : win.pageXOffset,<br/>					top ? val : win.pageYOffset<br/>				);<br/><br/>			} else {<br/>				elem[ method ] = val;<br/>			}<br/>		}, method, val, arguments.length );<br/>	};<br/>} );<br/><br/>// Support: Safari &lt;=7 - 9.1, Chrome &lt;=37 - 49<br/>// Add the top/left cssHooks using jQuery.fn.position<br/>// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084<br/>// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347<br/>// getComputedStyle returns percent when specified for top/left/bottom/right;<br/>// rather than make the css module depend on the offset module, just check for it here<br/>jQuery.each( [ "top", "left" ], function( i, prop ) {<br/>	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,<br/>		function( elem, computed ) {<br/>			if ( computed ) {<br/>				computed = curCSS( elem, prop );<br/><br/>				// If curCSS returns percentage, fallback to offset<br/>				return rnumnonpx.test( computed ) ?<br/>					jQuery( elem ).position()[ prop ] + "px" :<br/>					computed;<br/>			}<br/>		}<br/>	);<br/>} );<br/><br/><br/>// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods<br/>jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {<br/>	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },<br/>		function( defaultExtra, funcName ) {<br/><br/>		// Margin is only for outerHeight, outerWidth<br/>		jQuery.fn[ funcName ] = function( margin, value ) {<br/>			var chainable = arguments.length &amp;&amp; ( defaultExtra || typeof margin !== "boolean" ),<br/>				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );<br/><br/>			return access( this, function( elem, type, value ) {<br/>				var doc;<br/><br/>				if ( isWindow( elem ) ) {<br/><br/>					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)<br/>					return funcName.indexOf( "outer" ) === 0 ?<br/>						elem[ "inner" + name ] :<br/>						elem.document.documentElement[ "client" + name ];<br/>				}<br/><br/>				// Get document width or height<br/>				if ( elem.nodeType === 9 ) {<br/>					doc = elem.documentElement;<br/><br/>					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],<br/>					// whichever is greatest<br/>					return Math.max(<br/>						elem.body[ "scroll" + name ], doc[ "scroll" + name ],<br/>						elem.body[ "offset" + name ], doc[ "offset" + name ],<br/>						doc[ "client" + name ]<br/>					);<br/>				}<br/><br/>				return value === undefined ?<br/><br/>					// Get width or height on the element, requesting but not forcing parseFloat<br/>					jQuery.css( elem, type, extra ) :<br/><br/>					// Set width or height on the element<br/>					jQuery.style( elem, type, value, extra );<br/>			}, type, chainable ? margin : undefined, chainable );<br/>		};<br/>	} );<br/>} );<br/><br/><br/>jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +<br/>	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +<br/>	"change select submit keydown keypress keyup contextmenu" ).split( " " ),<br/>	function( i, name ) {<br/><br/>	// Handle event binding<br/>	jQuery.fn[ name ] = function( data, fn ) {<br/>		return arguments.length &gt; 0 ?<br/>			this.on( name, null, data, fn ) :<br/>			this.trigger( name );<br/>	};<br/>} );<br/><br/>jQuery.fn.extend( {<br/>	hover: function( fnOver, fnOut ) {<br/>		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );<br/>	}<br/>} );<br/><br/><br/><br/><br/>jQuery.fn.extend( {<br/><br/>	bind: function( types, data, fn ) {<br/>		return this.on( types, null, data, fn );<br/>	},<br/>	unbind: function( types, fn ) {<br/>		return this.off( types, null, fn );<br/>	},<br/><br/>	delegate: function( selector, types, data, fn ) {<br/>		return this.on( types, selector, data, fn );<br/>	},<br/>	undelegate: function( selector, types, fn ) {<br/><br/>		// ( namespace ) or ( selector, types [, fn] )<br/>		return arguments.length === 1 ?<br/>			this.off( selector, "**" ) :<br/>			this.off( types, selector || "**", fn );<br/>	}<br/>} );<br/><br/>// Bind a function to a context, optionally partially applying any<br/>// arguments.<br/>// jQuery.proxy is deprecated to promote standards (specifically Function#bind)<br/>// However, it is not slated for removal any time soon<br/>jQuery.proxy = function( fn, context ) {<br/>	var tmp, args, proxy;<br/><br/>	if ( typeof context === "string" ) {<br/>		tmp = fn[ context ];<br/>		context = fn;<br/>		fn = tmp;<br/>	}<br/><br/>	// Quick check to determine if target is callable, in the spec<br/>	// this throws a TypeError, but we will just return undefined.<br/>	if ( !isFunction( fn ) ) {<br/>		return undefined;<br/>	}<br/><br/>	// Simulated bind<br/>	args = slice.call( arguments, 2 );<br/>	proxy = function() {<br/>		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );<br/>	};<br/><br/>	// Set the guid of unique handler to the same of original handler, so it can be removed<br/>	proxy.guid = fn.guid = fn.guid || jQuery.guid++;<br/><br/>	return proxy;<br/>};<br/><br/>jQuery.holdReady = function( hold ) {<br/>	if ( hold ) {<br/>		jQuery.readyWait++;<br/>	} else {<br/>		jQuery.ready( true );<br/>	}<br/>};<br/>jQuery.isArray = Array.isArray;<br/>jQuery.parseJSON = JSON.parse;<br/>jQuery.nodeName = nodeName;<br/>jQuery.isFunction = isFunction;<br/>jQuery.isWindow = isWindow;<br/>jQuery.camelCase = camelCase;<br/>jQuery.type = toType;<br/><br/>jQuery.now = Date.now;<br/><br/>jQuery.isNumeric = function( obj ) {<br/><br/>	// As of jQuery 3.0, isNumeric is limited to<br/>	// strings and numbers (primitives or objects)<br/>	// that can be coerced to finite numbers (gh-2662)<br/>	var type = jQuery.type( obj );<br/>	return ( type === "number" || type === "string" ) &amp;&amp;<br/><br/>		// parseFloat NaNs numeric-cast false positives ("")<br/>		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")<br/>		// subtraction forces infinities to NaN<br/>		!isNaN( obj - parseFloat( obj ) );<br/>};<br/><br/><br/><br/><br/>// Register as a named AMD module, since jQuery can be concatenated with other<br/>// files that may use define, but not via a proper concatenation script that<br/>// understands anonymous AMD modules. A named AMD is safest and most robust<br/>// way to register. Lowercase jquery is used because AMD module names are<br/>// derived from file names, and jQuery is normally delivered in a lowercase<br/>// file name. Do this after creating the global so that if an AMD module wants<br/>// to call noConflict to hide this version of jQuery, it will work.<br/><br/>// Note that for maximum portability, libraries that are not jQuery should<br/>// declare themselves as anonymous modules, and avoid setting a global if an<br/>// AMD loader is present. jQuery is a special case. For more information, see<br/>// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon<br/><br/>if ( typeof define === "function" &amp;&amp; define.amd ) {<br/>	define( "jquery", [], function() {<br/>		return jQuery;<br/>	} );<br/>}<br/><br/><br/><br/><br/>var<br/><br/>	// Map over jQuery in case of overwrite<br/>	_jQuery = window.jQuery,<br/><br/>	// Map over the $ in case of overwrite<br/>	_$ = window.$;<br/><br/>jQuery.noConflict = function( deep ) {<br/>	if ( window.$ === jQuery ) {<br/>		window.$ = _$;<br/>	}<br/><br/>	if ( deep &amp;&amp; window.jQuery === jQuery ) {<br/>		window.jQuery = _jQuery;<br/>	}<br/><br/>	return jQuery;<br/>};<br/><br/>// Expose jQuery and $ identifiers, even in AMD<br/>// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)<br/>// and CommonJS for browser emulators (#13566)<br/>if ( !noGlobal ) {<br/>	window.jQuery = window.$ = jQuery;<br/>}<br/><br/><br/><br/><br/>return jQuery;<br/>} );<br/>
		</div>
	</body>
</html>
